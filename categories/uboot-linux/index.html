<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="robots" content="noindex"><meta><title>分类: uboot_linux - Hexo</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="Hexo"><meta name="msapplication-TileImage" content="/img/favicon.svg"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="Hexo"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta property="og:type" content="blog"><meta property="og:title" content="Hexo"><meta property="og:url" content="https://satelite98.github.io/"><meta property="og:site_name" content="Hexo"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://satelite98.github.io/img/og_image.png"><meta property="article:author" content="John Doe"><meta property="twitter:card" content="summary"><meta property="twitter:image:src" content="https://satelite98.github.io/img/og_image.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://satelite98.github.io"},"headline":"Hexo","image":["https://satelite98.github.io/img/og_image.png"],"author":{"@type":"Person","name":"John Doe"},"publisher":{"@type":"Organization","name":"Hexo","logo":{"@type":"ImageObject","url":"https://satelite98.github.io/img/logo.svg"}},"description":""}</script><link rel="icon" href="/img/favicon.svg"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v6.0.0/css/all.css"><link data-pjax rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@11.7.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link data-pjax rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/css/justifiedGallery.min.css"><!--!--><!--!--><!--!--><style>.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pace-inactive{display:none}.pace .pace-progress{background:#3273dc;position:fixed;z-index:2000;top:0;right:100%;width:100%;height:2px}</style><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js"></script><!--!--><!--!--><!-- hexo injector head_end start --><script>
  (function () {
      function switchTab() {
          if (!location.hash) {
            return;
          }

          const id = '#' + CSS.escape(location.hash.substring(1));
          const $tabMenu = document.querySelector(`.tabs a[href="${id}"]`);
          if (!$tabMenu) {
            return;
          }

          const $tabMenuContainer = $tabMenu.parentElement.parentElement;
          Array.from($tabMenuContainer.children).forEach($menu => $menu.classList.remove('is-active'));
          Array.from($tabMenuContainer.querySelectorAll('a'))
              .map($menu => document.getElementById($menu.getAttribute("href").substring(1)))
              .forEach($content => $content.classList.add('is-hidden'));

          if ($tabMenu) {
              $tabMenu.parentElement.classList.add('is-active');
          }
          const $activeTab = document.querySelector(id);
          if ($activeTab) {
              $activeTab.classList.remove('is-hidden');
          }
      }
      switchTab();
      window.addEventListener('hashchange', switchTab, false);
  })();
  </script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.2.0"></head><body class="is-2-column"><nav class="navbar navbar-main"><div class="container navbar-container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/logo.svg" alt="Hexo" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/about">About</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-8-widescreen"><div class="card"><div class="card-content"><nav class="breadcrumb" aria-label="breadcrumbs"><ul><li><a href="/categories">分类</a></li><li class="is-active"><a href="#" aria-current="page">uboot_linux</a></li></ul></nav></div></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2024-06-06T15:00:09.074Z" title="2024/6/6 23:00:09">2024-06-06</time>发表</span><span class="level-item"><time dateTime="2024-06-06T15:02:56.681Z" title="2024/6/6 23:02:56">2024-06-06</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/uboot-linux/">uboot_linux</a></span><span class="level-item">11 分钟读完 (大约1608个字)</span></div></div><div class="content"><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/liangliangge/p/12549087.html">https://www.cnblogs.com/liangliangge/p/12549087.html</a>  cortex-A7 的中断处理流程</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//程序入口</span></span><br><span class="line">_start:</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SYS_DV_NOR_BOOT_CFG</span></span><br><span class="line">	.word	CONFIG_SYS_DV_NOR_BOOT_CFG</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	b	reset	<span class="comment">//strart 会 直接跳转到reset 地址去</span></span><br><span class="line">	ldr	pc, _undefined_instruction	<span class="comment">//发生异常时，会跳到该指令处，然后执行指令ldr	pc, _undefined_instruction ，便会跳转到_undefined_instruction 这个符号地址去了。</span></span><br><span class="line">	ldr	pc, _software_interrupt</span><br><span class="line">	ldr	pc, _prefetch_abort</span><br><span class="line">	ldr	pc, _data_abort</span><br><span class="line">	ldr	pc, _not_used</span><br><span class="line">	ldr	pc, _irq</span><br><span class="line">	ldr	pc, _fiq</span><br></pre></td></tr></table></figure>

<ul>
<li><p>全局配置的结构体</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">global_data</span> &#123;</span></span><br><span class="line">	<span class="type">bd_t</span> *bd;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> flags;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> baudrate;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> cpu_clk;	<span class="comment">/* CPU clock in Hz!		*/</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> bus_clk;</span><br><span class="line">	<span class="comment">/* We cannot bracket this with CONFIG_PCI due to mpc5xxx */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> pci_clk;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> mem_clk;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(CONFIG_LCD) || defined(CONFIG_VIDEO)</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> fb_base;	<span class="comment">/* Base address of framebuffer mem */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(CONFIG_POST) || defined(CONFIG_LOGBUFFER)</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> post_log_word;  <span class="comment">/* Record POST activities */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> post_log_res; <span class="comment">/* success of POST test */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> post_init_f_time;  <span class="comment">/* When post_init_f started */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_BOARD_TYPES</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> board_type;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> have_console;	<span class="comment">/* serial_init() was called */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_PRE_CONSOLE_BUFFER</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> precon_buf_idx;	<span class="comment">/* Pre-Console buffer index */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> env_addr;	<span class="comment">/* Address  of Environment struct */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> env_valid;	<span class="comment">/* Checksum of Environment valid? */</span></span><br><span class="line"></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> ram_top;	<span class="comment">/* Top address of RAM used by U-Boot */</span></span><br><span class="line"></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> relocaddr;	<span class="comment">/* Start address of U-Boot in RAM */</span></span><br><span class="line">	<span class="type">phys_size_t</span> ram_size;	<span class="comment">/* RAM size */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SYS_MEM_RESERVE_SECURE</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MEM_RESERVE_SECURE_SECURED	0x1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MEM_RESERVE_SECURE_MAINTAINED	0x2</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MEM_RESERVE_SECURE_ADDR_MASK	(~0x3)</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Secure memory addr</span></span><br><span class="line"><span class="comment">	 * This variable needs maintenance if the RAM base is not zero,</span></span><br><span class="line"><span class="comment">	 * or if RAM splits into non-consecutive banks. It also has a</span></span><br><span class="line"><span class="comment">	 * flag indicating the secure memory is marked as secure by MMU.</span></span><br><span class="line"><span class="comment">	 * Flags used: 0x1 secured</span></span><br><span class="line"><span class="comment">	 *             0x2 maintained</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">phys_addr_t</span> secure_ram;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> mon_len;	<span class="comment">/* monitor len */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> irq_sp;		<span class="comment">/* irq stack pointer */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> start_addr_sp;	<span class="comment">/* start_addr_stackpointer */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> reloc_off;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">global_data</span> *<span class="title">new_gd</span>;</span>	<span class="comment">/* relocated global data */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_DM</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">udevice</span>	*<span class="title">dm_root</span>;</span>	<span class="comment">/* Root instance for Driver Model */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">udevice</span>	*<span class="title">dm_root_f</span>;</span>	<span class="comment">/* Pre-relocation root instance */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">uclass_root</span>;</span>	<span class="comment">/* Head of core tree */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_TIMER</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">udevice</span>	*<span class="title">timer</span>;</span>	<span class="comment">/* Timer instance for Driver Model */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="type">const</span> <span class="type">void</span> *fdt_blob;	<span class="comment">/* Our device tree, NULL if none */</span></span><br><span class="line">	<span class="type">void</span> *new_fdt;		<span class="comment">/* Relocated FDT */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> fdt_size;	<span class="comment">/* Space reserved for relocated FDT */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">jt_funcs</span> *<span class="title">jt</span>;</span>		<span class="comment">/* jump table */</span></span><br><span class="line">	<span class="type">char</span> env_buf[<span class="number">32</span>];	<span class="comment">/* buffer for getenv() before reloc. */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_TRACE</span></span><br><span class="line">	<span class="type">void</span>		*trace_buff;	<span class="comment">/* The trace buffer */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(CONFIG_SYS_I2C)</span></span><br><span class="line">	<span class="type">int</span>		cur_i2c_bus;	<span class="comment">/* current used i2c bus */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SYS_I2C_MXC</span></span><br><span class="line">	<span class="type">void</span> *srdata[<span class="number">10</span>];</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> timebase_h;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> timebase_l;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SYS_MALLOC_F_LEN</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> malloc_base;	<span class="comment">/* base address of early malloc() */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> malloc_limit;	<span class="comment">/* limit address */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> malloc_ptr;	<span class="comment">/* current address */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_PCI</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">pci_controller</span> *<span class="title">hose</span>;</span>	<span class="comment">/* PCI hose for early use */</span></span><br><span class="line">	<span class="type">phys_addr_t</span> pci_ram_top;	<span class="comment">/* top of region accessible to PCI */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_PCI_BOOTDELAY</span></span><br><span class="line">	<span class="type">int</span> pcidelay_done;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">udevice</span> *<span class="title">cur_serial_dev</span>;</span>	<span class="comment">/* current serial device */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">arch_global_data</span> <span class="title">arch</span>;</span>	<span class="comment">/* architecture-specific data */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_CONSOLE_RECORD</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">membuff</span> <span class="title">console_out</span>;</span>	<span class="comment">/* console output */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">membuff</span> <span class="title">console_in</span>;</span>	<span class="comment">/* console input */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_DM_VIDEO</span></span><br><span class="line">	ulong video_top;		<span class="comment">/* Top of video frame buffer area */</span></span><br><span class="line">	ulong video_bottom;		<span class="comment">/* Bottom of video frame buffer area */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125; <span class="type">gd_t</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>


</li>
<li><p>这句话 是怎么实现函数指针跳转到对应函数的？-后面有具体实现的，只是clangd没有跳转过去。</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="title function_">int</span> <span class="params">(*<span class="type">init_fnc_t</span>)</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">initcall_run_list</span><span class="params">(<span class="type">const</span> <span class="type">init_fnc_t</span> init_sequence[])</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">initcall_run_list</span><span class="params">(<span class="type">const</span> <span class="type">init_fnc_t</span> init_sequence[])</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">const</span> <span class="type">init_fnc_t</span> *init_fnc_ptr;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (init_fnc_ptr = init_sequence; *init_fnc_ptr; ++init_fnc_ptr) &#123;</span><br><span class="line">		<span class="type">unsigned</span> <span class="type">long</span> reloc_ofs = <span class="number">0</span>;</span><br><span class="line">		<span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (gd-&gt;flags &amp; GD_FLG_RELOC)</span><br><span class="line">			reloc_ofs = gd-&gt;reloc_off;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_EFI_APP</span></span><br><span class="line">		reloc_ofs = (<span class="type">unsigned</span> <span class="type">long</span>)image_base;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">		debug(<span class="string">&quot;initcall: %p&quot;</span>, (<span class="type">char</span> *)*init_fnc_ptr - reloc_ofs);</span><br><span class="line">		<span class="keyword">if</span> (gd-&gt;flags &amp; GD_FLG_RELOC)</span><br><span class="line">			debug(<span class="string">&quot; (relocated to %p)\n&quot;</span>, (<span class="type">char</span> *)*init_fnc_ptr);</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			debug(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">		ret = (*init_fnc_ptr)();</span><br><span class="line">		<span class="keyword">if</span> (ret) &#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;initcall sequence %p failed at call %p (err=%d)\n&quot;</span>,</span><br><span class="line">			       init_sequence,</span><br><span class="line">			       (<span class="type">char</span> *)*init_fnc_ptr - reloc_ofs, ret);</span><br><span class="line">			<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>uboot 命令分析</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#define U_BOOT_CMD_MKENT_COMPLETE(_name, _maxargs, _rep, _cmd,		\</span></span><br><span class="line">				_usage, _<span class="built_in">help</span>, _comp)			\</span><br><span class="line">		&#123; <span class="comment">#_name, _maxargs, _rep, _cmd, _usage,			\</span></span><br><span class="line">			_CMD_HELP(_<span class="built_in">help</span>) _CMD_COMPLETE(_comp) &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">#define U_BOOT_CMD_MKENT(_name, _maxargs, _rep, _cmd, _usage, _help)	\</span></span><br><span class="line">	U_BOOT_CMD_MKENT_COMPLETE(_name, _maxargs, _rep, _cmd,		\</span><br><span class="line">					_usage, _<span class="built_in">help</span>, NULL)</span><br><span class="line"></span><br><span class="line"><span class="comment">#define U_BOOT_CMD_COMPLETE(_name, _maxargs, _rep, _cmd, _usage, _help, _comp) \</span></span><br><span class="line">	ll_entry_declare(cmd_tbl_t, _name, cmd) =			\</span><br><span class="line">		U_BOOT_CMD_MKENT_COMPLETE(_name, _maxargs, _rep, _cmd,	\</span><br><span class="line">						_usage, _<span class="built_in">help</span>, _comp);</span><br><span class="line"></span><br><span class="line"><span class="comment">#define U_BOOT_CMD(_name, _maxargs, _rep, _cmd, _usage, _help)		\</span></span><br><span class="line">	U_BOOT_CMD_COMPLETE(_name, _maxargs, _rep, _cmd, _usage, _<span class="built_in">help</span>, NULL)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>可以看出有以下几点：</p>
<ol>
<li><p><code>U_BOOT_CMD</code>就是<code>U_BOOT_CMD_COMPLETE</code>的宏参数最后一个为<strong>NULL</strong></p>
</li>
<li><p><code>U_BOOT_CMD_COMPLETE</code>会继续调用<code>ll_entry_declare</code>和<code>U_BOOT_CMD_MKENT_COMPLETE</code>函数。分别显示如下</p>
<ul>
<li><pre><code class="python">#define ll_entry_declare(_type, _name, _list)				\
    _type _u_boot_list_2_##_list##_2_##_name __aligned(4)		\
            __attribute__((unused,				\
            section(&quot;.u_boot_list_2_&quot;#_list&quot;_2_&quot;#_name)))
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">* ```python</span><br><span class="line">  #define U_BOOT_CMD_MKENT_COMPLETE(_name, _maxargs, _rep, _cmd,\</span><br><span class="line">  				_usage, _help, _comp)			\</span><br><span class="line">  		&#123; #_name, _maxargs, _rep, _cmd, _usage,			\</span><br><span class="line">  			_CMD_HELP(_help) _CMD_COMPLETE(_comp) &#125;</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
</li>
<li><p>其中再次调用了<code>_CMD_HELP(_help) _CMD_COMPLETE(_comp)</code>这两部分定义如下(相关宏已经定义了)：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_AUTO_COMPLETE</span></span><br><span class="line"><span class="comment">//# define _CMD_COMPLETE(x) x,</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="comment">//# define _CMD_COMPLETE(x)</span></span><br><span class="line"><span class="comment">//#endif</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SYS_LONGHELP</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> _CMD_HELP(x) x,</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="comment">//# define _CMD_HELP(x)</span></span><br><span class="line"><span class="comment">//#endif</span></span><br></pre></td></tr></table></figure></li>
</ol>
<ul>
<li>利用一个CMD来分析</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">U_BOOT_CMD(</span><br><span class="line">	spibootldr, <span class="number">2</span>, <span class="number">0</span>, do_spibootldr,</span><br><span class="line">	<span class="string">&quot;boot ldr image from spi&quot;</span>,</span><br><span class="line">	<span class="string">&quot;[offset]\n&quot;</span></span><br><span class="line">	<span class="string">&quot;    - boot ldr image stored at offset into spi\n&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>经过上述的分析，此命令可以被解析为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">--ll_entry_declare(_type, _name, _list)</span><br><span class="line">  -&gt;  <span class="type">cmd_tbl_t</span> _u_boot_list_2_spibootldr_2_spibootldr __aligned(<span class="number">4</span>)		\</span><br><span class="line">			__attribute__((unused,				\</span><br><span class="line">			section(<span class="string">&quot;.u_boot_list_2_do_spibootldr_2_spibootldr)))</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">--&#123; &quot;</span>spibootldr<span class="string">&quot;, 2, 0, do_spibootldr,&quot;</span> boot ldr image from spi<span class="string">&quot;,			\</span></span><br><span class="line"><span class="string">			&quot;</span>[offset]\n<span class="string">&quot;&quot;</span>- boot ldr image stored at offset into spi\n<span class="string">&quot;, NULL, &#125;               </span></span><br></pre></td></tr></table></figure>

<p><code>##</code> 连接符:表示后面直接链接</p>
<p><code>#</code> 字符串化：表示将传来的参数字符串化。</p>
<p>所以最后实现的语句如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">cmd_tbl_t</span> _u_boot_list_2_spibootldr_2_spibootldr __aligned(<span class="number">4</span>)		\</span><br><span class="line">__attribute__((unused, section(<span class="string">&quot;.u_boot_list_2_do_spibootldr_2_spibootldr&quot;</span>))) </span><br><span class="line">                               = &#123; <span class="string">&quot;spibootldr&quot;</span>, <span class="number">2</span>, <span class="number">0</span>, do_spibootldr,</span><br><span class="line">                                  <span class="string">&quot; boot ldr image from spi&quot;</span>,</span><br><span class="line">                                  <span class="string">&quot;[offset]\n&quot;</span><span class="string">&quot;- boot ldr image stored at offset into spi\n&quot;</span>,</span><br><span class="line">                                  <span class="literal">NULL</span>, &#125; </span><br></pre></td></tr></table></figure>

<p>4字节对齐定义了一个<code>cmd_tbl_t</code>的结构体变量<code>_u_boot_list_2_spibootldr_2_spibootldr</code>，且被划分到了<code>u_boot_list_2_do_spibootldr_2_spibootldr</code> section。</p>
<ul>
<li>其中对于<code>cmd_tbl_t</code> 有以下定义:</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cmd_tbl_s</span> &#123;</span></span><br><span class="line">	<span class="type">char</span>		*name;		<span class="comment">/* Command Name	  		*/</span>          </span><br><span class="line">	<span class="type">int</span>		maxargs;	<span class="comment">/* maximum number of arguments	*/</span></span><br><span class="line">	<span class="type">int</span>		repeatable;	<span class="comment">/* autorepeat allowed?		*/</span></span><br><span class="line">					<span class="comment">/* Implementation function	*/</span></span><br><span class="line">	<span class="type">int</span>		(*cmd)(<span class="keyword">struct</span> cmd_tbl_s *, <span class="type">int</span>, <span class="type">int</span>, <span class="type">char</span> * <span class="type">const</span> []);  <span class="comment">/* 函数指针 */</span></span><br><span class="line">	<span class="type">char</span>		*usage;		<span class="comment">/* Usage message	(short)	*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span>	CONFIG_SYS_LONGHELP</span></span><br><span class="line">	<span class="type">char</span>		*help;		<span class="comment">/* Help  message	(long)	*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_AUTO_COMPLETE</span></span><br><span class="line">	<span class="comment">/* do auto completion on the arguments */</span></span><br><span class="line">	<span class="type">int</span>		(*complete)(<span class="type">int</span> argc, <span class="type">char</span> * <span class="type">const</span> argv[], <span class="type">char</span> last_char, <span class="type">int</span> maxv, <span class="type">char</span> *cmdv[]);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>section 在内存中的存储位置如下所示：四字节对齐之后存储在rodata 段之后。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">.rodata : &#123; *(SORT_BY_ALIGNMENT(SORT_BY_NAME(.rodata*))) &#125;</span><br><span class="line">. = ALIGN(<span class="number">4</span>);</span><br><span class="line">.data : &#123;</span><br><span class="line"> *(.data*)</span><br><span class="line">&#125;</span><br><span class="line">. = ALIGN(<span class="number">4</span>);</span><br><span class="line">. = .;</span><br><span class="line">. = ALIGN(<span class="number">4</span>);</span><br><span class="line">.u_boot_list : &#123;</span><br><span class="line"> KEEP(*(SORT(.u_boot_list*)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>对于命令结构体的处理方法如下所示：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="type">command_ret_t</span> <span class="title function_">cmd_process</span><span class="params">(<span class="type">int</span> flag, <span class="type">int</span> argc, <span class="type">char</span> * <span class="type">const</span> argv[],</span></span><br><span class="line"><span class="params">			       <span class="type">int</span> *repeatable, ulong *ticks)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">enum</span> <span class="title">command_ret_t</span> <span class="title">rc</span> =</span> CMD_RET_SUCCESS;</span><br><span class="line">	<span class="type">cmd_tbl_t</span> *cmdtp;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Look up command in command table */</span></span><br><span class="line">	cmdtp = find_cmd(argv[<span class="number">0</span>]);</span><br><span class="line">	<span class="keyword">if</span> (cmdtp == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Unknown command &#x27;%s&#x27; - try &#x27;help&#x27;\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* found - check max args */</span></span><br><span class="line">	<span class="keyword">if</span> (argc &gt; cmdtp-&gt;maxargs)</span><br><span class="line">		rc = CMD_RET_USAGE;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(CONFIG_CMD_BOOTD)</span></span><br><span class="line">	<span class="comment">/* avoid &quot;bootd&quot; recursion */</span></span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (cmdtp-&gt;cmd == do_bootd) &#123;</span><br><span class="line">		<span class="keyword">if</span> (flag &amp; CMD_FLAG_BOOTD) &#123;</span><br><span class="line">			<span class="built_in">puts</span>(<span class="string">&quot;&#x27;bootd&#x27; recursion detected\n&quot;</span>);</span><br><span class="line">			rc = CMD_RET_FAILURE;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			flag |= CMD_FLAG_BOOTD;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* If OK so far, then do the command */</span></span><br><span class="line">	<span class="keyword">if</span> (!rc) &#123;</span><br><span class="line">		<span class="keyword">if</span> (ticks)</span><br><span class="line">			*ticks = get_timer(<span class="number">0</span>);</span><br><span class="line">		rc = cmd_call(cmdtp, flag, argc, argv);</span><br><span class="line">		<span class="keyword">if</span> (ticks)</span><br><span class="line">			*ticks = get_timer(*ticks);</span><br><span class="line">		*repeatable &amp;= cmdtp-&gt;repeatable;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (rc == CMD_RET_USAGE)</span><br><span class="line">		rc = cmd_usage(cmdtp);</span><br><span class="line">	<span class="keyword">return</span> rc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li>boot z 命令执行</li>
</ul>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2024-06-06T15:00:09.072Z" title="2024/6/6 23:00:09">2024-06-06</time>发表</span><span class="level-item"><time dateTime="2024-06-06T15:03:03.404Z" title="2024/6/6 23:03:03">2024-06-06</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/uboot-linux/">uboot_linux</a></span><span class="level-item">21 分钟读完 (大约3111个字)</span></div></div><div class="content"><h1 id="从头理清uboot（4）-boot-cmd-的处理"><a href="#从头理清uboot（4）-boot-cmd-的处理" class="headerlink" title="从头理清uboot（4）-boot_cmd 的处理"></a>从头理清uboot（4）-boot_cmd 的处理</h1><p>[toc]</p>
<p>上次我们分析到，uboot在启动linux的过程中，最后是执行<code>bootcmd</code>这个环境变量，那么我们今天来分析，这个环境变量到底执行了哪些功能，这些功能调用了哪些函数，最后是如何实现linux的boot的？</p>
<p>&#x3D;&#x3D;关于环境变量：&#x3D;&#x3D;<strong>对于imax6ull来说，都是存储在&#x2F;include&#x2F;configs&#x2F;mx6ullevk.h和include&#x2F;env_dedault.h</strong></p>
<h2 id="1-默认的bootcmd-包含了哪些内容？"><a href="#1-默认的bootcmd-包含了哪些内容？" class="headerlink" title="1. 默认的bootcmd 包含了哪些内容？"></a>1. 默认的bootcmd 包含了哪些内容？</h2><p>在<code>default_environment</code>中有定义：于是查找<code>CONFIG_BOOTCOMMAND</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span>	CONFIG_BOOTCOMMAND</span></span><br><span class="line">	<span class="string">&quot;bootcmd=&quot;</span>	CONFIG_BOOTCOMMAND		<span class="string">&quot;\0&quot;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>在<code>./include/configs/mx6ullevk.h</code>中有定义：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> CONFIG_BOOTCOMMAND \</span></span><br><span class="line"><span class="meta">	   <span class="string">&quot;run findfdt;&quot;</span> \</span></span><br><span class="line"><span class="meta">	   <span class="string">&quot;mmc dev $&#123;mmcdev&#125;;&quot;</span> \</span></span><br><span class="line"><span class="meta">	   <span class="string">&quot;mmc dev $&#123;mmcdev&#125;; if mmc rescan; then &quot;</span> \</span></span><br><span class="line"><span class="meta">		   <span class="string">&quot;if run loadbootscript; then &quot;</span> \</span></span><br><span class="line"><span class="meta">			   <span class="string">&quot;run bootscript; &quot;</span> \</span></span><br><span class="line"><span class="meta">		   <span class="string">&quot;else &quot;</span> \</span></span><br><span class="line"><span class="meta">			   <span class="string">&quot;if run loadimage; then &quot;</span> \</span></span><br><span class="line"><span class="meta">				   <span class="string">&quot;run mmcboot; &quot;</span> \</span></span><br><span class="line"><span class="meta">			   <span class="string">&quot;else run netboot; &quot;</span> \</span></span><br><span class="line"><span class="meta">			   <span class="string">&quot;fi; &quot;</span> \</span></span><br><span class="line"><span class="meta">		   <span class="string">&quot;fi; &quot;</span> \</span></span><br><span class="line"><span class="meta">	   <span class="string">&quot;else run netboot; fi&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>其中,有以下环境变量：</p>
<ul>
<li><p>findfdt：其中会用到<code>fdt_file=undefined，board_name=EVK，board_rev=14X14 </code>这三个变量，用于寻找.dtb 文件</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;findfdt=&quot;</span>\</span><br><span class="line">		<span class="string">&quot;if test $fdt_file = undefined; then &quot;</span> \</span><br><span class="line">			<span class="string">&quot;if test $board_name = EVK &amp;&amp; test $board_rev = 9X9; then &quot;</span> \</span><br><span class="line">				<span class="string">&quot;setenv fdt_file imx6ull-9x9-evk.dtb; fi; &quot;</span> \</span><br><span class="line">			<span class="string">&quot;if test $board_name = EVK &amp;&amp; test $board_rev = 14X14; then &quot;</span> \</span><br><span class="line">				<span class="string">&quot;setenv fdt_file imx6ull-14x14-evk.dtb; fi; &quot;</span> \</span><br><span class="line">			<span class="string">&quot;if test $fdt_file = undefined; then &quot;</span> \</span><br><span class="line">				<span class="string">&quot;echo WARNING: Could not determine dtb to use; fi; &quot;</span> \</span><br><span class="line">		<span class="string">&quot;fi;\0&quot;</span> \</span><br></pre></td></tr></table></figure>
</li>
<li><p>mmc dev ${mmcdev} : 用于切换mmc 设置mmc  设备</p>
</li>
<li><p>mmc rescan ：执行mmc  扫描检查，成功执行<code>run loadbootscript</code>失败就执行<code>run netboot</code>网络boot。</p>
</li>
<li><p>run loadbootscript ： </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;loadbootscript=&quot;</span> \</span><br><span class="line">	<span class="string">&quot;fatload mmc $&#123;mmcdev&#125;:$&#123;mmcpart&#125; $&#123;loadaddr&#125; $&#123;script&#125;;\0&quot;</span> \</span><br></pre></td></tr></table></figure>

<p>其中<code> mmcdev=1，mmcpart=1，loadaddr=0x80800000，script= boot.scr</code>因此展开之后为下面指令，就是从 mmc1 的分区 1 中读取文件 boot.src 到 DRAM 的 0X80800000 处，如果成功的话就执行<code>bootscript</code>不行就会执行<code>run loadimage</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">loadbootscript=fatload mmc <span class="number">1</span>:<span class="number">1</span> <span class="number">0x80800000</span> boot.scr; </span><br></pre></td></tr></table></figure>

<ul>
<li><p>bootscript：只是一个输出语句</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;bootscript=echo Running bootscript from mmc ...; &quot;</span> \</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>run loadimage：见下方注释为从mmc 加载zImage到0x80800000地址处。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;loadimage=fatload mmc $&#123;mmcdev&#125;:$&#123;mmcpart&#125; $&#123;loadaddr&#125; $&#123;image&#125;\0&quot;</span> \</span><br><span class="line">  <span class="comment">/* 其中：  mmcdev=1、mmcpart=1  loadaddr=0x80800000、image = zImage 所以展开之后就是：*/</span> </span><br><span class="line">    loadimage=fatload mmc <span class="number">1</span>:<span class="number">1</span> <span class="number">0x80800000</span> zImage  </span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="1-1-mmcboot"><a href="#1-1-mmcboot" class="headerlink" title="1.1 mmcboot"></a>1.1 mmcboot</h3><p>mmcboot 的源码如下：</p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;mmcboot=echo Booting from mmc ...; &quot;</span> \</span><br><span class="line">	<span class="string">&quot;run mmcargs; &quot;</span> \</span><br><span class="line">	<span class="string">&quot;if test $&#123;boot_fdt&#125; = yes || test $&#123;boot_fdt&#125; = try; then &quot;</span> \</span><br><span class="line">		<span class="string">&quot;if run loadfdt; then &quot;</span> \</span><br><span class="line">			<span class="string">&quot;bootz $&#123;loadaddr&#125; - $&#123;fdt_addr&#125;; &quot;</span> \</span><br><span class="line">		<span class="string">&quot;else &quot;</span> \</span><br><span class="line">			<span class="string">&quot;if test $&#123;boot_fdt&#125; = try; then &quot;</span> \</span><br><span class="line">		<span class="string">&quot;bootz; &quot;</span> \</span><br><span class="line">			<span class="string">&quot;else &quot;</span> \</span><br><span class="line">		<span class="string">&quot;echo WARN: Cannot load the DT; &quot;</span> \</span><br><span class="line">			<span class="string">&quot;fi; &quot;</span> \</span><br><span class="line">		<span class="string">&quot;fi; &quot;</span> \</span><br><span class="line">	<span class="string">&quot;else &quot;</span> \</span><br><span class="line">		<span class="string">&quot;bootz; &quot;</span> \</span><br><span class="line">	<span class="string">&quot;fi;\0&quot;</span> \</span><br></pre></td></tr></table></figure>

<ul>
<li>其中第一行是设置boot 参数</li>
</ul>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">	<span class="string">&quot;mmcargs=setenv bootargs console=$&#123;console&#125;,$&#123;baudrate&#125; &quot;</span> \</span><br><span class="line">CONFIG_BOOTARGS_CMA_SIZE \</span><br><span class="line">		CONFIG_MFG_NAND_PARTITION \</span><br><span class="line">		<span class="string">&quot;root=$&#123;mmcroot&#125;\0&quot;</span> \</span><br><span class="line"> <span class="comment">/*&quot;console=ttymxc&quot;  baudrate=115200  mmcroot=&quot;/dev/mmcblk1p2&quot;rootwait rw */</span> </span><br><span class="line"> 所以这句话为：</span><br><span class="line">mmcargs=setenv bootargs  console=ttymxc0,<span class="number">115200</span>  <span class="string">&quot;&quot;</span> <span class="string">&quot;&quot;</span> root=/dev/mmcblk1p2 rootwait rw</span><br></pre></td></tr></table></figure>

<ul>
<li><p>由于<code>&quot;boot_fdt=try\0&quot; \</code>所以执行<code>loadfdt</code>,由于<code>fdt_file</code>在之前<code>findfdt</code>时候初始化过了，所以额这里就是load dtb 文件到<code>0x83000000</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;loadfdt=fatload mmc $&#123;mmcdev&#125;:$&#123;mmcpart&#125; $&#123;fdt_addr&#125; $&#123;fdt_file&#125;\0&quot;</span> \</span><br><span class="line"> <span class="comment">/* mmcdev=1、mmcpart=1 fdt_addr=0x83000000 、fdt_file= imx6ull-14x14-evk.dtb \0 */</span></span><br><span class="line">    fatload mmc <span class="number">1</span>:<span class="number">1</span> <span class="number">0x83000000</span> imx6ull<span class="number">-14</span>x14-evk.dtb</span><br></pre></td></tr></table></figure></li>
</ul>
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">* 于是` run loadfdt`执行成功，就会执行指令：</span><br><span class="line"></span><br><span class="line">  ```c</span><br><span class="line">  bootz $&#123;loadaddr&#125; - $&#123;fdt_addr&#125;;</span><br><span class="line">  /* loadaddr =  0x80800000  fdt_addr=0x83000000*/</span><br><span class="line">  bootz 0x80800000 - 0x83000000 </span><br></pre></td></tr></table></figure>

<h3 id="1-2-netboot"><a href="#1-2-netboot" class="headerlink" title="1.2 netboot"></a>1.2 netboot</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;netboot=echo Booting from net ...; &quot;</span> \</span><br><span class="line"><span class="string">&quot;run netargs; &quot;</span> \</span><br><span class="line"><span class="string">&quot;if test $&#123;ip_dyn&#125; = yes; then &quot;</span> \</span><br><span class="line">	<span class="string">&quot;setenv get_cmd dhcp; &quot;</span> \</span><br><span class="line"><span class="string">&quot;else &quot;</span> \</span><br><span class="line">	<span class="string">&quot;setenv get_cmd tftp; &quot;</span> \</span><br><span class="line"><span class="string">&quot;fi; &quot;</span> \</span><br><span class="line"><span class="string">&quot;$&#123;get_cmd&#125; $&#123;image&#125;; &quot;</span> \</span><br><span class="line"><span class="string">&quot;if test $&#123;boot_fdt&#125; = yes || test $&#123;boot_fdt&#125; = try; then &quot;</span> \</span><br><span class="line">	<span class="string">&quot;if $&#123;get_cmd&#125; $&#123;fdt_addr&#125; $&#123;fdt_file&#125;; then &quot;</span> \</span><br><span class="line">		<span class="string">&quot;bootz $&#123;loadaddr&#125; - $&#123;fdt_addr&#125;; &quot;</span> \</span><br><span class="line">	<span class="string">&quot;else &quot;</span> \</span><br><span class="line">		<span class="string">&quot;if test $&#123;boot_fdt&#125; = try; then &quot;</span> \</span><br><span class="line">			<span class="string">&quot;bootz; &quot;</span> \</span><br><span class="line">		<span class="string">&quot;else &quot;</span> \</span><br><span class="line">			<span class="string">&quot;echo WARN: Cannot load the DT; &quot;</span> \</span><br><span class="line">		<span class="string">&quot;fi; &quot;</span> \</span><br><span class="line">	<span class="string">&quot;fi; &quot;</span> \</span><br><span class="line"><span class="string">&quot;else &quot;</span> \</span><br><span class="line">	<span class="string">&quot;bootz; &quot;</span> \</span><br><span class="line"><span class="string">&quot;fi;\0&quot;</span> \</span><br></pre></td></tr></table></figure>

<h3 id="1-3-小总结"><a href="#1-3-小总结" class="headerlink" title="1.3 小总结"></a>1.3 小总结</h3><ul>
<li>对于<code>mmc_boot</code>有效的信息如下：<ol>
<li>给<code>findfdt</code>赋值，设置dtb文件：<code>setenv fdt_file imx6ull-14x14-evk.dtb</code></li>
<li>设置mmc 设备: <code>mmc dev 1</code></li>
<li>加载镜像：<code>fatload mmc 1:1 0x80800000 zImage  </code></li>
<li>设置bootargs：<code>setenv bootargs  console=ttymxc0,115200  &quot;&quot; &quot;&quot; root=/dev/mmcblk1p2 rootwait rw</code></li>
<li>加载dtb：<code>fatload mmc 1:1 0x83000000 imx6ull-14x14-evk.dtb</code></li>
<li>启动：<code>bootz 0x80800000 - 0x83000000 </code></li>
</ol>
</li>
</ul>
<h3 id="1-4-关于bootargs"><a href="#1-4-关于bootargs" class="headerlink" title="1.4 关于bootargs"></a>1.4 关于<code>bootargs</code></h3><ul>
<li><p>bootargs 是uboot 传递给linux 中的参数，上述解析之后的参数见下方：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mmcargs=setenv bootargs  console=ttymxc0,<span class="number">115200</span>  <span class="string">&quot;&quot;</span> <span class="string">&quot;&quot;</span> root=/dev/mmcblk1p2 rootwait rw</span><br></pre></td></tr></table></figure>

<p>其中有三个设置点：</p>
<ol>
<li>console ：设置Linux的输出窗口，由于mx6ull中，串口0的表示是<code>/dev/ttymxc0</code>所以设置输出窗口为这个。</li>
<li>root ：设置根文件系统的位置，告诉Linux在哪里寻找根文件系统。<code>/dev/mmcblk1p2 </code>表示在ima6ull的分区2中。后续还有<code>“rootwait rw”</code>数据，表示等待根文件系统挂载完毕才加载，rw表示文件系统是可读写的。</li>
</ol>
</li>
</ul>
<h2 id="2-boot-linux-函数过程"><a href="#2-boot-linux-函数过程" class="headerlink" title="2. boot-linux 函数过程"></a>2. boot-linux 函数过程</h2><p>​		上面分析到，在把image和dtb 搬运到固定地址之后，执行<code>bootz 0x80800000 - 0x83000000</code>指令，进入linux 的boot 阶段。<code>bootz</code>指令的定义如下，于是可以发现是执行<code>do_bootz</code>函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">U_BOOT_CMD(</span><br><span class="line">	bootz,	CONFIG_SYS_MAXARGS,	<span class="number">1</span>,	do_bootz,</span><br><span class="line">	<span class="string">&quot;boot Linux zImage image from memory&quot;</span>, bootz_help_text</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<h3 id="2-1-结构体简单介绍"><a href="#2-1-结构体简单介绍" class="headerlink" title="2.1 结构体简单介绍"></a>2.1 结构体简单介绍</h3><p>uboot 中 定义了<code>bootm_headers_t</code>和<code>image_header_t</code>结构体分别用来抽象image 信息和 image 头部信息。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">bootm_headers</span> &#123;</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Legacy os image header, if it is a multi component image</span></span><br><span class="line"><span class="comment">	 * then boot_get_ramdisk() and get_fdt() will attempt to get</span></span><br><span class="line"><span class="comment">	 * data from second and third component accordingly.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">image_header_t</span>	*legacy_hdr_os;		<span class="comment">/* image header pointer */</span></span><br><span class="line">	<span class="type">image_header_t</span>	legacy_hdr_os_copy;	<span class="comment">/* header copy */</span></span><br><span class="line">	ulong		legacy_hdr_valid;</span><br><span class="line">    <span class="meta">#<span class="keyword">ifndef</span> USE_HOSTCC</span></span><br><span class="line">	<span class="type">image_info_t</span>	os;		<span class="comment">/* os image info */</span></span><br><span class="line">	ulong		ep;		<span class="comment">/* entry point of OS */</span></span><br><span class="line"></span><br><span class="line">	ulong		rd_start, rd_end;<span class="comment">/* ramdisk start/end */</span></span><br><span class="line"></span><br><span class="line">	<span class="type">char</span>		*ft_addr;	<span class="comment">/* flat dev tree address */</span></span><br><span class="line">	ulong		ft_len;		<span class="comment">/* length of flat device tree */</span></span><br><span class="line"></span><br><span class="line">	ulong		initrd_start;</span><br><span class="line">	ulong		initrd_end;</span><br><span class="line">	ulong		cmdline_start;</span><br><span class="line">	ulong		cmdline_end;</span><br><span class="line">	<span class="type">bd_t</span>		*kbd;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="type">int</span>		verify;		<span class="comment">/* getenv(&quot;verify&quot;)[0] != &#x27;n&#x27; */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	BOOTM_STATE_START	(0x00000001)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	BOOTM_STATE_FINDOS	(0x00000002)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	BOOTM_STATE_FINDOTHER	(0x00000004)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	BOOTM_STATE_LOADOS	(0x00000008)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	BOOTM_STATE_RAMDISK	(0x00000010)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	BOOTM_STATE_FDT		(0x00000020)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	BOOTM_STATE_OS_CMDLINE	(0x00000040)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	BOOTM_STATE_OS_BD_T	(0x00000080)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	BOOTM_STATE_OS_PREP	(0x00000100)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	BOOTM_STATE_OS_FAKE_GO	(0x00000200)	<span class="comment">/* &#x27;Almost&#x27; run the OS */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	BOOTM_STATE_OS_GO	(0x00000400)</span></span><br><span class="line">	<span class="type">int</span>		state;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_LMB</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">lmb</span>	<span class="title">lmb</span>;</span>		<span class="comment">/* for memory mgmt */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125; <span class="type">bootm_headers_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">bootm_headers_t</span> images;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 其中，header 再定义为： */</span></span><br><span class="line"> <span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">image_header</span> &#123;</span></span><br><span class="line">	__be32		ih_magic;	<span class="comment">/* Image Header Magic Number	*/</span></span><br><span class="line">	__be32		ih_hcrc;	<span class="comment">/* Image Header CRC Checksum	*/</span></span><br><span class="line">	__be32		ih_time;	<span class="comment">/* Image Creation Timestamp	*/</span></span><br><span class="line">	__be32		ih_size;	<span class="comment">/* Image Data Size		*/</span></span><br><span class="line">	__be32		ih_load;	<span class="comment">/* Data	 Load  Address		*/</span></span><br><span class="line">	__be32		ih_ep;		<span class="comment">/* Entry Point Address		*/</span></span><br><span class="line">	__be32		ih_dcrc;	<span class="comment">/* Image Data CRC Checksum	*/</span></span><br><span class="line">	<span class="type">uint8_t</span>		ih_os;		<span class="comment">/* Operating System		*/</span></span><br><span class="line">	<span class="type">uint8_t</span>		ih_arch;	<span class="comment">/* CPU architecture		*/</span></span><br><span class="line">	<span class="type">uint8_t</span>		ih_type;	<span class="comment">/* Image Type			*/</span></span><br><span class="line">	<span class="type">uint8_t</span>		ih_comp;	<span class="comment">/* Compression Type		*/</span></span><br><span class="line">	<span class="type">uint8_t</span>		ih_name[IH_NMLEN];	<span class="comment">/* Image Name		*/</span></span><br><span class="line">&#125; <span class="type">image_header_t</span>;</span><br></pre></td></tr></table></figure>

<h3 id="2-2-do-bootz函数分析"><a href="#2-2-do-bootz函数分析" class="headerlink" title="2.2 do_bootz函数分析"></a>2.2 do_bootz函数分析</h3><p>​		<code>do_bootz</code>会调用<code>bootz_start</code>准备好环境之后，关闭<code>中断</code>，在设置要启动的系统是<code>IH_OS_LINUX</code>之后，就会利用<code>do_bootm_states</code>函数启动linux。源码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">do_bootz</span><span class="params">(<span class="type">cmd_tbl_t</span> *cmdtp, <span class="type">int</span> flag, <span class="type">int</span> argc, <span class="type">char</span> * <span class="type">const</span> argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> ret;</span><br><span class="line">	<span class="comment">/* Consume &#x27;bootz&#x27;  过滤掉bootz 参数，这样子addr= argv[0] */</span> </span><br><span class="line">	argc--; argv++;</span><br><span class="line">	<span class="keyword">if</span> (bootz_start(cmdtp, flag, argc, argv, &amp;images))</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    bootm_disable_interrupts();</span><br><span class="line">	</span><br><span class="line">    images.os.os = IH_OS_LINUX;</span><br><span class="line">	ret = do_bootm_states(cmdtp, flag, argc, argv,</span><br><span class="line">			      BOOTM_STATE_OS_PREP | BOOTM_STATE_OS_FAKE_GO |</span><br><span class="line">			      BOOTM_STATE_OS_GO,</span><br><span class="line">			      &amp;images, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-2-1-bootz-start-函数"><a href="#2-2-1-bootz-start-函数" class="headerlink" title="2.2.1 bootz_start 函数"></a>2.2.1 bootz_start 函数</h4><ul>
<li><p>见下方，bootz_start的主要功能为：</p>
<ul>
<li>调用 do_bootm_states,且把状态设置为 <code>BOOTM_STATE_START </code>准备环境，释放原来<code>images</code>占用的区域。</li>
<li>设置<code>images-&gt;ep</code>这个地址是image 的启动地址（entry-point）。</li>
<li>把<code>images-&gt;ep</code>头部指针传递给<code>bootz_setup</code>,在里面会做是否是linux  系统image 的判定，并且获得起始和结束位置，如果不是的话会报错，给image  指针重定位。</li>
<li>调用<code>lmb_reserve</code>将image 占用的内存大小和区域设置为已经使用的区域。</li>
<li>调用<code>bootm_find_images</code>去找到dtb 文件，并且将地址和长度信息，存储到全局变量<code>images</code>中。</li>
</ul>
<p>做完以上之后，就会调用<code>do_bootm_states</code>,并且设置对应状态 启动inux。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">bootz_start</span><span class="params">(<span class="type">cmd_tbl_t</span> *cmdtp, <span class="type">int</span> flag, <span class="type">int</span> argc,</span></span><br><span class="line"><span class="params">			<span class="type">char</span> * <span class="type">const</span> argv[], <span class="type">bootm_headers_t</span> *images)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> ret;</span><br><span class="line">	ulong zi_start, zi_end;</span><br><span class="line">	ret = do_bootm_states(cmdtp, flag, argc, argv, BOOTM_STATE_START,</span><br><span class="line">			      images, <span class="number">1</span>); <span class="comment">/* */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Setup Linux kernel zImage entry point */</span></span><br><span class="line">	<span class="keyword">if</span> (!argc) &#123;</span><br><span class="line">		images-&gt;ep = load_addr;</span><br><span class="line">		debug(<span class="string">&quot;*  kernel: default image load address = 0x%08lx\n&quot;</span>,</span><br><span class="line">				load_addr);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		images-&gt;ep = simple_strtoul(argv[<span class="number">0</span>], <span class="literal">NULL</span>, <span class="number">16</span>);</span><br><span class="line">		debug(<span class="string">&quot;*  kernel: cmdline image address = 0x%08lx\n&quot;</span>,</span><br><span class="line">			images-&gt;ep);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	ret = bootz_setup(images-&gt;ep, &amp;zi_start, &amp;zi_end);</span><br><span class="line">	<span class="keyword">if</span> (ret != <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	lmb_reserve(&amp;images-&gt;lmb, images-&gt;ep, zi_end - zi_start);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (bootm_find_images(flag, argc, argv))</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="2-2-2-do-bootm-states-函数"><a href="#2-2-2-do-bootm-states-函数" class="headerlink" title="2.2.2 do_bootm_states 函数"></a>2.2.2 do_bootm_states 函数</h3><ul>
<li><p><code>do_bootm_states </code>能够根据不同的状态执行不同的函数，在imax6ull 中，起到了下面这些作用：</p>
<ul>
<li>调用<code>bootm_start</code>函数，释放原来<code>images</code>指向的区域并清0。</li>
<li>调用<code>bootm_load_os</code>函数，设置对应的地址。</li>
<li>&#x3D;&#x3D;调用<code>bootm_os_get_boot_func</code>函数:&#x3D;&#x3D;找到boot 中真正使用的函数。本次boot 的os 在之前已经设置过了为<code>IH_OS_LINUX</code>于是会调用<code>do_bootm_linux</code>。后面执行的<code>boot_fn(BOOTM_STATE_OS_CMDLINE, argc, argv, images);</code>函数实际上都是由<code>do_bootm_linux</code>函数执行。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">do_bootm_states</span><span class="params">(<span class="type">cmd_tbl_t</span> *cmdtp, <span class="type">int</span> flag, <span class="type">int</span> argc, <span class="type">char</span> * <span class="type">const</span> argv[],</span></span><br><span class="line"><span class="params">		    <span class="type">int</span> states, <span class="type">bootm_headers_t</span> *images, <span class="type">int</span> boot_progress)</span></span><br><span class="line">&#123;</span><br><span class="line">	boot_os_fn *boot_fn;</span><br><span class="line">	ulong iflag = <span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> ret = <span class="number">0</span>, need_boot_fn;</span><br><span class="line"></span><br><span class="line">	images-&gt;state |= states;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Work through the states and see how far we get. We stop on</span></span><br><span class="line"><span class="comment">	 * any error.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (states &amp; BOOTM_STATE_START)</span><br><span class="line">		ret = bootm_start(cmdtp, flag, argc, argv);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!ret &amp;&amp; (states &amp; BOOTM_STATE_FINDOS))</span><br><span class="line">		ret = bootm_find_os(cmdtp, flag, argc, argv);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!ret &amp;&amp; (states &amp; BOOTM_STATE_FINDOTHER)) &#123;</span><br><span class="line">		ret = bootm_find_other(cmdtp, flag, argc, argv);</span><br><span class="line">		argc = <span class="number">0</span>;	<span class="comment">/* consume the args */</span></span><br><span class="line">	&#125;</span><br><span class="line">    ......</span><br><span class="line">        </span><br><span class="line">    boot_fn = bootm_os_get_boot_func(images-&gt;os.os);</span><br><span class="line">	need_boot_fn = states &amp; (BOOTM_STATE_OS_CMDLINE |</span><br><span class="line">			BOOTM_STATE_OS_BD_T | BOOTM_STATE_OS_PREP |</span><br><span class="line">			BOOTM_STATE_OS_FAKE_GO | BOOTM_STATE_OS_GO);</span><br><span class="line">	......</span><br><span class="line">    	<span class="comment">/*  这里实际执行的都是do_bootm_linux 函数了！ */</span></span><br><span class="line">    	<span class="comment">/* Call various other states that are not generally used */</span> </span><br><span class="line">	<span class="keyword">if</span> (!ret &amp;&amp; (states &amp; BOOTM_STATE_OS_CMDLINE))</span><br><span class="line">		ret = boot_fn(BOOTM_STATE_OS_CMDLINE, argc, argv, images);</span><br><span class="line">	<span class="keyword">if</span> (!ret &amp;&amp; (states &amp; BOOTM_STATE_OS_BD_T))</span><br><span class="line">		ret = boot_fn(BOOTM_STATE_OS_BD_T, argc, argv, images);</span><br><span class="line">	<span class="keyword">if</span> (!ret &amp;&amp; (states &amp; BOOTM_STATE_OS_PREP))</span><br><span class="line">		ret = boot_fn(BOOTM_STATE_OS_PREP, argc, argv, images);</span><br><span class="line">	......</span><br><span class="line">    	<span class="comment">/* Now run the OS! We hope this doesn&#x27;t return */</span></span><br><span class="line">	<span class="keyword">if</span> (!ret &amp;&amp; (states &amp; BOOTM_STATE_OS_GO))</span><br><span class="line">		ret = boot_selected_os(argc, argv, BOOTM_STATE_OS_GO,</span><br><span class="line">				images, boot_fn);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="2-2-3-do-bootm-linux函数"><a href="#2-2-3-do-bootm-linux函数" class="headerlink" title="2.2.3 do_bootm_linux函数"></a>2.2.3 do_bootm_linux函数</h3><p>上面说到，在本次启动过程中，最后实际调用的是<code>do_bootm_linux</code>于是再继续分析这个函数。</p>
<ul>
<li><p>我们在<code>do_bootz</code>的时候，实际调用的是这调用整个宏<code>BOOTM_STATE_OS_PREP </code>，会调用<code>boot_prep_linux(images);</code> 这个函数进行启动前的准备。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">do_bootm_linux</span><span class="params">(<span class="type">int</span> flag, <span class="type">int</span> argc, <span class="type">char</span> * <span class="type">const</span> argv[],</span></span><br><span class="line"><span class="params">		   <span class="type">bootm_headers_t</span> *images)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/* No need for those on ARM */</span></span><br><span class="line">	<span class="keyword">if</span> (flag &amp; BOOTM_STATE_OS_BD_T || flag &amp; BOOTM_STATE_OS_CMDLINE)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (flag &amp; BOOTM_STATE_OS_PREP) &#123;</span><br><span class="line">		boot_prep_linux(images);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (flag &amp; (BOOTM_STATE_OS_GO | BOOTM_STATE_OS_FAKE_GO)) &#123;</span><br><span class="line">		boot_jump_linux(images, flag);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	boot_prep_linux(images);</span><br><span class="line">	boot_jump_linux(images, flag);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>后面<code>do_bootz</code>会调用<code>boot_selected_os</code>函数，之后继续调用<code>do_bootm_linux</code>并且将flag 设置为<code>BOOTM_STATE_OS_GO</code>，执行<code>boot_jump_linux(images, flag);</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">boot_selected_os(argc, argv, BOOTM_STATE_OS_GO,</span><br><span class="line">				images, boot_fn);</span><br><span class="line"><span class="comment">/* 实际还是调用了  boot_fn(state, argc, argv, images); */</span></span><br><span class="line"><span class="comment">/* 在bootlinux 的情况下，实际执行的是：do_bootm_linux*/</span></span><br><span class="line"> do_bootm_linux (BOOTM_STATE_OS_GO,argc,argv，images)</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="2-2-4-boot-jump-linux函数"><a href="#2-2-4-boot-jump-linux函数" class="headerlink" title="2.2.4 boot_jump_linux函数"></a>2.2.4 boot_jump_linux函数</h3><ul>
<li><p>可见<code>boot_jump_linux</code>的作用如下：</p>
<ul>
<li>定义函数指针并且赋值为<code>images-&gt;ep</code>,作为程序跳转到linux 的入口。</li>
<li>获取<code>id</code>值和环境变量<code>machid</code>比较，判断是否相等。</li>
<li>清除CPU的cache 环境。</li>
<li>设置函数指针<code>kernel_entry</code>的参数，分别是0、machid、fdt地址&#x2F;或者bi_boot_params。如果不使用设备数的话，就是<code>bootargs</code></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Subcommand: GO */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">boot_jump_linux</span><span class="params">(<span class="type">bootm_headers_t</span> *images, <span class="type">int</span> flag)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> machid = gd-&gt;bd-&gt;bi_arch_number;</span><br><span class="line">	<span class="type">char</span> *s;</span><br><span class="line">	<span class="type">void</span> (*kernel_entry)(<span class="type">int</span> zero, <span class="type">int</span> arch, uint params);<span class="comment">/* 定义函数指针 */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> r2;</span><br><span class="line">	<span class="type">int</span> fake = (flag &amp; BOOTM_STATE_OS_FAKE_GO);</span><br><span class="line"></span><br><span class="line">	kernel_entry = (<span class="type">void</span> (*)(<span class="type">int</span>, <span class="type">int</span>, uint))images-&gt;ep; <span class="comment">/*给函数指针赋值为*/</span></span><br><span class="line"></span><br><span class="line">	s = getenv(<span class="string">&quot;machid&quot;</span>);    <span class="comment">/* 比较id 是不是和环境变量是相同的 */</span></span><br><span class="line">	<span class="keyword">if</span> (s) &#123;</span><br><span class="line">		<span class="keyword">if</span> (strict_strtoul(s, <span class="number">16</span>, &amp;machid) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">			debug(<span class="string">&quot;strict_strtoul failed!\n&quot;</span>);</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Using machid 0x%lx from environment\n&quot;</span>, machid);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	debug(<span class="string">&quot;## Transferring control to Linux (at address %08lx)&quot;</span> \</span><br><span class="line">		<span class="string">&quot;...\n&quot;</span>, (ulong) kernel_entry);</span><br><span class="line">	bootstage_mark(BOOTSTAGE_ID_RUN_OS);</span><br><span class="line">	announce_and_cleanup(fake);					<span class="comment">/* CPU clean up,把cache 都刷掉了。 */</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (IMAGE_ENABLE_OF_LIBFDT &amp;&amp; images-&gt;ft_len)<span class="comment">/* 把 r2 寄存器设置为ft_addr 或者 bi_boot_params*/</span></span><br><span class="line">		r2 = (<span class="type">unsigned</span> <span class="type">long</span>)images-&gt;ft_addr;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		r2 = gd-&gt;bd-&gt;bi_boot_params;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!fake) &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_ARMV7_NONSEC</span></span><br><span class="line">		<span class="keyword">if</span> (armv7_boot_nonsec()) &#123;</span><br><span class="line">			armv7_init_nonsec();</span><br><span class="line">			secure_ram_addr(_do_nonsec_entry)(kernel_entry,</span><br><span class="line">							  <span class="number">0</span>, machid, r2);</span><br><span class="line">		&#125; <span class="keyword">else</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">			kernel_entry(<span class="number">0</span>, machid, r2);</span><br><span class="line">	&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>小问题，之前提到的<code>bootargs</code> 是在哪里设定的呢，怎么传递过去的？<ul>
<li>如果不适用fdt的话，参数r2 就是<code>bootargs</code>的值。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="3-一些指令是如何实现的"><a href="#3-一些指令是如何实现的" class="headerlink" title="3. 一些指令是如何实现的?"></a>3. 一些指令是如何实现的?</h2><p>由前面分析我们可以知道，uboot 的命令都是由<code>U_BOOT_CMD</code>实现的，所以我们可以在boot 的文件夹下搜索我们关心的命令，例如上面频繁的用到了<code>fatload</code>命令，我们可以搜索如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">:~/for_study/imax6ull/uboot$: grep  -nr <span class="string">&quot;U_BOOT_CMD&quot;</span> | grep -n <span class="string">&quot;fat&quot;</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">/* 得到下面结果 */</span></span><br><span class="line"><span class="number">1244</span>:cmd/fat.c:<span class="number">27</span>:U_BOOT_CMD(</span><br><span class="line"><span class="number">1245</span>:cmd/fat.c:<span class="number">41</span>:U_BOOT_CMD(</span><br><span class="line"><span class="number">1246</span>:cmd/fat.c:<span class="number">61</span>:U_BOOT_CMD(</span><br><span class="line"><span class="number">1247</span>:cmd/fat.c:<span class="number">93</span>:U_BOOT_CMD(</span><br><span class="line"><span class="number">1248</span>:cmd/fat.c:<span class="number">145</span>:U_BOOT_CMD(</span><br></pre></td></tr></table></figure>

<p>可以发现，是在这些命令都在<code>cmd/fat.c</code>里面，由此可以找到命令的定义和回调函数，具体的实现就需要深入研究源码了。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">U_BOOT_CMD(</span><br><span class="line">	fatload,	<span class="number">7</span>,	<span class="number">0</span>,	do_fat_fsload,</span><br><span class="line">	......</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">    </span><br></pre></td></tr></table></figure>

</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2024-06-06T15:00:09.071Z" title="2024/6/6 23:00:09">2024-06-06</time>发表</span><span class="level-item"><time dateTime="2024-06-06T15:02:49.234Z" title="2024/6/6 23:02:49">2024-06-06</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/uboot-linux/">uboot_linux</a></span><span class="level-item">12 分钟读完 (大约1804个字)</span></div></div><div class="content"><h1 id="从头理清uboot（3）-main-loop-及-CMD实现"><a href="#从头理清uboot（3）-main-loop-及-CMD实现" class="headerlink" title="从头理清uboot（3）-main_loop 及 CMD实现"></a>从头理清uboot（3）-main_loop 及 CMD实现</h1><p>[toc]</p>
<h2 id="1-main—loop-函数"><a href="#1-main—loop-函数" class="headerlink" title="1. main—loop 函数"></a>1. main—loop 函数</h2><p>上篇引导启动的分析最后会调用<code>run_main_loop</code>,在其中会循环调用<code>main_loop()</code>函数。见下方：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">run_main_loop</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">for</span> (;;)</span><br><span class="line">		main_loop();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而在<code>main_loop</code>中，执行的语句如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">main_loop</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">const</span> <span class="type">char</span> *s;</span><br><span class="line">	bootstage_mark_name(BOOTSTAGE_ID_MAIN_LOOP, <span class="string">&quot;main_loop&quot;</span>); <span class="comment">//打印启动进度</span></span><br><span class="line">	cli_init();							<span class="comment">/*初始化 hash shell 相关  */</span></span><br><span class="line">	run_preboot_environment_command();	<span class="comment">/*获取 preboot 环境变量  */</span></span><br><span class="line">	s = bootdelay_process();			<span class="comment">/*读取环境变量 bootdelay和bootcmd 的内容*/</span></span><br><span class="line">	<span class="keyword">if</span> (cli_process_fdt(&amp;s))			<span class="comment">/* 此次uboot 直接返回uboot */</span></span><br><span class="line">		cli_secure_boot_cmd(s);			</span><br><span class="line">	autoboot_command(s);<span class="comment">/* 如果延时到了，没有打断就执行默认的boot-arg */</span></span><br><span class="line">	cli_loop();							<span class="comment">/* 命令执行函数 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>bootdelay_process 函数解析：初始化好了<code>bootdelay</code>的参数，并且返回的命令是<code>bootcmd</code> 环境变量。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">char</span> *<span class="title function_">bootdelay_process</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">char</span> *s;</span><br><span class="line">	<span class="type">int</span> bootdelay;</span><br><span class="line">    s = getenv(<span class="string">&quot;bootdelay&quot;</span>);</span><br><span class="line">	bootdelay = s ? (<span class="type">int</span>)simple_strtol(s, <span class="literal">NULL</span>, <span class="number">10</span>) : CONFIG_BOOTDELAY;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> !defined(CONFIG_FSL_FASTBOOT) &amp;&amp; defined(is_boot_from_usb)</span></span><br><span class="line">	<span class="keyword">if</span> (is_boot_from_usb()) &#123;</span><br><span class="line">		disconnect_from_pc();</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Boot from USB for mfgtools\n&quot;</span>);</span><br><span class="line">		bootdelay = <span class="number">0</span>;</span><br><span class="line">		set_default_env(<span class="string">&quot;Use default environment for \</span></span><br><span class="line"><span class="string">				 mfgtools\n&quot;</span>);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Normal Boot\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    bootretry_init_cmd_timeout();</span><br><span class="line">    s = getenv(<span class="string">&quot;bootcmd&quot;</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> !defined(CONFIG_FSL_FASTBOOT) &amp;&amp; defined(is_boot_from_usb)</span></span><br><span class="line">	<span class="keyword">if</span> (is_boot_from_usb()) &#123;</span><br><span class="line">		s = getenv(<span class="string">&quot;bootcmd_mfg&quot;</span>);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Run bootcmd_mfg: %s\n&quot;</span>, s);</span><br><span class="line">	&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span>    </span></span><br><span class="line">   	process_fdt_options(gd-&gt;fdt_blob);</span><br><span class="line">	stored_bootdelay = bootdelay;</span><br><span class="line">	<span class="keyword">return</span> s;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>其中的<code>get_env</code>函数：可见这个函数根据命令的不同，从<strong>哈希表</strong>和<strong>遍历</strong>两种方式，去现有得环境变量中查找对应命令。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *<span class="title function_">getenv</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name)</span></span><br><span class="line">&#123;</span><br><span class="line">     <span class="comment">/* after import into hashtable */</span></span><br><span class="line">	<span class="keyword">if</span> (gd-&gt;flags &amp; GD_FLG_ENV_READY) &#123;</span><br><span class="line">		ENTRY e, *ep;</span><br><span class="line"></span><br><span class="line">		WATCHDOG_RESET();</span><br><span class="line"></span><br><span class="line">		e.key	= name;</span><br><span class="line">		e.data	= <span class="literal">NULL</span>;</span><br><span class="line">		hsearch_r(e, FIND, &amp;ep, &amp;env_htab, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> ep ? ep-&gt;data : <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/* restricted capabilities before import */</span></span><br><span class="line">	<span class="keyword">if</span> (getenv_f(name, (<span class="type">char</span> *)(gd-&gt;env_buf), <span class="keyword">sizeof</span>(gd-&gt;env_buf)) &gt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> (<span class="type">char</span> *)(gd-&gt;env_buf);</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
<li><p>autoboot_command的函数代码精简如下，可见有三个参数，<code>stored_bootdelay</code>是刚刚初始化好的<code>bootdelay</code>环境变量的值，S 是<code>bootcmd</code>的值，这两个都条件成立。</p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">autoboot_command</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *s)</span></span><br><span class="line">&#123;</span><br><span class="line">   debug(<span class="string">&quot;### main_loop: bootcmd=\&quot;%s\&quot;\n&quot;</span>, s ? s : <span class="string">&quot;&lt;UNDEFINED&gt;&quot;</span>);</span><br><span class="line">     <span class="keyword">if</span> (stored_bootdelay != <span class="number">-1</span> &amp;&amp; s &amp;&amp; !abortboot(stored_bootdelay)) &#123;</span><br><span class="line"> 		run_command_list(s, <span class="number">-1</span>, <span class="number">0</span>); </span><br><span class="line"> 	&#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>进一步分析<code>abortboot(stored_bootdelay)</code>发现里面会每次delay 1000ms 就会把传入的<code>stored_bootdelay</code>参数减一，所以当<code>stored_bootdelay </code>递减到0的时候，会执行<code>run_command_list(s, -1, 0)</code>。</p>
</li>
<li><p>但是其中有个函数是<code>tstc()</code>有效的话，就会导致提前break ,不再执行<code>run_command_list(s, -1, 0)</code>。进入指令处理流程。</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> ((bootdelay &gt; <span class="number">0</span>) &amp;&amp; (!<span class="built_in">abort</span>)) &#123;</span><br><span class="line">	--bootdelay;</span><br><span class="line">	<span class="comment">/* delay 1000 ms */</span></span><br><span class="line">	ts = get_timer(<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">do</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (tstc()) &#123;	<span class="comment">/* we got a key press	*/</span></span><br><span class="line">			<span class="built_in">abort</span>  = <span class="number">1</span>;	<span class="comment">/* don&#x27;t auto boot	*/</span></span><br><span class="line">			bootdelay = <span class="number">0</span>;	<span class="comment">/* no more delay	*/</span></span><br><span class="line">			(<span class="type">void</span>) getc();  <span class="comment">/* consume input	*/</span></span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		udelay(<span class="number">10000</span>);</span><br><span class="line">	&#125; <span class="keyword">while</span> (!<span class="built_in">abort</span> &amp;&amp; get_timer(ts) &lt; <span class="number">1000</span>);</span><br><span class="line">  </span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\b\b\b%2d &quot;</span>, bootdelay);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
<li><p>正常的autoboot流程– run_command_list 函数分析：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">会调用：rcode = parse_string_outer(buff, FLAG_PARSE_SEMICOLON);</span><br><span class="line">	进而调用：rcode = parse_stream_outer(&amp;input, flag);</span><br></pre></td></tr></table></figure>
</li>
<li><p>有按键输入，执行解析命令-cli_loop函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">parse_file_outer();</span><br><span class="line">	-&gt;调用：parse_stream_outer(&amp;input, FLAG_PARSE_SEMICOLON);</span><br></pre></td></tr></table></figure>
</li>
<li><p>所以这种方式都会把接收到的命令交给<code>parse_stream_outer</code>函数执行。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-&gt; 调用: rcode = parse_stream(&amp;temp, &amp;ctx, inp, flag &amp; FLAG_CONT_ON_NEWLINE ? <span class="number">-1</span> : <span class="string">&#x27;\n&#x27;</span>); <span class="comment">/* 解析输入的命令 */</span></span><br><span class="line">-&gt; 调用: code = run_list(ctx.list_head); <span class="comment">/* 执行命令*/</span></span><br><span class="line">	-&gt;run_list_real(pi);</span><br><span class="line">		-&gt;run_pipe_real(pi);</span><br><span class="line">			-&gt;cmd_process(flag, child-&gt;argc, child-&gt;argv,</span><br><span class="line">				   &amp;flag_repeat, <span class="literal">NULL</span>); <span class="comment">/* 实际的处理流程*/</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="2-cmd-process-函数分析"><a href="#2-cmd-process-函数分析" class="headerlink" title="2. cmd_process 函数分析"></a>2. cmd_process 函数分析</h2><p>​		在看函数处理之前，可以先了解uboot  cmd 结构体的组成，其中参数见下图注释</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cmd_tbl_s</span> &#123;</span></span><br><span class="line">	<span class="type">char</span>		*name;		<span class="comment">/* Command Name			*/</span></span><br><span class="line">	<span class="type">int</span>		maxargs;	<span class="comment">/* maximum number of arguments	*/</span></span><br><span class="line">	<span class="type">int</span>		repeatable;	<span class="comment">/* autorepeat allowed?		*/</span></span><br><span class="line">					<span class="comment">/* Implementation function	*/</span></span><br><span class="line">	<span class="type">int</span>		(*cmd)(<span class="keyword">struct</span> cmd_tbl_s *, <span class="type">int</span>, <span class="type">int</span>, <span class="type">char</span> * <span class="type">const</span> []);<span class="comment">/*调用函数*/</span></span><br><span class="line">	<span class="type">char</span>		*usage;		<span class="comment">/*简短提示信息*/</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>​		cmd_process 的处理流程如下所示， 可见主要流程为：查找命令-&gt;判断参数数量-&gt;回调函数调用。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="type">command_ret_t</span> <span class="title function_">cmd_process</span><span class="params">(<span class="type">int</span> flag, <span class="type">int</span> argc, <span class="type">char</span> * <span class="type">const</span> argv[],</span></span><br><span class="line"><span class="params">			       <span class="type">int</span> *repeatable, ulong *ticks)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">enum</span> <span class="title">command_ret_t</span> <span class="title">rc</span> =</span> CMD_RET_SUCCESS;</span><br><span class="line">	<span class="type">cmd_tbl_t</span> *cmdtp;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Look up command in command table */</span></span><br><span class="line">	cmdtp = find_cmd(argv[<span class="number">0</span>]);</span><br><span class="line">	<span class="keyword">if</span> (cmdtp == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Unknown command &#x27;%s&#x27; - try &#x27;help&#x27;\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* found - check max args */</span></span><br><span class="line">	<span class="keyword">if</span> (argc &gt; cmdtp-&gt;maxargs)</span><br><span class="line">		rc = CMD_RET_USAGE;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(CONFIG_CMD_BOOTD)</span></span><br><span class="line">	<span class="comment">/* avoid &quot;bootd&quot; recursion */</span></span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (cmdtp-&gt;cmd == do_bootd) &#123;</span><br><span class="line">		<span class="keyword">if</span> (flag &amp; CMD_FLAG_BOOTD) &#123;</span><br><span class="line">			<span class="built_in">puts</span>(<span class="string">&quot;&#x27;bootd&#x27; recursion detected\n&quot;</span>);</span><br><span class="line">			rc = CMD_RET_FAILURE;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			flag |= CMD_FLAG_BOOTD;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="comment">/* If OK so far, then do the command */</span></span><br><span class="line">	<span class="keyword">if</span> (!rc) &#123;</span><br><span class="line">		<span class="keyword">if</span> (ticks)</span><br><span class="line">			*ticks = get_timer(<span class="number">0</span>);</span><br><span class="line">		rc = cmd_call(cmdtp, flag, argc, argv);<span class="comment">/*利用回调函数执行*/</span></span><br><span class="line">		<span class="keyword">if</span> (ticks)</span><br><span class="line">			*ticks = get_timer(*ticks);</span><br><span class="line">		*repeatable &amp;= cmdtp-&gt;repeatable;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (rc == CMD_RET_USAGE)</span><br><span class="line">		rc = cmd_usage(cmdtp);</span><br><span class="line">	<span class="keyword">return</span> rc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="3-cmd-定义流程"><a href="#3-cmd-定义流程" class="headerlink" title="3. cmd 定义流程"></a>3. cmd 定义流程</h2><ul>
<li>uboot 命令分析，在<code>include/command.h</code>中有定义：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">#define U_BOOT_CMD_MKENT_COMPLETE(_name, _maxargs, _rep, _cmd,		\</span><br><span class="line">				_usage, _help, _comp)			\</span><br><span class="line">		&#123; #_name, _maxargs, _rep, _cmd, _usage,			\</span><br><span class="line">			_CMD_HELP(_help) _CMD_COMPLETE(_comp) &#125;</span><br><span class="line"></span><br><span class="line">#define U_BOOT_CMD_MKENT(_name, _maxargs, _rep, _cmd, _usage, _help)	\</span><br><span class="line">	U_BOOT_CMD_MKENT_COMPLETE(_name, _maxargs, _rep, _cmd,		\</span><br><span class="line">					_usage, _help, NULL)</span><br><span class="line"></span><br><span class="line">#define U_BOOT_CMD_COMPLETE(_name, _maxargs, _rep, _cmd, _usage, _help, _comp) \</span><br><span class="line">	ll_entry_declare(cmd_tbl_t, _name, cmd) =			\</span><br><span class="line">		U_BOOT_CMD_MKENT_COMPLETE(_name, _maxargs, _rep, _cmd,	\</span><br><span class="line">						_usage, _help, _comp);</span><br><span class="line"></span><br><span class="line">#define U_BOOT_CMD(_name, _maxargs, _rep, _cmd, _usage, _help)		\</span><br><span class="line">	U_BOOT_CMD_COMPLETE(_name, _maxargs, _rep, _cmd, _usage, _help, NULL)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>可以看出有以下几点：</p>
<ol>
<li><p><code>U_BOOT_CMD</code>就是<code>U_BOOT_CMD_COMPLETE</code>的宏参数最后一个为<strong>NULL</strong></p>
</li>
<li><p><code>U_BOOT_CMD_COMPLETE</code>会继续调用<code>ll_entry_declare</code>和<code>U_BOOT_CMD_MKENT_COMPLETE</code>函数。分别显示如下</p>
<ul>
<li><pre><code class="asm">#define ll_entry_declare(_type, _name, _list)				\
    _type _u_boot_list_2_##_list##_2_##_name __aligned(4)		\
            __attribute__((unused,				\
            section(&quot;.u_boot_list_2_&quot;#_list&quot;_2_&quot;#_name)))
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">* ```asm</span><br><span class="line">  #define U_BOOT_CMD_MKENT_COMPLETE(_name, _maxargs, _rep, _cmd,\</span><br><span class="line">  				_usage, _help, _comp)			\</span><br><span class="line">  		&#123; #_name, _maxargs, _rep, _cmd, _usage,			\</span><br><span class="line">  			_CMD_HELP(_help) _CMD_COMPLETE(_comp) &#125;</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
</li>
<li><p>其中再次调用了<code>_CMD_HELP(_help) _CMD_COMPLETE(_comp)</code>这两部分定义如下(相关宏已经定义了)：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_AUTO_COMPLETE</span></span><br><span class="line"><span class="comment">//# define _CMD_COMPLETE(x) x,</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="comment">//# define _CMD_COMPLETE(x)</span></span><br><span class="line"><span class="comment">//#endif</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SYS_LONGHELP</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> _CMD_HELP(x) x,</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="comment">//# define _CMD_HELP(x)</span></span><br><span class="line"><span class="comment">//#endif</span></span><br></pre></td></tr></table></figure></li>
</ol>
<ul>
<li><p>利用一个CMD来分析</p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">U_BOOT_CMD(</span><br><span class="line">	spibootldr, <span class="number">2</span>, <span class="number">0</span>, do_spibootldr,</span><br><span class="line">	<span class="string">&quot;boot ldr image from spi&quot;</span>,</span><br><span class="line">	<span class="string">&quot;[offset]\n&quot;</span></span><br><span class="line">	<span class="string">&quot;    - boot ldr image stored at offset into spi\n&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>经过上述的分析，此命令可以被解析为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">--ll_entry_declare(_type, _name, _list)</span><br><span class="line">  -&gt;  <span class="type">cmd_tbl_t</span> _u_boot_list_2_spibootldr_2_spibootldr __aligned(<span class="number">4</span>)		\</span><br><span class="line">			__attribute__((unused,				\</span><br><span class="line">			section(<span class="string">&quot;.u_boot_list_2_do_spibootldr_2_spibootldr)))</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">	--&#123; &quot;</span>spibootldr<span class="string">&quot;, 2, 0, do_spibootldr,&quot;</span> boot ldr image from spi<span class="string">&quot;,			\</span></span><br><span class="line"><span class="string">			&quot;</span>[offset]\n<span class="string">&quot;&quot;</span>- boot ldr image stored at offset into spi\n<span class="string">&quot;, 	NULL, &#125;               </span></span><br></pre></td></tr></table></figure>
<p>  <code>##</code> 连接符:表示后面直接链接</p>
<p>  <code>#</code> 字符串化：表示将传来的参数字符串化。</p>
<p>  所以最后实现的语句如下所示：</p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">cmd_tbl_t</span> _u_boot_list_2_spibootldr_2_spibootldr __aligned(<span class="number">4</span>)	\ __attribute__((unused, section(<span class="string">&quot;.u_boot_list_2_do_spibootldr_2_spibootldr&quot;</span>))) </span><br><span class="line">                           = &#123; <span class="string">&quot;spibootldr&quot;</span>, <span class="number">2</span>, <span class="number">0</span>, do_spibootldr,</span><br><span class="line">                              <span class="string">&quot; boot ldr image from spi&quot;</span>,</span><br><span class="line">                              <span class="string">&quot;[offset]\n&quot;</span><span class="string">&quot;- boot ldr image stored at offset into spi\n&quot;</span>,</span><br><span class="line">                              <span class="literal">NULL</span>, &#125; </span><br></pre></td></tr></table></figure></li>
</ul>
<p>​		4字节对齐定义了一个<code>cmd_tbl_t</code>的结构体变量<code>_u_boot_list_2_spibootldr_2_spibootldr</code>，且被划分到了<code>u_boot_list_2_do_spibootldr_2_spibootldr</code> section。</p>
<ul>
<li><p>其中对于<code>cmd_tbl_t</code> 有以下定义: </p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cmd_tbl_s</span> &#123;</span></span><br><span class="line">    <span class="type">char</span>		*name;		<span class="comment">/* Command Name	  		*/</span>          </span><br><span class="line">    <span class="type">int</span>		maxargs;	<span class="comment">/* maximum number of arguments	*/</span></span><br><span class="line">    <span class="type">int</span>		repeatable;	<span class="comment">/* autorepeat allowed?		*/</span></span><br><span class="line">                    <span class="comment">/* Implementation function	*/</span></span><br><span class="line">    <span class="type">int</span>		(*cmd)(<span class="keyword">struct</span> cmd_tbl_s *, <span class="type">int</span>, <span class="type">int</span>, <span class="type">char</span> * <span class="type">const</span> []);  <span class="comment">/* 函数指针 */</span></span><br><span class="line">    <span class="type">char</span>		*usage;		<span class="comment">/* Usage message	(short)	*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span>	CONFIG_SYS_LONGHELP</span></span><br><span class="line">    <span class="type">char</span>		*help;		<span class="comment">/* Help  message	(long)	*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_AUTO_COMPLETE</span></span><br><span class="line">    <span class="comment">/* do auto completion on the arguments */</span></span><br><span class="line">    <span class="type">int</span>		(*complete)(<span class="type">int</span> argc, <span class="type">char</span> * <span class="type">const</span> argv[], <span class="type">char</span> last_char, <span class="type">int</span> maxv, <span class="type">char</span> *cmdv[]);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>section 在内存中的存储位置如下所示：四字节对齐之后存储在rodata 段之后。</p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">.rodata : &#123; *(SORT_BY_ALIGNMENT(SORT_BY_NAME(.rodata*))) &#125;</span><br><span class="line">. = ALIGN(<span class="number">4</span>);</span><br><span class="line">.data : &#123;</span><br><span class="line"> *(.data*)</span><br><span class="line">&#125;</span><br><span class="line">. = ALIGN(<span class="number">4</span>);</span><br><span class="line">. = .;</span><br><span class="line">. = ALIGN(<span class="number">4</span>);</span><br><span class="line">.u_boot_list : &#123;</span><br><span class="line"> KEEP(*(SORT(.u_boot_list*)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>注意：</strong>这里有一次<code>SORT</code>排序，结合下面的代码，就会发现能够获取板子的整个命令段。函数内部静态定义也会存在全局变量中。</p>
<ul>
<li><pre><code class="asm">#define ll_entry_start(_type, _list)\
(&#123;\
    static char start[0] __aligned(4) __attribute__((unused,	\
        section(&quot;.u_boot_list_2_&quot;#_list&quot;_1&quot;)));			\
    (_type *)&amp;start;						\
&#125;)
#define ll_entry_end(_type, _list)\
(&#123;									\
    static char end[0] __aligned(4) __attribute__((unused,		\
        section(&quot;.u_boot_list_2_&quot;#_list&quot;_3&quot;)));			\
    (_type *)&amp;end;							\
&#125;)
</code></pre>
</li>
</ul>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2024-06-06T15:00:09.070Z" title="2024/6/6 23:00:09">2024-06-06</time>发表</span><span class="level-item"><time dateTime="2024-06-06T15:02:39.857Z" title="2024/6/6 23:02:39">2024-06-06</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/uboot-linux/">uboot_linux</a></span><span class="level-item">41 分钟读完 (大约6175个字)</span></div></div><div class="content"><h1 id="从头理清uboot（2）-启动流程分析"><a href="#从头理清uboot（2）-启动流程分析" class="headerlink" title="从头理清uboot（2）-启动流程分析"></a>从头理清uboot（2）-启动流程分析</h1><p>[toc]</p>
<h2 id="1-总体流程图"><a href="#1-总体流程图" class="headerlink" title="1.总体流程图"></a>1.总体流程图</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">graph TB</span><br><span class="line">上电--&gt;a[entry: start] --&gt;设置中断向量表,跳转到reset--&gt;设置处理器工作模式--&gt;设置CP的值/初始化中断向量表--&gt;关闭mmu,初始化堆栈值--&gt;初始化gd结构体:完成内存布局初步分配--&gt;c[利用函数指针初始化函数]</span><br><span class="line">c--&gt;代码重定位--&gt;dyn段的table值重定位+向量表重定位--&gt;再次执行函数指针数组--&gt;进入main_loop函数</span><br></pre></td></tr></table></figure>

<h2 id="2-逐步分析"><a href="#2-逐步分析" class="headerlink" title="2. 逐步分析"></a>2. 逐步分析</h2><h3 id="2-1-上电后执行的第一条指令"><a href="#2-1-上电后执行的第一条指令" class="headerlink" title="2.1 上电后执行的第一条指令"></a>2.1 上电后执行的第一条指令</h3><p>由于在编译的时候有下面的链接命令：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arm-linux-gnueabihf-ld.bfd   -pie  --gc-sections -Bstatic -Ttext 0x87800000 -o u-boot -T u-boot.lds arch/arm/cpu/armv7/start.o --start-group  arch/arm/cpu/built-in.o ...... test/dm/built-in.o --end-group arch/arm/lib/eabi_compat.o  -L /usr/lib/gcc-cross/arm-linux-gnueabihf/9 -lgcc -Map u-boot.map</span><br></pre></td></tr></table></figure>

<p>所以其实是利用<code>u-boot.lds</code>来链接整个bin 文件的。那么就可以在lds 中看到uboot 的程序入口：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">ENTRY(_start)</span><br><span class="line">SECTIONS</span><br><span class="line">&#123;</span><br><span class="line"> . = 0x00000000;</span><br><span class="line"> . = ALIGN(4);</span><br><span class="line"> .text :</span><br><span class="line"> &#123;</span><br><span class="line">  *(.__image_copy_start)</span><br><span class="line">  *(.vectors)</span><br><span class="line">  arch/arm/cpu/armv7/start.o (.text*)</span><br><span class="line">  *(.text*)</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>在<code>arch/arm/lib/vector.s</code>中能够找到<code>_start</code>的具体实现：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">_start:</span><br><span class="line">#ifdef CONFIG_SYS_DV_NOR_BOOT_CFG</span><br><span class="line">	.word	CONFIG_SYS_DV_NOR_BOOT_CFG</span><br><span class="line">#endif</span><br><span class="line">	b	reset</span><br><span class="line">	ldr	pc, _undefined_instruction</span><br><span class="line">	ldr	pc, _software_interrupt</span><br><span class="line">	ldr	pc, _prefetch_abort</span><br><span class="line">	ldr	pc, _data_abort</span><br><span class="line">	ldr	pc, _not_used</span><br><span class="line">	ldr	pc, _irq</span><br><span class="line">	ldr	pc, _fiq</span><br></pre></td></tr></table></figure>

<p>​		由此我们找到了程序上电执行的第一条指令。</p>
<h3 id="2-2-初始化中断向量表"><a href="#2-2-初始化中断向量表" class="headerlink" title="2.2 初始化中断向量表"></a>2.2 初始化中断向量表</h3><p>​		由上可知，_start的汇编代码的作用便是初始化了中断向量表，并且跳转像了<code>reset</code>函数。至于为什么这里实现了跳转了中断向量表，可先参考这个blog 学习：</p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/liangliangge/p/12549087.html">https://www.cnblogs.com/liangliangge/p/12549087.html</a>  </p>
<p>&#x3D;&#x3D;TODO：补充armv7 中断处理功能&#x3D;&#x3D;</p>
<h3 id="2-3-初始化工作模式-初始化中断向量表。"><a href="#2-3-初始化工作模式-初始化中断向量表。" class="headerlink" title="2.3 初始化工作模式 &amp; 初始化中断向量表。"></a>2.3 初始化工作模式 &amp; 初始化中断向量表。</h3><p>​		在<code>_start</code>函数中，会跳到<code>reset</code>函数（在<code>arch/arm/cpu/armv7/start.s</code>）中，其函数如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">	.globl	reset</span><br><span class="line">	.globl	save_boot_params_ret</span><br><span class="line"></span><br><span class="line">reset:</span><br><span class="line">	......<span class="comment">//中间代码边分析边给出</span></span><br><span class="line">	bl	_main</span><br></pre></td></tr></table></figure>

<p>​		进入reset 之后，首先执行的就是<code>b  save_boot_params</code>但是又会跳回<code>save_boot_params_ret:</code>，在reset 中再次执行，由于定义是week 的，最后实际实现还可以再覆盖。见下方代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ENTRY(save_boot_params)</span><br><span class="line">	b	save_boot_params_ret</span><br><span class="line"><span class="title function_">ENDPROC</span><span class="params">(save_boot_params)</span></span><br><span class="line">	.weak	save_boot_params</span><br></pre></td></tr></table></figure>

<p>​		之后便会初始化处理器的工作模式及关闭中断，见下方代码，注释已经写入其中。</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/zhoutaopower/article/details/113746587">https://blog.csdn.net/zhoutaopower/article/details/113746587</a></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mrs	r0, cpsr			<span class="comment">//读cpsr 的值到r0</span></span><br><span class="line">and	r1, r0, #<span class="number">0x1f</span>		<span class="comment">//取 低五位到r1</span></span><br><span class="line">teq	r1, #<span class="number">0x1a</span>			<span class="comment">//判断是，即判断是不是HYP模式</span></span><br><span class="line">bicne	r0, r0, #<span class="number">0x1f</span>	<span class="comment">//不是，就清除低五位</span></span><br><span class="line">orrne	r0, r0, #<span class="number">0x13</span>	<span class="comment">//不是，设置为SVC 模式</span></span><br><span class="line">orr	r0, r0, #<span class="number">0xc0</span>		<span class="comment">//关闭FIQ 和IRQ</span></span><br><span class="line">msr	cpsr,r0				<span class="comment">//把新的r0 值写入CPSR</span></span><br></pre></td></tr></table></figure>

<p>​		其次就会设置SCTLR 的值，这里会涉及到armv7 的CP 寄存器，可以见这篇文章：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/lifexy/p/7203786.html">协处理器CP15介绍—MCR&#x2F;MRC指令(6) - 诺谦 - 博客园 (cnblogs.com)</a>，uboot 汇编相关见下方注释：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> !(defined(CONFIG_OMAP44XX) &amp;&amp; defined(CONFIG_SPL_BUILD))</span></span><br><span class="line">	<span class="comment">/* Set V=0 in CP15 SCTLR register - for VBAR to point to vector */</span></span><br><span class="line">	mrc	p15, <span class="number">0</span>, r0, c1, c0, <span class="number">0</span>	<span class="comment">//把cp15寄存器中c1控制位 读到r0中</span></span><br><span class="line">	bic	r0, #CR_V				<span class="comment">//清除r0 中的 CR_V 控制位，表示向量表地址为0x00000000,且可以重定位向量表。</span></span><br><span class="line">	mcr	p15, <span class="number">0</span>, r0, c1, c0, <span class="number">0</span>	<span class="comment">//把r0写回 cp15-c1</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Set vector address in CP15 VBAR register */</span></span><br><span class="line">	ldr	r0, =_start</span><br><span class="line">	mcr	p15, <span class="number">0</span>, r0, c12, c0, <span class="number">0</span>	 <span class="comment">//把_start设置为向量表地址，写入 cp15-c12</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<h3 id="2-4-cpu-init-cp15-cpu-init-crit"><a href="#2-4-cpu-init-cp15-cpu-init-crit" class="headerlink" title="2.4 cpu_init_cp15 &amp; cpu_init_crit"></a>2.4 cpu_init_cp15 &amp; cpu_init_crit</h3><p>​		在设置好中断向量表之后，在<code>reset </code>中会做两个<strong>CPU 核</strong>相关的init动作，之后便会跳转到<code>_main</code>执行，见下方代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> CONFIG_SKIP_LOWLEVEL_INIT</span></span><br><span class="line">	bl	cpu_init_cp15</span><br><span class="line">	bl	cpu_init_crit</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	bl	_main</span><br></pre></td></tr></table></figure>

<p>我们依次分析这两个函数都做了什么事情：</p>
<h4 id="2-4-1-cpu-init-cp15"><a href="#2-4-1-cpu-init-cp15" class="headerlink" title="2.4.1 cpu_init_cp15"></a>2.4.1 cpu_init_cp15</h4><p>​		通过下方代码，可以看出，功能为：关闭指令cache、清空写和预取缓存区，关闭mmu、使能地址跳转预测、获取CPU信息并且根据CPU info  信息的不同来做处理。下方直接将注释写入下方代码段中：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line">/*************************************************************************</span><br><span class="line"> *</span><br><span class="line"> * cpu_init_cp15</span><br><span class="line"> *</span><br><span class="line"> * Setup CP15 registers (cache, MMU, TLBs). The I-cache is turned on unless</span><br><span class="line"> * CONFIG_SYS_ICACHE_OFF is defined.</span><br><span class="line"> *</span><br><span class="line"> *************************************************************************/</span><br><span class="line">ENTRY(cpu_init_cp15)</span><br><span class="line">	/*</span><br><span class="line">	 * Invalidate L1 I/D</span><br><span class="line">	 */</span><br><span class="line">	mov	r0, #0			@ set up for MCR</span><br><span class="line">	mcr	p15, 0, r0, c8, c7, 0	@ 无效整个数据和指令TLB</span><br><span class="line">	mcr	p15, 0, r0, c7, c5, 0	@无效整个指令cache</span><br><span class="line">	mcr	p15, 0, r0, c7, c5, 6	@ 无效整个跳转目标cache</span><br><span class="line">	mcr p15, 0, r0, c7, c10, 4	@ 清空写缓存区</span><br><span class="line">	mcr p15, 0, r0, c7, c5, 4	@ 清空预取缓存区</span><br><span class="line"></span><br><span class="line">	/*</span><br><span class="line">	 * disable MMU stuff and caches</span><br><span class="line">	 */</span><br><span class="line">	mrc	p15, 0, r0, c1, c0, 0	@把cp15-c1 的值读到r0中</span><br><span class="line">	bic	r0, r0, #0x00002000	@ 设置低端一场中断向量表，且在可重定位状态</span><br><span class="line">	bic	r0, r0, #0x00000007	@ 关闭mmu、地址对齐、禁止cache</span><br><span class="line">	orr	r0, r0, #0x00000002	@ 使能地址对齐检查</span><br><span class="line">	orr	r0, r0, #0x00000800	@ 使能跳转预测</span><br><span class="line">#ifdef CONFIG_SYS_ICACHE_OFF</span><br><span class="line">	bic	r0, r0, #0x00001000	@ 关闭 I-cahe</span><br><span class="line">#else</span><br><span class="line">	orr	r0, r0, #0x00001000	@ 使能 I-cahe</span><br><span class="line">#endif</span><br><span class="line">	mcr	p15, 0, r0, c1, c0, 0</span><br><span class="line"></span><br><span class="line">#ifdef CONFIG_ARM_ERRATA_716044  --使能跳转预测</span><br><span class="line">	mrc	p15, 0, r0, c1, c0, 0	@ read system control register</span><br><span class="line">	orr	r0, r0, #1 &lt;&lt; 11	@ set bit #11</span><br><span class="line">	mcr	p15, 0, r0, c1, c0, 0	@ write system control register</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">  --C15 寄存器会随着设计的不同而不同。</span><br><span class="line">#if (defined(CONFIG_ARM_ERRATA_742230) || defined(CONFIG_ARM_ERRATA_794072))</span><br><span class="line">	mrc	p15, 0, r0, c15, c0, 1	@ read diagnostic register</span><br><span class="line">	orr	r0, r0, #1 &lt;&lt; 4		@ set bit #4</span><br><span class="line">	mcr	p15, 0, r0, c15, c0, 1	@ write diagnostic register</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line"> 		.</span><br><span class="line"> 		. @中间为相似判断，省略</span><br><span class="line"> 		.</span><br><span class="line"> 		.</span><br><span class="line"> 		.</span><br><span class="line"> 		.</span><br><span class="line"></span><br><span class="line">	mov	r5, lr			@ Store my Caller 保存下lr指针，保存函数返回地址</span><br><span class="line">	mrc	p15, 0, r1, c0, c0, 0	@ 把cp15-c0-主标识符 读到r1</span><br><span class="line">	mov	r3, r1, lsr #20		@ 将r1 右移20bit ,存储到r3</span><br><span class="line">	and	r3, r3, #0xf		@获取r1[23:20]</span><br><span class="line">	and	r4, r1, #0xf		@ 获取r1[4:0]</span><br><span class="line">	mov	r2, r3, lsl #4		@ shift variant field for combined value</span><br><span class="line">	orr	r2, r4, r2		@ r2= r1[23:20] + r1[4:0] = c0[23:20] + c0[4:0] CPU variant + revision</span><br><span class="line"></span><br><span class="line"> 		.</span><br><span class="line"> 		. @中间为相似判断，省略</span><br><span class="line"> 		.</span><br><span class="line"> 		.</span><br><span class="line"> 		.</span><br><span class="line"> 		.</span><br><span class="line"></span><br><span class="line">#ifdef CONFIG_ARM_ERRATA_621766</span><br><span class="line">	cmp	r2, #0x21		@ Only on &lt; r2p1</span><br><span class="line">	bge	skip_errata_621766</span><br><span class="line"></span><br><span class="line">	mrc	p15, 0, r0, c1, c0, 1	@ Read ACR</span><br><span class="line">	orr	r0, r0, #(0x1 &lt;&lt; 5)	@ Set L1NEON bit</span><br><span class="line">	push	&#123;r1-r5&#125;			@ Save the cpu info registers</span><br><span class="line">	bl	v7_arch_cp15_set_acr</span><br><span class="line">	pop	&#123;r1-r5&#125;			@ Restore the cpu info - fall through</span><br><span class="line"></span><br><span class="line">skip_errata_621766:</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">	mov	pc, r5			@ 退出函数执行，跳回。</span><br><span class="line">ENDPROC(cpu_init_cp15)</span><br></pre></td></tr></table></figure>



<h4 id="2-4-1-cpu-init-crit"><a href="#2-4-1-cpu-init-crit" class="headerlink" title="2.4.1 cpu_init_crit"></a>2.4.1 cpu_init_crit</h4><p>​		跳入 <code>lowlevel_init</code>函数，在<code>arch/arm/cpu/armv7/lowlevel_init.s</code>中有定义，可见初步作用是初始化栈，调用<code>s_init</code>函数，定义在<code>arch/arm/cpu/armv7/mx6/soc.c</code>，但是对于<code>imax6ull</code>而言就是个空函数，故整体而言，这里只是做了一个获取<code>CONFIG_SYS_INIT_SP_ADDR</code>的值，做了下sp 的初始化，给<code>GD_SIZE</code>留出空间。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">ENTRY(lowlevel_init)</span><br><span class="line"></span><br><span class="line">	ldr	sp, =CONFIG_SYS_INIT_SP_ADDR</span><br><span class="line">	bic	sp, sp, #7 /*8byte对齐*/</span><br><span class="line">#ifdef CONFIG_SPL_DM</span><br><span class="line">	mov	r9, #0</span><br><span class="line">#else</span><br><span class="line">#ifdef CONFIG_SPL_BUILD  </span><br><span class="line">	ldr	r9, =gdata</span><br><span class="line">#else</span><br><span class="line">	sub	sp, sp, #GD_SIZE  @减去 GD_SIZE 的值。</span><br><span class="line">	bic	sp, sp, #7 /*8byte对齐*/</span><br><span class="line">	mov	r9, sp</span><br><span class="line">#endif</span><br><span class="line">#endif</span><br><span class="line">	push	&#123;ip, lr&#125; @将IP  和 lr  都压入栈中</span><br><span class="line">	bl	s_init</span><br><span class="line">	pop	&#123;ip, pc&#125; @将IP  和 lr  都出栈</span><br><span class="line">ENDPROC(lowlevel_init)</span><br></pre></td></tr></table></figure>

<p>​		对于<code>CONFIG_SYS_INIT_SP_ADDR</code>和&#96;&#96;在<code>include/configs/mx6sllevk.h</code>中有定义：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> CONFIG_SYS_INIT_RAM_ADDR	IRAM_BASE_ADDR</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CONFIG_SYS_INIT_RAM_SIZE	IRAM_SIZE</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CONFIG_SYS_INIT_SP_OFFSET \</span></span><br><span class="line"><span class="meta">	(CONFIG_SYS_INIT_RAM_SIZE - GENERATED_GBL_DATA_SIZE)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CONFIG_SYS_INIT_SP_ADDR \</span></span><br><span class="line"><span class="meta">	(CONFIG_SYS_INIT_RAM_ADDR + CONFIG_SYS_INIT_SP_OFFSET)</span></span><br></pre></td></tr></table></figure>

<p>​		其中<code>IRAM_BASE_ADDR</code>和 <code>IRAM_SIZE</code>在&#96;&#96;arch&#x2F;arm&#x2F;include&#x2F;asm&#x2F;arch-mx6&#x2F;imx-regs.h&#96;中有定义,可以看出，这应该是CPU内部的<strong>ram</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> IRAM_BASE_ADDR			0x00900000</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> !(defined(CONFIG_MX6SX) || defined(CONFIG_MX6UL) || \</span></span><br><span class="line"><span class="meta">	defined(CONFIG_MX6SLL) || defined(CONFIG_MX6SL))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IRAM_SIZE                    0x00040000</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IRAM_SIZE                    0x00020000</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>​		我们还需要知道<code>GENERATED_GBL_DATA_SIZE</code>和<code>GD_SIZE</code>的值，都定义在<code>include/generated/generic-asm-offsets.h</code>中，有以下定义：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> GENERATED_GBL_DATA_SIZE 256 <span class="comment">/* (sizeof(struct global_data) + 15) &amp; ~15	@ */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GENERATED_BD_INFO_SIZE 80 <span class="comment">/* (sizeof(struct bd_info) + 15) &amp; ~15	@ */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GD_SIZE 248 <span class="comment">/* sizeof(struct global_data)	@ */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GD_BD 0 <span class="comment">/* offsetof(struct global_data, bd)	@ */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GD_MALLOC_BASE 188 <span class="comment">/* offsetof(struct global_data, malloc_base)	@ */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GD_RELOCADDR 44 <span class="comment">/* offsetof(struct global_data, relocaddr)	@ */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GD_RELOC_OFF 64 <span class="comment">/* offsetof(struct global_data, reloc_off)	@ */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GD_START_ADDR_SP 60 <span class="comment">/* offsetof(struct global_data, start_addr_sp)	@ */</span></span></span><br></pre></td></tr></table></figure>

<p>​		由此我们可以得到当前的栈指针的值：</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">*</span> sp = CONFIG<span class="emphasis">_SYS_</span>INIT<span class="emphasis">_SP_</span>ADDR =  (CONFIG<span class="emphasis">_SYS_</span>INIT<span class="emphasis">_RAM_</span>ADDR + CONFIG<span class="emphasis">_SYS_</span>INIT<span class="emphasis">_RAM_</span>SIZE - GENERATED<span class="emphasis">_GBL_</span>DATA<span class="emphasis">_SIZE) = 0x00900000 + 0x00020000 -256 = 0x0091FF00</span></span><br><span class="line"><span class="emphasis">* sp = sp - GD_</span>SIZE = 0x0091FF00 - 248 = 0x0091FE08 </span><br><span class="line"><span class="bullet">*</span> bic	sp, sp, #7 --&gt; sp = 0x0091FE00</span><br></pre></td></tr></table></figure>

<h3 id="2-5-进入-main-函数"><a href="#2-5-进入-main-函数" class="headerlink" title="2.5 进入_main 函数"></a>2.5 进入_main 函数</h3><p>​		&#x3D;&#x3D;补充重点：&#x3D;&#x3D;<strong>建议看crt0.S 中关于_main 函数的作用，里面解释了为什么会有这些流程</strong></p>
<p>​		在上面步骤，应该是初步完成了CPU的一些配置，解下来会进入_main函数，进一步完成系统级的初始化工作。   <code>__main</code>函数定义在<code> arch/arm/lib/crt0.S</code>中。【crt0.S 作用是 准备计入C语言需要的环境。】</p>
<p>​	首先判断是否定义了SPL build 相关，初始化栈sp 指针。然后会分别调用<code>board_init_f_alloc_reserve</code>、<code>board_init_f_init_reserve</code>、<code>board_init_f</code>(r0 &#x3D;&#x3D;0),可见下方代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">ENTRY(_main)</span><br><span class="line">/*</span><br><span class="line"> * Set up initial C runtime environment and call board_init_f(0).</span><br><span class="line"> */</span><br><span class="line">#if defined(CONFIG_SPL_BUILD) &amp;&amp; defined(CONFIG_SPL_STACK)</span><br><span class="line">	ldr	sp, =(CONFIG_SPL_STACK)</span><br><span class="line">#else</span><br><span class="line">	ldr	sp, =(CONFIG_SYS_INIT_SP_ADDR)</span><br><span class="line">#endif</span><br><span class="line">#if defined(CONFIG_CPU_V7M)	/* v7M forbids using SP as BIC destination */</span><br><span class="line">	mov	r3, sp</span><br><span class="line">	bic	r3, r3, #7</span><br><span class="line">	mov	sp, r3</span><br><span class="line">#else</span><br><span class="line">	bic	sp, sp, #7	/* 8-byte alignment for ABI compliance */</span><br><span class="line">#endif</span><br><span class="line">	mov	r0, sp</span><br><span class="line">	bl	board_init_f_alloc_reserve</span><br><span class="line">	mov	sp, r0  </span><br><span class="line">	/* set up gd here, outside any C code */</span><br><span class="line">	mov	r9, r0</span><br><span class="line">	bl	board_init_f_init_reserve</span><br><span class="line"></span><br><span class="line">	mov	r0, #0</span><br><span class="line">	bl	board_init_f</span><br><span class="line"></span><br><span class="line">#if ! defined(CONFIG_SPL_BUILD)</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> * Set up intermediate environment (new sp and gd) and call</span><br><span class="line"> * relocate_code(addr_moni). Trick here is that we&#x27;ll return</span><br><span class="line"> * &#x27;here&#x27; but relocated.</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">	ldr	sp, [r9, #GD_START_ADDR_SP]	/* sp = gd-&gt;start_addr_sp */</span><br><span class="line">	.......</span><br></pre></td></tr></table></figure>

<h4 id="2-5-1-board-init-f-alloc-reserve（sp）"><a href="#2-5-1-board-init-f-alloc-reserve（sp）" class="headerlink" title="2.5.1 board_init_f_alloc_reserve（sp）"></a>2.5.1 board_init_f_alloc_reserve（sp）</h4><p>​	其中调用的<code>board_init_f_alloc_reserve（sp）</code>在<code>common/init/board_init.c</code>中，这个函数有一个传参，实际为sp 的值，可见这个函数的作用为在栈中留出<code>CONFIG_SYS_MALLOC_F_LEN = 0x400</code>大小和<code>global_data</code>结构体的大小(GD_SIZE)空间区域后，进行一个16byte 的对齐操作。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ulong <span class="title function_">board_init_f_alloc_reserve</span><span class="params">(ulong top)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/* Reserve early malloc arena */</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(CONFIG_SYS_MALLOC_F)</span></span><br><span class="line">	top -= CONFIG_SYS_MALLOC_F_LEN;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="comment">/* LAST : reserve GD (rounded up to a multiple of 16 bytes) */</span></span><br><span class="line">	top = rounddown(top-<span class="keyword">sizeof</span>(<span class="keyword">struct</span> global_data), <span class="number">16</span>);</span><br><span class="line">	<span class="keyword">return</span> top;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​		所以当前的sp 为：<code>0x0091FF00 - 0x400 - 248 = 0x0091Fa00 </code>。出栈后会把<strong>算好的r0 在赋值给sp</strong>，同时赋值g给r9。</p>
<h4 id="2-5-2-board-init-f-init-reserve（sp）"><a href="#2-5-2-board-init-f-init-reserve（sp）" class="headerlink" title="2.5.2 board_init_f_init_reserve（sp）"></a>2.5.2 board_init_f_init_reserve（sp）</h4><p>​	之后会调用<code>board_init_f_init_reserve</code>，对于imax6ull 条件编译之后见下方，可见主要作用为：</p>
<p>​		将当前sp 设置为<code>global_data</code>的基地址、<code>global_data</code>区域清0、然后把<code>gd-&gt;malloc_base</code>设置为base 加上<code>struct global_data</code>并且16字节取整，之后base 加上<code>CONFIG_SYS_MALLOC_F_LEN</code>长度。那么这个函数就是把<code>global_data</code>初始化了，把malloc地址指向了<code> 0x0091FF00 - 0x400</code>，然后把base设置为了<code>0x0091FF00 </code>再赋值给r0了。</p>
<p>​		作用：这里留出一块内存用于保存global_data和 执行后面的函数的内存空间</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">board_init_f_init_reserve</span><span class="params">(ulong base)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">global_data</span> *<span class="title">gd_ptr</span>;</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * clear GD entirely and set it up.</span></span><br><span class="line"><span class="comment">	 * Use gd_ptr, as gd may not be properly set yet.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	gd_ptr = (<span class="keyword">struct</span> global_data *)base;</span><br><span class="line">	<span class="comment">/* zero the area */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _USE_MEMCPY</span></span><br><span class="line">	<span class="built_in">memset</span>(gd_ptr, <span class="string">&#x27;\0&#x27;</span>, <span class="keyword">sizeof</span>(*gd));</span><br><span class="line">	<span class="comment">/* next alloc will be higher by one GD plus 16-byte alignment */</span></span><br><span class="line">	base += roundup(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> global_data), <span class="number">16</span>);</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * record early malloc arena start.</span></span><br><span class="line"><span class="comment">	 * Use gd as it is now properly set for all architectures.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(CONFIG_SYS_MALLOC_F)</span></span><br><span class="line">	<span class="comment">/* go down one &#x27;early malloc arena&#x27; */</span></span><br><span class="line">	gd-&gt;malloc_base = base;</span><br><span class="line">	<span class="comment">/* next alloc will be higher by one &#x27;early malloc arena&#x27; size */</span></span><br><span class="line">	base += CONFIG_SYS_MALLOC_F_LEN;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-5-3-board-init-f-0"><a href="#2-5-3-board-init-f-0" class="headerlink" title="2.5.3 board_init_f(0)"></a>2.5.3 board_init_f(0)</h4><p>​	<code>board_init_f</code>函数定义在<code> common/board_f.c</code>中，经过条件编译之后的结果为下图所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">board_init_f</span><span class="params">(ulong boot_flags)</span></span><br><span class="line">&#123;</span><br><span class="line">	gd-&gt;flags = boot_flags;</span><br><span class="line">	gd-&gt;have_console = <span class="number">0</span>;  </span><br><span class="line">	<span class="keyword">if</span> (initcall_run_list(init_sequence_f))</span><br><span class="line">		hang();</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> !defined(CONFIG_ARM) &amp;&amp; !defined(CONFIG_SANDBOX) &amp;&amp; \</span></span><br><span class="line"><span class="meta">		!defined(CONFIG_EFI_APP)</span></span><br><span class="line">	<span class="comment">/* NOTREACHED - jump_to_copy() does not return */</span></span><br><span class="line">	hang();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="comment">/* Light up LED1 */</span></span><br><span class="line">	imx6_light_up_led1();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​		<code>gd-&gt;have_console = 0;</code>表明现在还没有窗口。</p>
<p>​		其中<code>boot_flags == 0</code>作为输入传入，后续主要是执行<code>initcall_run_list(init_sequence_f)</code>这个函数，我们需要先看函数输入<code>init_sequence_f</code>的定义(已经经过条件编译，见下方)。</p>
<p>​		其中<code>init_fnc_t</code>的定义为<code>typedef int (*init_fnc_t)(void);</code>，由此这是一个函数指针结构体，而在<code>board_init_f</code>中调用的<code>initcall_run_list</code>函数就是会遍历执行下方的<code>init_sequence_f</code>函数结构体，来执行板级的初始化。对于被遍历的函数，大致功能见注释。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">init_fnc_t</span> init_sequence_f[] = &#123;</span><br><span class="line">    setup_mon_len, <span class="comment">//gd-&gt;mon_len = (ulong)&amp;__bss_end - (ulong)_start; 设置mon_len 为代码长度</span></span><br><span class="line">    initf_malloc,	<span class="comment">//gd-&gt;malloc_limit = 0x40; 当前内存池大小。</span></span><br><span class="line">	initf_console_record,	<span class="comment">//return 0;</span></span><br><span class="line">    arch_cpu_init,		<span class="comment">/* basic arch cpu dependent setup */</span></span><br><span class="line">	initf_dm,			<span class="comment">//初始化驱动模型相关</span></span><br><span class="line">	arch_cpu_init_dm,</span><br><span class="line">	mark_bootstage,		<span class="comment">/* need timer, go after init dm */</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(CONFIG_BOARD_EARLY_INIT_F)</span></span><br><span class="line">	board_early_init_f,		<span class="comment">//，I.MX6ULL 用来初始化串口的 IO 配置</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(CONFIG_ARM) || defined(CONFIG_MIPS) || \</span></span><br><span class="line"><span class="meta">		defined(CONFIG_BLACKFIN) || defined(CONFIG_NDS32) || \</span></span><br><span class="line"><span class="meta">		defined(CONFIG_SPARC)</span></span><br><span class="line">	timer_init,		<span class="comment">//初始化内部定时器</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span>    </span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(CONFIG_BOARD_POSTCLK_INIT)</span></span><br><span class="line">	board_postclk_init,		<span class="comment">//设置 VDDSOC 电压</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(CONFIG_SYS_FSL_CLK) || defined(CONFIG_M68K)</span></span><br><span class="line">	get_clocks,			<span class="comment">//可以配置获取多种时钟值，I.MX6ULL 获取的是 sdhc_clk 时钟</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	env_init,		<span class="comment">//gd-&gt;env_addr	= (ulong)&amp;default_environment[0]; 设置gd ENV 地址</span></span><br><span class="line">    init_baud_rate,		<span class="comment">/* 根据 “baudrate” 环境变量配置波特率 */</span></span><br><span class="line">	serial_init,		<span class="comment">/* 串口初始化 会调用函数指针 */</span></span><br><span class="line">	console_init_f,		<span class="comment">/* gd-&gt;have_console = 1; 配置输出窗口*/</span></span><br><span class="line">    display_options,	<span class="comment">/* 在窗口上显示输出 */</span></span><br><span class="line">	display_text_info,	<span class="comment">/* 在窗口上打印文本输出*/</span></span><br><span class="line">	print_cpuinfo,		<span class="comment">/* 打印CPU 信息 */</span>      </span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(CONFIG_DISPLAY_BOARDINFO)</span></span><br><span class="line">	show_board_info,	<span class="comment">/* 打印板子 信息 */</span>    </span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	INIT_FUNC_WATCHDOG_INIT     <span class="comment">/*初始化看门狗， I.MX6ULL 来说是空函数  */</span></span><br><span class="line">	INIT_FUNC_WATCHDOG_RESET 	<span class="comment">/*喂狗， I.MX6ULL 来说是空函数  */</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(CONFIG_HARD_I2C) || defined(CONFIG_SYS_I2C)</span></span><br><span class="line">	init_func_i2c,				<span class="comment">/* 初始化IIC */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span>        </span></span><br><span class="line">	announce_dram_init,</span><br><span class="line">	<span class="comment">/* <span class="doctag">TODO:</span> unify all these dram functions? */</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(CONFIG_ARM) || defined(CONFIG_X86) || defined(CONFIG_NDS32) || \</span></span><br><span class="line"><span class="meta">		defined(CONFIG_MICROBLAZE) || defined(CONFIG_AVR32)</span></span><br><span class="line">	dram_init,		<span class="comment">/*gd-&gt;ram_size = imx_ddr_size();把 外部能用的DDR大小付给gd-&gt;ram_size */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span>    </span></span><br><span class="line">    INIT_FUNC_WATCHDOG_RESET</span><br><span class="line">    INIT_FUNC_WATCHDOG_RESET</span><br><span class="line">    INIT_FUNC_WATCHDOG_RESET</span><br><span class="line"> 	setup_dest_addr,	<span class="comment">/* 这个函数下方详细介绍 */</span></span><br><span class="line">   	reserve_round_4k,	<span class="comment">/* gd-&gt;relocaddr &amp;= ~(4096 - 1);重定位地址4k 对齐 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> !(defined(CONFIG_SYS_ICACHE_OFF) &amp;&amp; defined(CONFIG_SYS_DCACHE_OFF)) &amp;&amp; \</span></span><br><span class="line"><span class="meta">		defined(CONFIG_ARM)</span></span><br><span class="line">	reserve_mmu,		<span class="comment">/* 这个函数下方详细介绍 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">   	reserve_trace,		<span class="comment">/*留出debug 空间，I.MX6ULL 来说是空函数*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> !defined(CONFIG_BLACKFIN)</span></span><br><span class="line">	reserve_uboot,		<span class="comment">/*留出 uboot code空间 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> CONFIG_SPL_BUILD</span></span><br><span class="line">	reserve_malloc,		<span class="comment">/*留出malloc 空间 TOTAL_MALLOC_LEN*/</span></span><br><span class="line">	reserve_board,		<span class="comment">/* 留出 sizeof(bd_t) 的空间*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	setup_machine,		<span class="comment">/* 设置机器id 等设置，I.MX6ULL 来说是空函数 */</span></span><br><span class="line">	reserve_global_data,	<span class="comment">/*留出sizeof(gd_t)的空间 */</span></span><br><span class="line">	reserve_fdt,		<span class="comment">/* 留出 fdt_size 的空间,I.MX6ULL 无效 */</span></span><br><span class="line">	reserve_arch,		<span class="comment">/* I.MX6ULL 来说是空函数 */</span></span><br><span class="line">	reserve_stacks,		<span class="comment">/*gd-&gt;start_addr_sp 栈顶做16字节对齐  */</span></span><br><span class="line">	setup_dram_config,	<span class="comment">/* 设置Dram的地址和大小，后续告诉linux 内核 */</span></span><br><span class="line">	show_dram_config,	<span class="comment">/* 打印上述信息  */</span></span><br><span class="line">	display_new_sp,    	<span class="comment">/* 打印sp-栈顶 */</span></span><br><span class="line">   	INIT_FUNC_WATCHDOG_RESET	</span><br><span class="line">	reloc_fdt,			<span class="comment">/* I.MX6ULL 没有用到 */</span></span><br><span class="line">重要：setup_reloc,		<span class="comment">/*设置一些重定位要用的参数，并且将gd 从ram中拷贝到DDR中* / </span></span><br><span class="line"><span class="comment">    	NULL,</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br></pre></td></tr></table></figure>

<p>可以看出，<code>board_init_f(0)</code>总体上是围绕<code>global_data</code>展开的，关于<code>global_data</code>可以参考这篇文档：<a target="_blank" rel="noopener" href="https://blog.csdn.net/wenjin359/article/details/82849492%EF%BC%8C">https://blog.csdn.net/wenjin359/article/details/82849492，</a></p>
<ul>
<li><p>setup_dest_addr 函数</p>
<ul>
<li><p>作用：初始化<code>gd-&gt;ram_siz</code>、<code>gd-&gt;ram_top</code>、<code>gd-&gt;relocaddr </code>。</p>
 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">setup_dest_addr</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	gd-&gt;ram_size = board_reserve_ram_top(gd-&gt;ram_size);<span class="comment">// ram_szie 前面已经init过了，是imx_ddr_size()</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SYS_SDRAM_BASE</span></span><br><span class="line">	gd-&gt;ram_top = CONFIG_SYS_SDRAM_BASE;	<span class="comment">//设置为DDR base 地址CONFIG_SYS_SDRAM_BASE</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	gd-&gt;ram_top += get_effective_memsize();<span class="comment">// base + gd-&gt;ram_size </span></span><br><span class="line">	gd-&gt;ram_top = board_get_usable_ram_top(gd-&gt;mon_len);</span><br><span class="line">	gd-&gt;relocaddr = gd-&gt;ram_top;			<span class="comment">//重定位地址 = gd-&gt;ram_top</span></span><br><span class="line">	debug(<span class="string">&quot;Ram top: %08lX\n&quot;</span>, (ulong)gd-&gt;ram_top);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>reserve_round_4k 函数，把刚刚初始化的<code>gd-&gt;relocaddr</code>地址4K对齐。<code>gd-&gt;relocaddr &amp;= ~(4096 - 1);</code></p>
</li>
<li><p>reserve_mmu:</p>
<ul>
<li>作用：在DDR中留出<code>PGTABLE_SIZE</code>大小的空间用于做tlb。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">reserve_mmu</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/* reserve TLB table */</span></span><br><span class="line">	gd-&gt;arch.tlb_size = PGTABLE_SIZE;</span><br><span class="line">	gd-&gt;relocaddr -= gd-&gt;arch.tlb_size;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* round down to next 64 kB limit */</span></span><br><span class="line">	gd-&gt;relocaddr &amp;= ~(<span class="number">0x10000</span> - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">	gd-&gt;arch.tlb_addr = gd-&gt;relocaddr;</span><br><span class="line">	debug(<span class="string">&quot;TLB table from %08lx to %08lx\n&quot;</span>, gd-&gt;arch.tlb_addr,</span><br><span class="line">	      gd-&gt;arch.tlb_addr + gd-&gt;arch.tlb_size);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>&#x3D;&#x3D;reserve_uboot：&#x3D;&#x3D;</p>
<ul>
<li><p>作用：留出code_len 的空间，并且把此时<code>relocaddr</code>地址付给<code>start_addr_sp</code>。<strong>注意，这里开始gd-&gt;relocaddr</strong>不再继续减小了，因为已经到了代码段都拷完的地方了，重定位的地址已经确定好了！！！</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">reserve_uboot</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	gd-&gt;relocaddr -= gd-&gt;mon_len;</span><br><span class="line">	gd-&gt;relocaddr &amp;= ~(<span class="number">4096</span> - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">	debug(<span class="string">&quot;Reserving %ldk for U-Boot at: %08lx\n&quot;</span>, gd-&gt;mon_len &gt;&gt; <span class="number">10</span>,</span><br><span class="line">	      gd-&gt;relocaddr);</span><br><span class="line"></span><br><span class="line">	gd-&gt;start_addr_sp = gd-&gt;relocaddr;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>其余剩余的reserve_xxx 函数都是在DDR 内存中，划分出对应区域给对应功能实用。有以下几个参数需要注意一下</p>
<ul>
<li><p>重定位offset 偏移：<code>gd-&gt;reloc_off = gd-&gt;relocaddr - CONFIG_SYS_TEXT_BASE;</code></p>
</li>
<li><p>会有一次gd 的搬运：，其中gd 的宏定义展开见下方，由于之前将<strong>将cpu ram 的gd 指针存储在R9</strong>中，所以芯片内部的ram 中有一份global_data结构体。新的gd 会放在全局变量后面：参考<code>reserve_global_data</code>函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//搬运：</span></span><br><span class="line">`<span class="built_in">memcpy</span>(gd-&gt;new_gd, (<span class="type">char</span> *)gd, <span class="keyword">sizeof</span>(<span class="type">gd_t</span>));`</span><br><span class="line"><span class="comment">//获取老gd 地址：</span></span><br><span class="line">__asm__ <span class="title function_">volatile</span><span class="params">(<span class="string">&quot;mov %0, r9\n&quot;</span> : <span class="string">&quot;=r&quot;</span> (gd_ptr))</span>;</span><br><span class="line"><span class="comment">//新GD 地址</span></span><br><span class="line"> gd-&gt;new_gd = (<span class="type">gd_t</span> *)map_sysmem(gd-&gt;start_addr_sp, <span class="keyword">sizeof</span>(<span class="type">gd_t</span>));</span><br><span class="line">   </span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>总结：由此 board_info 就执行完了，主要是初始化了DDR的内存布局，并且对golobal data 进行初始化，同时拷贝进了DDR中。</p>
</li>
</ul>
<h4 id="2-5-4-再次回到-main-函数"><a href="#2-5-4-再次回到-main-函数" class="headerlink" title="2.5.4 再次回到 _main 函数"></a>2.5.4 再次回到 _main 函数</h4><p>执行完DDR区域分配及配置好gd 之后，会执行下面的操作：</p>
<ul>
<li><p>把 sp设置到DDR上：<code>ldr   sp, [r9, #GD_START_ADDR_SP] /* sp = gd-&gt;start_addr_sp */</code></p>
</li>
<li><p>初始化栈，之后会执行代码段的重定位，需要注意<code>lr</code>的值，再次返回时就已经到DDR中的重定位地址了。</p>
</li>
<li><p>问题：当前代码在什么地址？**R:**根据obj dump 来看，在<code>87802800 &lt;_main&gt;:</code>DDR 中。</p>
</li>
<li><p>&#x3D;&#x3D;追问：&#x3D;&#x3D;那为什么需要再搬运一次地址？新搬运的地址在哪里？**R:**搬运的地址是<code>board_init_f()</code>中设置的地址，提高了灵活性？</p>
</li>
</ul>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"> <span class="meta">#<span class="keyword">if</span> defined(CONFIG_CPU_V7M)	<span class="comment">/* v7M forbids using SP as BIC destination */</span></span></span><br><span class="line"> 	mov	r3, sp</span><br><span class="line"> 	bic	r3, r3, #<span class="number">7</span></span><br><span class="line"> 	mov	sp, r3</span><br><span class="line"> <span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"> 	bic	sp, sp, #<span class="number">7</span>	<span class="comment">/* 8-byte alignment for ABI compliance */</span></span><br><span class="line"> <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"> 	ldr	r9, [r9, #GD_BD]		<span class="comment">/* r9 = gd-&gt;bd */</span></span><br><span class="line"> 	sub	r9, r9, #GD_SIZE		<span class="comment">/* new GD is below bd */</span> 获取新gd的位置？</span><br><span class="line"> </span><br><span class="line"> 	adr	lr, here</span><br><span class="line"> 	ldr	r0, [r9, #GD_RELOC_OFF]		<span class="comment">/* r0 = gd-&gt;reloc_off */</span></span><br><span class="line"> 	add	lr, lr, r0				  lr  = here 地址 + gd-&gt;reloc_off </span><br><span class="line"> <span class="meta">#<span class="keyword">if</span> defined(CONFIG_CPU_V7M)</span></span><br><span class="line"> 	orr	lr, #<span class="number">1</span>				<span class="comment">/* As required by Thumb-only */</span></span><br><span class="line"> <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"> 	ldr	r0, [r9, #GD_RELOCADDR]		<span class="comment">/* r0 = gd-&gt;relocaddr */</span></span><br><span class="line"> 	b	relocate_code			<span class="comment">/*代码从定位*/</span> 所以执行完这个，跳回的时候就已经在DDR中了？</span><br><span class="line"> here:</span><br><span class="line"> <span class="comment">/*</span></span><br><span class="line"><span class="comment">  * now relocate vectors</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> 	bl	relocate_vectors 	 </span><br><span class="line"> <span class="comment">/* Set up final (full) environment */</span></span><br><span class="line">bl	c_runtime_cpu_setup	<span class="comment">/* we still call old routine here */</span></span><br><span class="line"> <span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>执行<code>relocate_code</code>函数</p>
<p>​		见下方代码，r1是代码段起始地址，r0是传入的<code>gd-&gt;relocaddr</code>重定位地址，整体作用是判断起始地址和<code>relocaddr</code>是否相等，不相等的话就会进行代码段的搬运（__image_copy_start ~ image_copy_end）。然后进行<code>dyn</code>段，即动态代码段的符号表地址的更改。【此处涉及到elf文件的表示，有兴趣的可以查阅elf 文件格式，了解动态代码是如何执行的。】</p>
<p><strong>注意：</strong>这里跳转使用的是<code>b</code>而不是<strong>bl</strong>就是不需要更改<strong>LR</strong>的值，因为LR 已经被重定位了。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">ENTRY(relocate_code)</span><br><span class="line">	ldr	r1, =__image_copy_start	/* r1 &lt;- SRC &amp;__image_copy_start */</span><br><span class="line">	subs	r4, r0, r1		/* r4 &lt;- relocation offset */</span><br><span class="line">	beq	relocate_done		/* skip relocation */</span><br><span class="line">	ldr	r2, =__image_copy_end	/* r2 &lt;- SRC &amp;__image_copy_end */</span><br><span class="line"></span><br><span class="line">copy_loop:</span><br><span class="line">	ldmia	r1!, &#123;r10-r11&#125;		/* copy from source address [r1]    */</span><br><span class="line">	stmia	r0!, &#123;r10-r11&#125;		/* copy to   target address [r0]    */</span><br><span class="line">	cmp	r1, r2			/* until source end address [r2]    */</span><br><span class="line">	blo	copy_loop</span><br><span class="line"></span><br><span class="line">	/*</span><br><span class="line">	 * fix .rel.dyn relocations</span><br><span class="line">	 */</span><br><span class="line">	ldr	r2, =__rel_dyn_start	/* r2 &lt;- SRC &amp;__rel_dyn_start */</span><br><span class="line">	ldr	r3, =__rel_dyn_end	/* r3 &lt;- SRC &amp;__rel_dyn_end */</span><br><span class="line">fixloop:</span><br><span class="line">	ldmia	r2!, &#123;r0-r1&#125;		/* (r0,r1) &lt;- (SRC location,fixup) */</span><br><span class="line">	and	r1, r1, #0xff</span><br><span class="line">	cmp	r1, #23			/* relative fixup? */</span><br><span class="line">	bne	fixnext</span><br><span class="line"></span><br><span class="line">	/* relative fix: increase location by offset */</span><br><span class="line">	add	r0, r0, r4</span><br><span class="line">	ldr	r1, [r0]</span><br><span class="line">	add	r1, r1, r4</span><br><span class="line">	str	r1, [r0]</span><br><span class="line">fixnext:</span><br><span class="line">	cmp	r2, r3</span><br><span class="line">	blo	fixloop</span><br><span class="line"></span><br><span class="line">relocate_done:</span><br><span class="line">	bx	lr</span><br><span class="line">ENDPROC(relocate_code)</span><br></pre></td></tr></table></figure>
</li>
<li><p>向量表的重定位：</p>
<p>由于<code>arm</code>处理器将向量表放在代码头部，所以这里中断向量表的重定位也是设置 cp15-c12 的值，将其设置为<code>gd-&gt;relocaddr</code>，即重定位代码段的首地址。编译后的程序如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ENTRY(relocate_vectors)	</span><br><span class="line">	ldr	r0, [r9, #GD_RELOCADDR]	/* r0 = gd-&gt;relocaddr */</span><br><span class="line">	mcr     p15, 0, r0, c12, c0, 0  /* Set VBAR */</span><br><span class="line">	bx	lr</span><br><span class="line">ENDPROC(relocate_vectors)	</span><br></pre></td></tr></table></figure>
</li>
<li><p>执行<code>c_runtime_cpu_setup 函数</code>，此代码在<code>arch/arm/cpu/armv7/start.S </code>中，作用是关闭指令cache</p>
</li>
<li><p>执行清除BSS段的汇编代码</p>
</li>
<li><p>跳转执行到<code>board_init_r()</code>，至此<strong>—main</strong>函数运行结束。</p>
</li>
</ul>
<h3 id="2-6-执行board-init-r函数，开始最后的初始化"><a href="#2-6-执行board-init-r函数，开始最后的初始化" class="headerlink" title="2.6 执行board_init_r函数，开始最后的初始化"></a>2.6 执行board_init_r函数，开始最后的初始化</h3><p>board_init_r函数如下，如同board_init_f 函数，主要是遍历了<code>init_sequence_r</code>这样一个函数指针结构提。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">void board_init_r(gd_t *new_gd, ulong dest_addr)</span><br><span class="line">&#123;</span><br><span class="line">	if (initcall_run_list(init_sequence_r))</span><br><span class="line">		hang();</span><br><span class="line">	/* NOTREACHED - run_main_loop() does not return */</span><br><span class="line">	hang();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同样，对于<code>init_sequence_r</code>这样一个函数指针数据，我们分析其条件条件编译之后的参数项</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">init_fnc_t</span> init_sequence_r[] = &#123;</span><br><span class="line">	initr_trace, <span class="comment">/* 初始化追踪调试内容 */</span></span><br><span class="line">	initr_reloc,	<span class="comment">/* gd-&gt;flags |= GD_FLG_RELOC | GD_FLG_FULL_MALLOC_INIT; 表示重定位完成 */</span></span><br><span class="line">	<span class="comment">/* <span class="doctag">TODO:</span> could x86/PPC have this also perhaps? */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_ARM</span></span><br><span class="line">	initr_caches,<span class="comment">/* 使能cache  */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	initr_reloc_global_data, <span class="comment">/* 修改重定位之后的 gd 参数 */</span></span><br><span class="line">	initr_barrier,			<span class="comment">/*  I.MX6ULL 来说是空函数   */</span></span><br><span class="line">	initr_malloc,			<span class="comment">/* 初始化 malloc 的内存空间，一些全局变量参数  */</span></span><br><span class="line">	initr_console_record,	<span class="comment">/* I.MX6ULL 来说是空函数  */</span></span><br><span class="line">	bootstage_relocate,		<span class="comment">/* bootstage重定位-但实际未看到*/</span></span><br><span class="line">	initr_bootstage,		<span class="comment">/* 初始化 bootstage*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(CONFIG_ARM) || defined(CONFIG_NDS32)</span></span><br><span class="line">	board_init,	<span class="comment">/* Setup chipselects 	- 片上外设初始化在这里 USB IIC FEC QSPI 等等*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	stdio_init_tables,		<span class="comment">/* 初始化 STDIO */</span></span><br><span class="line">	initr_serial,			<span class="comment">/* 串行设备初始化 */</span></span><br><span class="line">	initr_announce,</span><br><span class="line">	INIT_FUNC_WATCHDOG_RESET    </span><br><span class="line">	power_init_board,       <span class="comment">/* 电源初始化- imx6ull 来说是空函数*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_GENERIC_MMC</span></span><br><span class="line">	initr_mmc,				<span class="comment">/* 初始化mmc */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    initr_env,				<span class="comment">/* 环境变量初始化 */</span></span><br><span class="line">   	INIT_FUNC_WATCHDOG_RESET</span><br><span class="line">	initr_secondary_cpu,	<span class="comment">/* 多核初始化,I.MX6ULL 来说是空函数 */</span></span><br><span class="line">   	stdio_add_devices,		<span class="comment">/* 各种输入输出外设初始化 */</span></span><br><span class="line">	initr_jumptable,		<span class="comment">/* 初始化跳转表 */</span></span><br><span class="line">    console_init_r,			<span class="comment">/* 人机交互控制台初始化 */</span></span><br><span class="line">    interrupt_init,			<span class="comment">/* 中断堆栈初始化 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(CONFIG_ARM) || defined(CONFIG_AVR32)</span></span><br><span class="line">	initr_enable_interrupts,	<span class="comment">/* 中断使能 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="meta">#<span class="keyword">ifdef</span> CONFIG_CMD_NET</span></span><br><span class="line">	initr_ethaddr,			<span class="comment">/* 获取环境变量“ethaddr” 来初始化MAC的值 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_BOARD_LATE_INIT</span></span><br><span class="line">	board_late_init,		<span class="comment">/* 后续初始化，如果环境变量需要存储在EMMC/SD 中的话， 会初始化EMMC,并且调用了 cmd 接口*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_CMD_NET</span></span><br><span class="line">	INIT_FUNC_WATCHDOG_RESET</span><br><span class="line">	initr_net,				<span class="comment">/* 网口初始化 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">        imx6_light_up_led2,</span><br><span class="line"></span><br><span class="line">	run_main_loop,			<span class="comment">/* uboot 的主命令循环 */</span></span><br><span class="line">&#125;;       </span><br></pre></td></tr></table></figure>

<p>由上注释可见，调用<code>board_init_r</code>函数更多的是板级初始化的设置，让整个SOC板子和外设能够正常的运行起来，进入到main_loop 的函数。</p>
<h2 id="3-整体函数调用框架"><a href="#3-整体函数调用框架" class="headerlink" title="3. 整体函数调用框架"></a>3. 整体函数调用框架</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">a[reset]--&gt;|set scv mode|cpu_init_cp15</span><br><span class="line">a--&gt;cpu_init_crit--&gt;lowlevel_init--&gt;s_init</span><br><span class="line">a--&gt;b[_main]</span><br><span class="line">b--&gt;board_init_f_alloc_reserve</span><br><span class="line">b--&gt;board_init_f_init_reserve</span><br><span class="line">b--&gt;board_init_f--&gt;initcall_run_list-init_sequence_f</span><br><span class="line">b--&gt;relocate_code</span><br><span class="line">b--&gt;relocate_vectors</span><br><span class="line">b--&gt;|bss-init|c_runtime_cpu_setup</span><br><span class="line">b--&gt;board_init_r</span><br></pre></td></tr></table></figure>



<p>有了整体框架之后我们依次简短的介绍下各个函数的作用</p>
<ul>
<li>cpu_init_cp15：在进入SVC 模式之后，关闭各种Cache、MMU，读取<code>CPU variant + revision</code>CPU 信息。</li>
<li>cpu_init_crit：第一次初始化 SP 在CPU内部的SRAM中。并且给结构体数组<code>gd_date</code>留出空间，把<code>gd_data</code>的指针赋值给r9，后面可以直接通过r9寄存器调用gd。（sram内部）然后调用s_init了。</li>
<li>board_init_f_alloc_reserve：在_main 函数中会重新设定<code>sp</code>的值为<code>CONFIG_SYS_INIT_SP_ADDR</code>，在此函数中会在sram中留出<strong>malloc 和 global_data</strong>的空间</li>
<li>board_init_f_init_reserve：把global_data 的空间清0，并且设定malloc 的空间起始地址。为执行C语言的环境做准备。</li>
<li>board_init_f：调用<code>initcall_run_list(init_sequence_f)</code>函数来初步板级初始化（CPU特性、时钟、环境变量、串行显示等）和对内存的划分（boot 使用的内存空间、global_date、relocate、mmu_TLB、ENV）信息的存储。</li>
<li>relocate_code &amp; relocate_vectors：代码和中断向量的重定位</li>
<li>board_init_r：调用<code>initcall_run_list(init_sequence_r)</code>函数来进一步初始化板级外设、设置和开启中断，最后进入<strong>run_main_loop</strong>函数等待执行命令。</li>
</ul>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2024-06-06T15:00:09.069Z" title="2024/6/6 23:00:09">2024-06-06</time>发表</span><span class="level-item"><time dateTime="2024-06-06T15:02:45.714Z" title="2024/6/6 23:02:45">2024-06-06</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/uboot-linux/">uboot_linux</a></span><span class="level-item">21 分钟读完 (大约3179个字)</span></div></div><div class="content"><h1 id="从头理清uboot（1）-makefile-分析"><a href="#从头理清uboot（1）-makefile-分析" class="headerlink" title="从头理清uboot（1）-makefile 分析"></a>从头理清uboot（1）-makefile 分析</h1><p>[toc]</p>
<h2 id="1-简单介绍及背景"><a href="#1-简单介绍及背景" class="headerlink" title="1.简单介绍及背景"></a>1.简单介绍及背景</h2><p>u-boot 的作用及背景：初始化外设、下载代码、搬运执行、boot kernel。（这个有很多解释了，就不再过多解释了^ - ^）</p>
<h2 id="2-makefile分析"><a href="#2-makefile分析" class="headerlink" title="2. makefile分析"></a>2. makefile分析</h2><h3 id="2-1-执行make-mx6ull-14x14-ddr512-emmc-defconfig-之后会发生什么？"><a href="#2-1-执行make-mx6ull-14x14-ddr512-emmc-defconfig-之后会发生什么？" class="headerlink" title="2.1 执行make mx6ull_14x14_ddr512_emmc_defconfig 之后会发生什么？"></a>2.1 执行make mx6ull_14x14_ddr512_emmc_defconfig 之后会发生什么？</h3><p>在uboot的编译中，我们会先利用<code>make mx6ull_14x14_ddr512_emmc_defconfig</code>类似指令去生成一个默认的<code>.config</code>文件，之后uboot 会根据这个<code>.config</code>文件编译成<code>uboot.bin</code>。</p>
<p>执行这个命令，在顶层makefile中会有下面这个规则和其匹配，可以看出其依赖于scripts_basic  outputmakefile FORCE 这三个变量。</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">%config: scripts_basic outputmakefile FORCE</span></span><br><span class="line">	<span class="variable">$(Q)</span><span class="variable">$(MAKE)</span> <span class="variable">$(build)</span>=scripts/kconfig <span class="variable">$@</span></span><br></pre></td></tr></table></figure>

<p>其中需要处理的变量分别如下：</p>
<h5 id="1-scripts-basic"><a href="#1-scripts-basic" class="headerlink" title="1. scripts_basic  :"></a>1. scripts_basic  :</h5><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">scripts_basic:</span></span><br><span class="line">	<span class="variable">$(Q)</span><span class="variable">$(MAKE)</span> <span class="variable">$(build)</span>=scripts/basic</span><br><span class="line">	<span class="variable">$(Q)</span>rm -f .tmp_quiet_recordmcount</span><br></pre></td></tr></table></figure>

<p>​	分析其中几个变量的初始化值：</p>
<ol>
<li><p><code>$(Q)</code>在开头有如下定义，其中<code>$(origin V)</code>是判断V 的来源是不是输入的<code>command line</code>。在编译config 的时候，我们没有定义<code>v</code>于是<code>KBUILD_VERBOSE =0</code>进而quiet 和Q 都不是空</p>
<ul>
<li>会有什么影响：在makefile中 @ 和 quiet_ 都是用于抑制输出。<strong>加载命令行前就不会输出对应的makefile命令行</strong></li>
</ul>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ifeq</span> (<span class="string">&quot;$(origin V)&quot;</span>, <span class="string">&quot;command line&quot;</span>)</span><br><span class="line">  KBUILD_VERBOSE = <span class="variable">$(V)</span></span><br><span class="line"><span class="keyword">endif</span></span><br><span class="line"><span class="keyword">ifndef</span> KBUILD_VERBOSE</span><br><span class="line">  KBUILD_VERBOSE = 0</span><br><span class="line"><span class="keyword">endif</span></span><br><span class="line"><span class="keyword">ifeq</span> (<span class="variable">$(KBUILD_VERBOSE)</span>,1)</span><br><span class="line">  quiet =</span><br><span class="line">  Q =</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  quiet=quiet_</span><br><span class="line">  Q = @</span><br><span class="line"><span class="keyword">endif</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li><p><code>$(make)</code> 一般为对应的make 指令,为make 或者gmake.</p>
</li>
<li><p><code>$(build)</code> buiild 在顶层makefile 没有被调用，在<code>scripts/Kbuild.include</code>的文件中有定义如下：</p>
</li>
</ol>
 <figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">###</span></span><br><span class="line"><span class="comment"># Shorthand for $(Q)$(MAKE) -f scripts/Makefile.build obj=</span></span><br><span class="line"><span class="comment"># Usage:</span></span><br><span class="line"><span class="comment"># $(Q)$(MAKE) $(build)=dir</span></span><br><span class="line">build := -f <span class="variable">$(srctree)</span>/scripts/Makefile.build obj</span><br></pre></td></tr></table></figure>

<p> 那么有以下问题：</p>
<ul>
<li><p>怎么会包含这个Kbuild.include？ R: 因为主makefile 包含了这个文件：<code>include scripts/Kbuild.include</code>。</p>
</li>
<li><p>$(srctree)的值是多少？R:见下面的makefile语法，由于变量<code>KBUILD_SRC</code>没有被定义，所以<code>srctree := .</code>，其中<code>:=</code>  表示立即赋值，在尽显赋值时机会被计算展开，否则采用<code>=</code>时，只会在使用时展开。</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ifeq</span> (<span class="variable">$(KBUILD_SRC)</span>,)</span><br><span class="line">        <span class="comment"># building in the source tree</span></span><br><span class="line">        srctree := . </span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">        <span class="keyword">ifeq</span> (<span class="variable">$(KBUILD_SRC)</span>/,<span class="variable">$(<span class="built_in">dir</span> <span class="variable">$(CURDIR)</span>)</span>)</span><br><span class="line">                <span class="comment"># building in a subdirectory of the source tree</span></span><br><span class="line">                srctree := ..</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">                srctree := <span class="variable">$(KBUILD_SRC)</span></span><br><span class="line">        <span class="keyword">endif</span></span><br><span class="line"><span class="keyword">endif</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p> 由此我们可以 知道：<code>build := -f ./scripts/Makefile.build obj</code></p>
</li>
</ol>
<p>由此我们可以知道<code>scripts_basic</code>的最后定义为：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">scripts_basic:</span></span><br><span class="line">   @make -f ./scripts/Makefile.build obj=scripts/basic</span><br><span class="line">	@rm -f .tmp_quiet_recordmcount</span><br></pre></td></tr></table></figure>



<h5 id="2-outputmakefile"><a href="#2-outputmakefile" class="headerlink" title="2. outputmakefile"></a>2. outputmakefile</h5><p>由于变量<code>KBUILD_SRC</code> 没有定义，所以此项为空。</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">outputmakefile:</span></span><br><span class="line"><span class="keyword">ifneq</span> (<span class="variable">$(KBUILD_SRC)</span>,)</span><br><span class="line">	<span class="variable">$(Q)</span>ln -fsn <span class="variable">$(srctree)</span> source</span><br><span class="line">	<span class="variable">$(Q)</span><span class="variable">$(CONFIG_SHELL)</span> <span class="variable">$(srctree)</span>/scripts/mkmakefile \</span><br><span class="line">	    <span class="variable">$(srctree)</span> <span class="variable">$(objtree)</span> <span class="variable">$(VERSION)</span> <span class="variable">$(PATCHLEVEL)</span></span><br><span class="line"><span class="keyword">endif</span></span><br></pre></td></tr></table></figure>

<h5 id="3-FORCE"><a href="#3-FORCE" class="headerlink" title="3.FORCE"></a>3.FORCE</h5><p>FORCE 的值为常空，<strong>由此，FORCE是没有依赖的，每次重新编译，都会更新</strong>，由此所有依赖FORCE的编译选项也都会重新更新。</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PHONY += FORCE</span><br><span class="line"><span class="section">FORCE:</span></span><br></pre></td></tr></table></figure>

<p>经过上面三点的分析，我们回溯一下，makefile 实际上执行了这两个步骤：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">scripts_basic:</span></span><br><span class="line">	@make -f ./scripts/Makefile.build obj=scripts/basic</span><br><span class="line">	</span><br><span class="line"><span class="section">%config: scripts_basic outputmakefile FORCE</span></span><br><span class="line">	@make -f ./scripts/Makefile.build obj=scripts/kconfig \ mx6ull_14x14_ddr512_emmc_defconfig</span><br><span class="line"><span class="comment"># 在makefile 中 $@ 会被替换为当前正在构建的目标的名称</span></span><br></pre></td></tr></table></figure>



<h3 id="2-2-对于实际命令的进一步分析"><a href="#2-2-对于实际命令的进一步分析" class="headerlink" title="2.2 对于实际命令的进一步分析"></a>2.2 对于实际命令的进一步分析</h3><p>由上文的命令分析可知，其实最后就是分析上面两条命令，由此分别分析如下：</p>
<h4 id="1-make-f-scripts-Makefile-build-obj-scripts-basic"><a href="#1-make-f-scripts-Makefile-build-obj-scripts-basic" class="headerlink" title="1) @make -f .&#x2F;scripts&#x2F;Makefile.build obj&#x3D;scripts&#x2F;basic"></a>1) @make -f .&#x2F;scripts&#x2F;Makefile.build obj&#x3D;scripts&#x2F;basic</h4><p>同上，根据makefile的执行规则，由于我们没有指定目标文件，所以在<code>./scripts/Makefile.build</code>中会执行默认的<strong>第一个makefile目标</strong>：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">__build: $(if <span class="variable">$(KBUILD_BUILTIN)</span>,$(builtin-target) $(lib-target) $(extra-y)) \</span></span><br><span class="line">	 <span class="variable">$(<span class="built_in">if</span> <span class="variable">$(KBUILD_MODULES)</span>,$(obj-m)</span> $(modorder-target)) \</span><br><span class="line">	 $(subdir-ym) <span class="variable">$(always)</span></span><br><span class="line">	@:</span><br><span class="line">	</span><br><span class="line"><span class="comment"># 由于在顶层makefile中有以下定义：</span></span><br><span class="line">KBUILD_MODULES :=</span><br><span class="line">KBUILD_BUILTIN := 1</span><br></pre></td></tr></table></figure>

<p>所以上诉依赖可以转化为：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">__build: $(builtin-target) $(lib-target) $(extra-y) $(subdir-ym) <span class="variable">$(always)</span></span></span><br></pre></td></tr></table></figure>

<p>这里我们不再继续分析，采用打印的方式：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 添加内容：</span></span><br><span class="line">	@:</span><br><span class="line">	@echo builtin-target = $(builtin-target) </span><br><span class="line">	@echo lib-target = $(lib-target)</span><br><span class="line">	@echo extra-y = $(extra-y)</span><br><span class="line">	@echo subdir-ym = $(subdir-ym)</span><br><span class="line">	@echo always = <span class="variable">$(always)</span></span><br><span class="line"><span class="comment">#得到结果</span></span><br><span class="line">builtin-target =</span><br><span class="line">lib-target =</span><br><span class="line">extra-y =</span><br><span class="line">subdir-ym =</span><br><span class="line">always = scripts/basic/fixdep</span><br></pre></td></tr></table></figure>

<p>所以可知，执行上述命令后，会生成<code>scripts/basic/fixdep</code> 这个可执行文件。</p>
<p>查阅相关资料，得到下面结果：<code>fixdep</code> 在 U-Boot 构建系统中的作用是解析和处理头文件的依赖关系，确保 Makefile 能正确地跟踪文件之间的依赖性，从而保证编译结果的一致性和正确性。</p>
<hr>
<h4 id="2-make-f-scripts-Makefile-build-obj-scripts-kconfig-mx6ull-14x14-ddr512-emmc-defconfig"><a href="#2-make-f-scripts-Makefile-build-obj-scripts-kconfig-mx6ull-14x14-ddr512-emmc-defconfig" class="headerlink" title="2) @make -f .&#x2F;scripts&#x2F;Makefile.build obj&#x3D;scripts&#x2F;kconfig \ mx6ull_14x14_ddr512_emmc_defconfig"></a>2) @make -f .&#x2F;scripts&#x2F;Makefile.build obj&#x3D;scripts&#x2F;kconfig \ mx6ull_14x14_ddr512_emmc_defconfig</h4><p>和第一条编译指令不同，此make 指令含有编译目标文件<code>mx6ull_14x14_ddr512_emmc_defconfig</code>，且makefile.build 中没有对应目标项，自上向下分析<code>./scripts/Makefile.build</code>有以下：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Modified for U-Boot</span></span><br><span class="line">prefix := tpl</span><br><span class="line">src := <span class="variable">$(<span class="built_in">patsubst</span> <span class="variable">$(prefix)</span>/%,%,<span class="variable">$(obj)</span>)</span></span><br><span class="line"><span class="keyword">ifeq</span> (<span class="variable">$(obj)</span>,<span class="variable">$(src)</span>)</span><br><span class="line">prefix := spl</span><br><span class="line">src := <span class="variable">$(<span class="built_in">patsubst</span> <span class="variable">$(prefix)</span>/%,%,<span class="variable">$(obj)</span>)</span></span><br><span class="line"><span class="keyword">ifeq</span> (<span class="variable">$(obj)</span>,<span class="variable">$(src)</span>)</span><br><span class="line">prefix := .</span><br><span class="line"><span class="keyword">endif</span></span><br><span class="line"><span class="keyword">endif</span></span><br></pre></td></tr></table></figure>

<p>其中<code>$(patsubst pattern,replacement,src )</code>是makefile 的官方函数，就是从 src 中判断没有没pattern 有的话 就替换为replacement。所以上面的makefile 是判断<code>$(obj)</code> 是不是分别在<code>tpl/</code> 和<code>spl/</code> 目录下，如果是的，就把src替换掉，prefix 赋值为<code>tpl 或者spl</code>。</p>
<p>对于我们的make 指令肯定不是，由此有：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">src := scripts/kconfig</span><br><span class="line">prefix := .</span><br></pre></td></tr></table></figure>

<p>发现makefile会包含下面的文件</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># The filename Kbuild has precedence over Makefile</span></span><br><span class="line">kbuild-dir := <span class="variable">$(<span class="built_in">if</span> $(<span class="built_in">filter</span> /%,<span class="variable">$(src)</span>)</span>,<span class="variable">$(src)</span>,<span class="variable">$(srctree)</span>/<span class="variable">$(src)</span>)</span><br><span class="line">kbuild-file := <span class="variable">$(<span class="built_in">if</span> $(<span class="built_in">wildcard</span> $(kbuild-<span class="built_in">dir</span>)</span>/Kbuild),$(kbuild-dir)/Kbuild,$(kbuild-dir)/Makefile)</span><br><span class="line"><span class="keyword">include</span> $(kbuild-file)</span><br></pre></td></tr></table></figure>

<p>其中我们可以知道：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">kbuild-dir := ./scripts/kconfig</span><br><span class="line"># 因为./scripts/kconfig/Kbuild 不存在，</span><br><span class="line">kbuild-file := ./scripts/kconfig/Makefile</span><br><span class="line">include ./scripts/kconfig/Makefile</span><br></pre></td></tr></table></figure>

<p>同时在 <code>./scripts/kconfig/Makefile</code>中下面对应的目标项内容：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">%_defconfig: <span class="variable">$(obj)</span>/conf</span></span><br><span class="line">	<span class="variable">$(Q)</span><span class="variable">$&lt;</span> <span class="variable">$(silent)</span> --defconfig=arch/<span class="variable">$(SRCARCH)</span>/configs/<span class="variable">$@</span> <span class="variable">$(Kconfig)</span></span><br><span class="line">	</span><br><span class="line"><span class="comment"># 可以转化为下面的方式：</span></span><br><span class="line"><span class="section">%_defconfig: scripts/kconfig/conf </span></span><br><span class="line">@<span class="variable">$&lt;</span> -S --defconfig=arch/../configs/mx6ull_14x14_ddr512_emmc_defconfig  Kconfig</span><br></pre></td></tr></table></figure>

<p>逐步分析其中用到的参数：</p>
<ul>
<li><p><code>$(Q)</code> 以前聊过，根据命令行中是否有V @ or 空</p>
</li>
<li><p><code>$(silent)</code> 根据以下的输入为空 或者-s(静默模式)</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ifeq</span> (<span class="variable">$(quiet)</span>,silent_)</span><br><span class="line">silent := -s</span><br><span class="line"><span class="keyword">endif</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>$&lt; </code>表示第一个依赖文件，<code>$@</code> 表示目标文件</p>
</li>
<li><p><code>$(SRCARCH)</code> 的值是.. 这个搜索一下就能找到<code>SRCARCH := ..</code></p>
</li>
<li><p><code>$(Kconfig)</code> 的值为 Kconfig</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ifdef</span> KBUILD_KCONFIG</span><br><span class="line">Kconfig := <span class="variable">$(KBUILD_KCONFIG)</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">Kconfig := Kconfig</span><br><span class="line"><span class="keyword">endif</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p>综上对于命令再一次解析：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 可以转化为下面的方式：</span></span><br><span class="line"><span class="section">%_defconfig: scripts/kconfig/conf </span></span><br><span class="line">@<span class="variable">$&lt;</span> -S --defconfig=arch/../configs/mx6ull_14x14_ddr512_emmc_defconfig</span><br><span class="line">就是：</span><br><span class="line">@scripts/kconfig/conf  -S --defconfig=arch/../configs/mx6ull_14x14_ddr512_emmc_defconfig Kconfig</span><br></pre></td></tr></table></figure>
<p>这行命令中的 <code>$&lt;</code> 是一个自动变量，用于表示规则的第一个依赖文件，也就是 <code>conf</code> 脚本本身的文件路径。在这个命令中，<code>$&lt;</code> 被用作脚本的输入文件。</p>
<p>整个命令的含义是运行 <code>scripts/kconfig/conf</code> 脚本，并指定一些选项：</p>
<ul>
<li><code>-S</code> 选项告诉脚本只生成配置文件，而不进行任何交互式配置。</li>
<li><code>--defconfig=arch/../configs/mx6ull_14x14_ddr512_emmc_defconfig</code> 选项指定了一个默认的配置文件，这个配置文件将被用作输入。</li>
</ul>
<p>因此，该命令的目的是使用给定的默认配置文件运行 Kconfig 配置脚本，生成配置文件而不进行交互式配置。</p>
<h4 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h4><p>执行上述的命令最后结果是能够调用<code>scripts/kconfig/conf</code>去处理我们定义好的<code>arch/../configs/mx6ull_14x14_ddr512_emmc_defconfig</code>文件，最后会生成一个<code>.conifg</code> 文件，被uboot 编译使用。</p>
<h3 id="2-3-生成-config-之后的编译流程-make-j12"><a href="#2-3-生成-config-之后的编译流程-make-j12" class="headerlink" title="2.3 生成.config 之后的编译流程 make -j12"></a>2.3 生成.config 之后的编译流程 make -j12</h3><p>由于没有直接的目标文件，就会编译下面的文件</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># That&#x27;s our default target when none is given on the command line</span></span><br><span class="line">PHONY := _all</span><br><span class="line"><span class="section">_all:</span></span><br><span class="line"><span class="comment">#而 _all 又依赖于 all:</span></span><br><span class="line"><span class="keyword">ifeq</span> (<span class="variable">$(KBUILD_EXTMOD)</span>,)</span><br><span class="line"><span class="section">_all: all</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="section">_all: modules</span></span><br><span class="line"><span class="keyword">endif</span></span><br><span class="line"><span class="comment"># 之后会依赖这个文件$(ALL-y) </span></span><br><span class="line"><span class="section">all:		$(ALL-y)</span></span><br><span class="line"><span class="keyword">ifneq</span> (<span class="variable">$(CONFIG_SYS_GENERIC_BOARD)</span>,y)</span><br><span class="line">	@echo <span class="string">&quot;===================== WARNING ======================&quot;</span></span><br><span class="line">	@echo <span class="string">&quot;Please convert this board to generic board.&quot;</span></span><br><span class="line">	@echo <span class="string">&quot;Otherwise it will be removed by the end of 2014.&quot;</span></span><br><span class="line">	@echo <span class="string">&quot;See doc/README.generic-board for further information&quot;</span></span><br><span class="line">	@echo <span class="string">&quot;====================================================&quot;</span></span><br><span class="line"><span class="keyword">endif</span></span><br><span class="line"><span class="keyword">ifeq</span> (<span class="variable">$(CONFIG_DM_I2C_COMPAT)</span>,y)</span><br><span class="line">	@echo <span class="string">&quot;===================== WARNING ======================&quot;</span></span><br><span class="line">	@echo <span class="string">&quot;This board uses CONFIG_DM_I2C_COMPAT. Please remove&quot;</span></span><br><span class="line">	@echo <span class="string">&quot;(possibly in a subsequent patch in your series)&quot;</span></span><br><span class="line">	@echo <span class="string">&quot;before sending patches to the mailing list.&quot;</span></span><br><span class="line">	@echo <span class="string">&quot;====================================================&quot;</span></span><br><span class="line"><span class="keyword">endif</span></span><br></pre></td></tr></table></figure>

<p>对于不同的<code>.config</code>中的配置选项，<code>$(all-y)</code>会有下面的不同内容</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Always append ALL so that arch config.mk&#x27;s can add custom ones</span></span><br><span class="line">ALL-y += u-boot.srec u-boot.bin u-boot.sym System.map u-boot.cfg binary_size_check</span><br><span class="line"></span><br><span class="line">ALL-<span class="variable">$(CONFIG_ONENAND_U_BOOT)</span> += u-boot-onenand.bin</span><br><span class="line">	...</span><br><span class="line">	...</span><br><span class="line">	...</span><br><span class="line"><span class="comment"># Add optional build target if defined in board/cpu/soc headers</span></span><br><span class="line"><span class="keyword">ifneq</span> (<span class="variable">$(CONFIG_BUILD_TARGET)</span>,)</span><br><span class="line">ALL-y += $(CONFIG_BUILD_TARGET:<span class="string">&quot;%&quot;</span>=%)</span><br><span class="line"><span class="keyword">endif</span></span><br></pre></td></tr></table></figure>

<p>其中的处理方式都相同，如果在<code>.config</code> 定义了某一项的话,<code>all-y</code>就需要加上这一项。</p>
<p>例如 <code>CONFIG_ONENAND_U_BOOT=y</code>的话<code>ALL-$(CONFIG_ONENAND_U_BOOT) += u-boot-onenand.bin</code>就变成了<code>ALL-y += u-boot-onenand.bin</code>，就会产生新的依赖。</p>
<h5 id="1）-对于u-boot-bin的分析"><a href="#1）-对于u-boot-bin的分析" class="headerlink" title="1） 对于u-boot.bin的分析"></a>1） 对于<code>u-boot.bin</code>的分析</h5><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ifeq</span> (<span class="variable">$(CONFIG_OF_SEPARATE)</span>,y)   <span class="comment"># 不成立</span></span><br><span class="line"><span class="section">u-boot-dtb.bin: u-boot-nodtb.bin dts/dt.dtb FORCE</span></span><br><span class="line">	<span class="variable">$(<span class="built_in">call</span> if_changed,cat)</span></span><br><span class="line"></span><br><span class="line"><span class="section">u-boot.bin: u-boot-dtb.bin FORCE</span></span><br><span class="line">	<span class="variable">$(<span class="built_in">call</span> if_changed,copy)</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="section">u-boot.bin: u-boot-nodtb.bin FORCE #依赖于这个，没有dtb</span></span><br><span class="line">	<span class="variable">$(<span class="built_in">call</span> if_changed,copy)</span></span><br><span class="line"><span class="keyword">endif</span></span><br><span class="line"></span><br><span class="line"><span class="comment">### 会继续依赖这个</span></span><br><span class="line"><span class="section">u-boot-nodtb.bin: u-boot FORCE</span></span><br><span class="line">	<span class="variable">$(<span class="built_in">call</span> if_changed,objcopy)</span></span><br><span class="line">	<span class="variable">$(<span class="built_in">call</span> DO_STATIC_RELA,<span class="variable">$&lt;</span>,<span class="variable">$@</span>,<span class="variable">$(CONFIG_SYS_TEXT_BASE)</span>)</span></span><br><span class="line">	<span class="variable">$(BOARD_SIZE_CHECK)</span></span><br></pre></td></tr></table></figure>

<p>其中<code>$(call if_changed,copy)</code> 其中<code>$(call ...)</code>是用于调用自定义函数的接口。</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Execute command if command has changed or prerequisite(s) are updated.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line">if_changed = <span class="variable">$(<span class="built_in">if</span> $(<span class="built_in">strip</span> $(any-prereq)</span> $(arg-check)),     \</span><br><span class="line">	@set -e;                                                \</span><br><span class="line">	$(echo-cmd) $(cmd_$(1));                                \</span><br><span class="line">	printf &#x27;%s\n&#x27; &#x27;cmd_<span class="variable">$@</span> := $(make-cmd)&#x27; &gt; $(dot-target).cmd)</span><br></pre></td></tr></table></figure>

<p>这里面涉及到函数的处理流程，大意是实现copy的函数。从log 中可以看到下方log ，即就是单纯的copy  <code>u-boot-nodtb.bin</code>。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp u-boot-nodtb.bin u-boot.bin</span><br></pre></td></tr></table></figure>





<h5 id="2）对于-u-boot-nodtb-bin的分析"><a href="#2）对于-u-boot-nodtb-bin的分析" class="headerlink" title="2）对于 u-boot-nodtb.bin的分析"></a>2）对于 <code>u-boot-nodtb.bin</code>的分析</h5><p>通过log 可以看出，依赖于uboot，并且是通过obj-ccopy 指令生成的：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arm-linux-gnueabihf-objcopy --gap-fill=0xff  -j .text -j .secure_text -j .rodata -j .hash -j .data -j .got -j .got.plt -j .u_boot_list -j .rel.dyn -O binary  u-boot u-boot-nodtb.bin</span><br></pre></td></tr></table></figure>

<p>由上可知，这是通过提取u-boot 的各个section 生成的。</p>
<h5 id="3）对于u-boot的分析："><a href="#3）对于u-boot的分析：" class="headerlink" title="3）对于u-boot的分析："></a>3）对于u-boot的分析：</h5><p>根据log 可以看出使用的link 文件和依赖的.o 文件 </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arm-linux-gnueabihf-ld.bfd   -pie  --gc-sections -Bstatic -Ttext <span class="number">0x87800000</span> -o u-boot -T u-boot.lds arch/arm/cpu/armv7/start.o --start-group  arch/arm/cpu/built-<span class="keyword">in</span>.o  arch/arm/cpu/armv7/built-<span class="keyword">in</span>.o  arch/arm/imx-common/built-<span class="keyword">in</span>.o  arch/arm/lib/built-<span class="keyword">in</span>.o  board/freescale/common/built-<span class="keyword">in</span>.o  board/freescale/mx6ullevk/built-<span class="keyword">in</span>.o  cmd/built-<span class="keyword">in</span>.o  common/built-<span class="keyword">in</span>.o  disk/built-<span class="keyword">in</span>.o  drivers/built-<span class="keyword">in</span>.o  drivers/dma/built-<span class="keyword">in</span>.o  drivers/gpio/built-<span class="keyword">in</span>.o  drivers/i2c/built-<span class="keyword">in</span>.o  drivers/mmc/built-<span class="keyword">in</span>.o  drivers/mtd/built-<span class="keyword">in</span>.o  drivers/mtd/onenand/built-<span class="keyword">in</span>.o  drivers/mtd/spi/built-<span class="keyword">in</span>.o  drivers/net/built-<span class="keyword">in</span>.o  drivers/net/phy/built-<span class="keyword">in</span>.o  drivers/pci/built-<span class="keyword">in</span>.o  drivers/power/built-<span class="keyword">in</span>.o  drivers/power/battery/built-<span class="keyword">in</span>.o  drivers/power/fuel_gauge/built-<span class="keyword">in</span>.o  drivers/power/mfd/built-<span class="keyword">in</span>.o  drivers/power/pmic/built-<span class="keyword">in</span>.o  drivers/power/regulator/built-<span class="keyword">in</span>.o  drivers/serial/built-<span class="keyword">in</span>.o  drivers/spi/built-<span class="keyword">in</span>.o  drivers/usb/dwc3/built-<span class="keyword">in</span>.o  drivers/usb/emul/built-<span class="keyword">in</span>.o  drivers/usb/eth/built-<span class="keyword">in</span>.o  drivers/usb/gadget/built-<span class="keyword">in</span>.o  drivers/usb/gadget/udc/built-<span class="keyword">in</span>.o  drivers/usb/host/built-<span class="keyword">in</span>.o  drivers/usb/musb-new/built-<span class="keyword">in</span>.o  drivers/usb/musb/built-<span class="keyword">in</span>.o  drivers/usb/phy/built-<span class="keyword">in</span>.o  drivers/usb/ulpi/built-<span class="keyword">in</span>.o  fs/built-<span class="keyword">in</span>.o  lib/built-<span class="keyword">in</span>.o  net/built-<span class="keyword">in</span>.o  test/built-<span class="keyword">in</span>.o  test/dm/built-<span class="keyword">in</span>.o --end-group arch/arm/lib/eabi_compat.o  -L /usr/lib/gcc-cross/arm-linux-gnueabihf/<span class="number">9</span> -lgcc -Map u-boot.<span class="built_in">map</span></span><br></pre></td></tr></table></figure>

<p>从makefile 角度再分析uboot 的生成：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">u-boot:	$(u-boot-init) $(u-boot-main) u-boot.lds FORCE</span></span><br><span class="line">	<span class="variable">$(<span class="built_in">call</span> if_changed,u-boot__)</span></span><br><span class="line"><span class="keyword">ifeq</span> (<span class="variable">$(CONFIG_KALLSYMS)</span>,y)</span><br><span class="line">	<span class="variable">$(<span class="built_in">call</span> cmd,smap)</span></span><br><span class="line">	<span class="variable">$(<span class="built_in">call</span> cmd,u-boot__)</span> common/system_map.o</span><br><span class="line"><span class="keyword">endif</span></span><br></pre></td></tr></table></figure>

<p>其中：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">u-boot-init := $(head-y)</span><br><span class="line">u-boot-main := $(libs-y)</span><br></pre></td></tr></table></figure>

<p>其中<code>$(head-y)</code> 在arch&#x2F;arm&#x2F;Makefile 中有定义，而<code>$(libs-y)</code> 在顶层Makefile 中有定义：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">head-y := arch/arm/cpu/<span class="variable">$(CPU)</span>/start.o </span><br><span class="line"><span class="comment">#即为：</span></span><br><span class="line">head-y := arch/arm/cpu/armv7/start.o </span><br><span class="line"></span><br><span class="line">libs-y += lib/</span><br><span class="line">libs-<span class="variable">$(HAVE_VENDOR_COMMON_LIB)</span> += board/<span class="variable">$(VENDOR)</span>/common/</span><br><span class="line">libs-<span class="variable">$(CONFIG_OF_EMBED)</span> += dts/</span><br><span class="line">libs-y += fs/</span><br><span class="line">	...</span><br><span class="line">	...</span><br><span class="line">libs-y += <span class="variable">$(<span class="built_in">if</span> <span class="variable">$(BOARDDIR)</span>,board/<span class="variable">$(BOARDDIR)</span>/)</span></span><br><span class="line"></span><br><span class="line">libs-y := <span class="variable">$(<span class="built_in">sort</span> $(libs-y)</span>)</span><br><span class="line"></span><br><span class="line">u-boot-dirs	:= <span class="variable">$(<span class="built_in">patsubst</span> %/,%,$(<span class="built_in">filter</span> %/, $(libs-y)</span>)) tools examples</span><br><span class="line"></span><br><span class="line">u-boot-alldirs	:= <span class="variable">$(<span class="built_in">sort</span> $(u-boot-dirs)</span> <span class="variable">$(<span class="built_in">patsubst</span> %/,%,$(<span class="built_in">filter</span> %/, $(libs-)</span>)))</span><br><span class="line"></span><br><span class="line">libs-y		:= <span class="variable">$(<span class="built_in">patsubst</span> %/, %/built-in.o, $(libs-y)</span>)</span><br></pre></td></tr></table></figure>

<p>由上可知，依赖会分别获取 一个架构的启动文件和library 文件，并且在获取<code>libs-y </code>之后，做一次排序，之后利用<code>$(patsubst %/, %/built-in.o, $(libs-y))</code>将所有的子目录 以<code>/</code>结尾的变成<code>/built-in.o</code>，即将<code>fs/</code>变为<code>fs/built-in.o</code>类似。</p>
<ul>
<li>对于 <code>XXX/built-in.o</code>通过log 可以看出（一个例子）</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arm-linux-gnueabihf-ld.bfd     -r -o board/freescale/common/built-<span class="keyword">in</span>.o board/freescale/common/mmc.o </span><br></pre></td></tr></table></figure>

<p>其实是通过连接器，通过重定位+重命名的方式，链接成一个.o文件，上述是将mmc.o 链接成 了built-in.o。</p>
<h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><p>综上，对于Makefile的bin 文件生成有以上关系：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">graph TB</span><br><span class="line">A[XXX/built-in.o]--&gt;B[libs-y//u-boot-main]</span><br><span class="line">C[xxx/start.o]--&gt;D[head-y/u-boot-init]</span><br><span class="line">B--&gt;|u-boot.lds|e[u-boot]</span><br><span class="line">D--&gt;|u-boot.lds|e</span><br><span class="line">e--&gt;|arm-linux-gnueabihf-objcopy|f[u-boot-nodtb.bin]</span><br><span class="line">f--&gt;|copy|G[u-boot.bin]</span><br><span class="line"></span><br></pre></td></tr></table></figure>

</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2024-06-06T15:00:09.067Z" title="2024/6/6 23:00:09">2024-06-06</time>发表</span><span class="level-item"><time dateTime="2024-06-06T15:02:42.117Z" title="2024/6/6 23:02:42">2024-06-06</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/uboot-linux/">uboot_linux</a></span><span class="level-item">6 分钟读完 (大约874个字)</span></div></div><div class="content"><p>关于CP 的操作，参考这个链接：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/schips/p/11270644.html">https://www.cnblogs.com/schips/p/11270644.html</a></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br></pre></td><td class="code"><pre><span class="line">/*************************************************************************</span><br><span class="line"> *</span><br><span class="line"> * cpu_init_cp15</span><br><span class="line"> *</span><br><span class="line"> * Setup CP15 registers (cache, MMU, TLBs). The I-cache is turned on unless</span><br><span class="line"> * CONFIG_SYS_ICACHE_OFF is defined.</span><br><span class="line"> *</span><br><span class="line"> *************************************************************************/</span><br><span class="line">ENTRY(cpu_init_cp15)</span><br><span class="line">	/*</span><br><span class="line">	 * Invalidate L1 I/D</span><br><span class="line">	 */</span><br><span class="line">	mov	r0, #0			@ set up for MCR</span><br><span class="line">	mcr	p15, 0, r0, c8, c7, 0	@ 无效整个数据和指令TLB</span><br><span class="line">	mcr	p15, 0, r0, c7, c5, 0	@无效整个指令cache</span><br><span class="line">	mcr	p15, 0, r0, c7, c5, 6	@ 无效整个跳转目标cache</span><br><span class="line">	mcr p15, 0, r0, c7, c10, 4	@ 清空写缓存区</span><br><span class="line">	mcr p15, 0, r0, c7, c5, 4	@ 清空预取缓存区</span><br><span class="line"></span><br><span class="line">	/*</span><br><span class="line">	 * disable MMU stuff and caches</span><br><span class="line">	 */</span><br><span class="line">	mrc	p15, 0, r0, c1, c0, 0	@把cp15-c1 的值读到r0中</span><br><span class="line">	bic	r0, r0, #0x00002000	@ 设置低端一场中断向量表，且在可重定位状态</span><br><span class="line">	bic	r0, r0, #0x00000007	@ 关闭mmu、地址对齐、禁止cache</span><br><span class="line">	orr	r0, r0, #0x00000002	@ 使能地址对齐检查</span><br><span class="line">	orr	r0, r0, #0x00000800	@ 使能跳转预测</span><br><span class="line">#ifdef CONFIG_SYS_ICACHE_OFF</span><br><span class="line">	bic	r0, r0, #0x00001000	@ 关闭 I-cahe</span><br><span class="line">#else</span><br><span class="line">	orr	r0, r0, #0x00001000	@ 使能 I-cahe</span><br><span class="line">#endif</span><br><span class="line">	mcr	p15, 0, r0, c1, c0, 0</span><br><span class="line"></span><br><span class="line">#ifdef CONFIG_ARM_ERRATA_716044  --使能跳转预测</span><br><span class="line">	mrc	p15, 0, r0, c1, c0, 0	@ read system control register</span><br><span class="line">	orr	r0, r0, #1 &lt;&lt; 11	@ set bit #11</span><br><span class="line">	mcr	p15, 0, r0, c1, c0, 0	@ write system control register</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">//  --C15 寄存器会随着设计的不同而不同。</span><br><span class="line">#if (defined(CONFIG_ARM_ERRATA_742230) || defined(CONFIG_ARM_ERRATA_794072))</span><br><span class="line">	mrc	p15, 0, r0, c15, c0, 1	@ read diagnostic register</span><br><span class="line">	orr	r0, r0, #1 &lt;&lt; 4		@ set bit #4</span><br><span class="line">	mcr	p15, 0, r0, c15, c0, 1	@ write diagnostic register</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">#ifdef CONFIG_ARM_ERRATA_743622</span><br><span class="line">	mrc	p15, 0, r0, c15, c0, 1	@ read diagnostic register</span><br><span class="line">	orr	r0, r0, #1 &lt;&lt; 6		@ set bit #6</span><br><span class="line">	mcr	p15, 0, r0, c15, c0, 1	@ write diagnostic register</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">#ifdef CONFIG_ARM_ERRATA_751472</span><br><span class="line">	mrc	p15, 0, r0, c15, c0, 1	@ read diagnostic register</span><br><span class="line">	orr	r0, r0, #1 &lt;&lt; 11	@ set bit #11</span><br><span class="line">	mcr	p15, 0, r0, c15, c0, 1	@ write diagnostic register</span><br><span class="line">#endif</span><br><span class="line">#ifdef CONFIG_ARM_ERRATA_761320</span><br><span class="line">	mrc	p15, 0, r0, c15, c0, 1	@ read diagnostic register</span><br><span class="line">	orr	r0, r0, #1 &lt;&lt; 21	@ set bit #21</span><br><span class="line">	mcr	p15, 0, r0, c15, c0, 1	@ write diagnostic register</span><br><span class="line">#endif</span><br><span class="line">#ifdef CONFIG_ARM_ERRATA_845369</span><br><span class="line">	mrc	p15, 0, r0, c15, c0, 1	@ read diagnostic register</span><br><span class="line">	orr	r0, r0, #1 &lt;&lt; 22	@ set bit #22</span><br><span class="line">	mcr	p15, 0, r0, c15, c0, 1	@ write diagnostic register</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">	mov	r5, lr			@ Store my Caller</span><br><span class="line">	mrc	p15, 0, r1, c0, c0, 0	@ 把cp15-c0 读到r1</span><br><span class="line">	mov	r3, r1, lsr #20		@ get variant field</span><br><span class="line">	and	r3, r3, #0xf		@ r3 has CPU variant</span><br><span class="line">	and	r4, r1, #0xf		@ r4 has CPU revision</span><br><span class="line">	mov	r2, r3, lsl #4		@ shift variant field for combined value</span><br><span class="line">	orr	r2, r4, r2		@ r2 has combined CPU variant + revision</span><br><span class="line"></span><br><span class="line">#ifdef CONFIG_ARM_ERRATA_798870</span><br><span class="line">	cmp	r2, #0x30		@ Applies to lower than R3p0</span><br><span class="line">	bge	skip_errata_798870      @ skip if not affected rev</span><br><span class="line">	cmp	r2, #0x20		@ Applies to including and above R2p0</span><br><span class="line">	blt	skip_errata_798870      @ skip if not affected rev</span><br><span class="line"></span><br><span class="line">	mrc	p15, 1, r0, c15, c0, 0  @ read l2 aux ctrl reg</span><br><span class="line">	orr	r0, r0, #1 &lt;&lt; 7         @ Enable hazard-detect timeout</span><br><span class="line">	push	&#123;r1-r5&#125;			@ Save the cpu info registers</span><br><span class="line">	bl	v7_arch_cp15_set_l2aux_ctrl</span><br><span class="line">	isb				@ Recommended ISB after l2actlr update</span><br><span class="line">	pop	&#123;r1-r5&#125;			@ Restore the cpu info - fall through</span><br><span class="line">skip_errata_798870:</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">#ifdef CONFIG_ARM_ERRATA_801819</span><br><span class="line">	cmp	r2, #0x24		@ Applies to lt including R2p4</span><br><span class="line">	bgt	skip_errata_801819      @ skip if not affected rev</span><br><span class="line">	cmp	r2, #0x20		@ Applies to including and above R2p0</span><br><span class="line">	blt	skip_errata_801819      @ skip if not affected rev</span><br><span class="line">	mrc	p15, 0, r0, c0, c0, 6	@ pick up REVIDR reg</span><br><span class="line">	and	r0, r0, #1 &lt;&lt; 3		@ check REVIDR[3]</span><br><span class="line">	cmp	r0, #1 &lt;&lt; 3</span><br><span class="line">	beq	skip_errata_801819	@ skip erratum if REVIDR[3] is set</span><br><span class="line"></span><br><span class="line">	mrc	p15, 0, r0, c1, c0, 1	@ read auxilary control register</span><br><span class="line">	orr	r0, r0, #3 &lt;&lt; 27	@ Disables streaming. All write-allocate</span><br><span class="line">					@ lines allocate in the L1 or L2 cache.</span><br><span class="line">	orr	r0, r0, #3 &lt;&lt; 25	@ Disables streaming. All write-allocate</span><br><span class="line">					@ lines allocate in the L1 cache.</span><br><span class="line">	push	&#123;r1-r5&#125;			@ Save the cpu info registers</span><br><span class="line">	bl	v7_arch_cp15_set_acr</span><br><span class="line">	pop	&#123;r1-r5&#125;			@ Restore the cpu info - fall through</span><br><span class="line">skip_errata_801819:</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">#ifdef CONFIG_ARM_ERRATA_454179</span><br><span class="line">	cmp	r2, #0x21		@ Only on &lt; r2p1</span><br><span class="line">	bge	skip_errata_454179</span><br><span class="line"></span><br><span class="line">	mrc	p15, 0, r0, c1, c0, 1	@ Read ACR</span><br><span class="line">	orr	r0, r0, #(0x3 &lt;&lt; 6)	@ Set DBSM(BIT7) and IBE(BIT6) bits</span><br><span class="line">	push	&#123;r1-r5&#125;			@ Save the cpu info registers</span><br><span class="line">	bl	v7_arch_cp15_set_acr</span><br><span class="line">	pop	&#123;r1-r5&#125;			@ Restore the cpu info - fall through</span><br><span class="line"></span><br><span class="line">skip_errata_454179:</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">#ifdef CONFIG_ARM_ERRATA_430973</span><br><span class="line">	cmp	r2, #0x21		@ Only on &lt; r2p1</span><br><span class="line">	bge	skip_errata_430973</span><br><span class="line"></span><br><span class="line">	mrc	p15, 0, r0, c1, c0, 1	@ Read ACR</span><br><span class="line">	orr	r0, r0, #(0x1 &lt;&lt; 6)	@ Set IBE bit</span><br><span class="line">	push	&#123;r1-r5&#125;			@ Save the cpu info registers</span><br><span class="line">	bl	v7_arch_cp15_set_acr</span><br><span class="line">	pop	&#123;r1-r5&#125;			@ Restore the cpu info - fall through</span><br><span class="line"></span><br><span class="line">skip_errata_430973:</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">#ifdef CONFIG_ARM_ERRATA_621766</span><br><span class="line">	cmp	r2, #0x21		@ Only on &lt; r2p1</span><br><span class="line">	bge	skip_errata_621766</span><br><span class="line"></span><br><span class="line">	mrc	p15, 0, r0, c1, c0, 1	@ Read ACR</span><br><span class="line">	orr	r0, r0, #(0x1 &lt;&lt; 5)	@ Set L1NEON bit</span><br><span class="line">	push	&#123;r1-r5&#125;			@ Save the cpu info registers</span><br><span class="line">	bl	v7_arch_cp15_set_acr</span><br><span class="line">	pop	&#123;r1-r5&#125;			@ Restore the cpu info - fall through</span><br><span class="line"></span><br><span class="line">skip_errata_621766:</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">	mov	pc, r5			@ back to my caller</span><br><span class="line">ENDPROC(cpu_init_cp15)</span><br></pre></td></tr></table></figure>

</div></article></div></div><div class="column column-left is-4-tablet is-4-desktop is-4-widescreen  order-1"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar" src="/img/my.png" alt="Satellite"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">Satellite</p><p class="is-size-6 is-block">none</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>SZHOU,CHINA</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/archives"><p class="title">13</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/categories"><p class="title">2</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/tags"><p class="title">0</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/ppoffice" target="_blank" rel="me noopener">关注我</a></div></div></div><!--!--><div class="card widget" data-type="links"><div class="card-content"><div class="menu"><h3 class="menu-label">链接</h3><ul class="menu-list"><li><a class="level is-mobile" href="https://hexo.io" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Hexo</span></span><span class="level-right"><span class="level-item tag">hexo.io</span></span></a></li><li><a class="level is-mobile" href="https://bulma.io" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Bulma</span></span><span class="level-right"><span class="level-item tag">bulma.io</span></span></a></li></ul></div></div></div><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">分类</h3><ul class="menu-list"><li><a class="level is-mobile" href="/categories/uboot-linux/"><span class="level-start"><span class="level-item">uboot_linux</span></span><span class="level-end"><span class="level-item tag">6</span></span></a></li><li><a class="level is-mobile" href="/categories/%E7%A7%AF%E7%B4%AF/"><span class="level-start"><span class="level-item">积累</span></span><span class="level-end"><span class="level-item tag">7</span></span></a></li></ul></div></div></div><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">最新文章</h3><article class="media"><div class="media-content"><p class="date"><time dateTime="2024-06-06T15:00:09.076Z">2024-06-06</time></p><p class="title"><a href="/2024/06/06/%E7%A7%AF%E7%B4%AF/%E9%9A%8F%E7%AC%94%E9%97%AE%E9%A2%98/"> </a></p><p class="categories"><a href="/categories/%E7%A7%AF%E7%B4%AF/">积累</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2024-06-06T15:00:09.075Z">2024-06-06</time></p><p class="title"><a href="/2024/06/06/%E7%A7%AF%E7%B4%AF/vscode+clangd/"> </a></p><p class="categories"><a href="/categories/%E7%A7%AF%E7%B4%AF/">积累</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2024-06-06T15:00:09.074Z">2024-06-06</time></p><p class="title"><a href="/2024/06/06/uboot&amp;linux/uboot_analyse/"> </a></p><p class="categories"><a href="/categories/uboot-linux/">uboot_linux</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2024-06-06T15:00:09.072Z">2024-06-06</time></p><p class="title"><a href="/2024/06/06/uboot&amp;linux/uboot_3/"> </a></p><p class="categories"><a href="/categories/uboot-linux/">uboot_linux</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2024-06-06T15:00:09.071Z">2024-06-06</time></p><p class="title"><a href="/2024/06/06/uboot&amp;linux/uboot_2/"> </a></p><p class="categories"><a href="/categories/uboot-linux/">uboot_linux</a></p></div></article></div></div><div class="card widget" data-type="archives"><div class="card-content"><div class="menu"><h3 class="menu-label">归档</h3><ul class="menu-list"><li><a class="level is-mobile" href="/archives/2024/06/"><span class="level-start"><span class="level-item">六月 2024</span></span><span class="level-end"><span class="level-item tag">13</span></span></a></li></ul></div></div></div><!--!--><div class="card widget" data-type="subscribe-email"><div class="card-content"><div class="menu"><h3 class="menu-label">订阅更新</h3><form action="https://feedburner.google.com/fb/a/mailverify" method="post" target="popupwindow" onsubmit="window.open(&#039;https://feedburner.google.com/fb/a/mailverify?uri=&#039;,&#039;popupwindow&#039;,&#039;scrollbars=yes,width=550,height=520&#039;);return true"><input type="hidden" value="" name="uri"><input type="hidden" name="loc" value="en_US"><div class="field has-addons"><div class="control has-icons-left is-expanded"><input class="input" name="email" type="email" placeholder="Email"><span class="icon is-small is-left"><i class="fas fa-envelope"></i></span></div><div class="control"><input class="button" type="submit" value="订阅"></div></div></form></div></div></div><div class="card widget"><div class="card-content"><div class="notification is-danger">You need to set <code>client_id</code> and <code>slot_id</code> to show this AD unit. Please set it in <code>_config.yml</code>.</div></div></div><div class="card widget" data-type="subscribe-email"><div class="card-content"><div class="menu"><h3 class="menu-label">follow.it</h3><form action="" method="post" target="_blank"><div class="field has-addons"><div class="control has-icons-left is-expanded"><input class="input" name="email" type="email" placeholder="Email"><span class="icon is-small is-left"><i class="fas fa-envelope"></i></span></div><div class="control"><input class="button" type="submit" value="订阅"></div></div></form></div></div></div></div><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/logo.svg" alt="Hexo" height="28"></a><p class="is-size-7"><span>&copy; 2024 John Doe</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p><p class="is-size-7">© 2019</p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("zh-cn");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script data-pjax src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script data-pjax src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "此网站使用Cookie来改善您的体验。",
          dismiss: "知道了！",
          allow: "允许使用Cookie",
          deny: "拒绝",
          link: "了解更多",
          policy: "Cookie政策",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/pjax@0.2.8/pjax.min.js"></script><script src="/js/pjax.js"></script><!--!--><!--!--><!--!--><script data-pjax src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>