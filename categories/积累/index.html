<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="robots" content="noindex"><meta><title>分类: 积累 - Hexo</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="Hexo"><meta name="msapplication-TileImage" content="/img/favicon.svg"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="Hexo"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta property="og:type" content="blog"><meta property="og:title" content="Hexo"><meta property="og:url" content="https://satelite98.github.io/"><meta property="og:site_name" content="Hexo"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://satelite98.github.io/img/og_image.png"><meta property="article:author" content="John Doe"><meta property="twitter:card" content="summary"><meta property="twitter:image:src" content="https://satelite98.github.io/img/og_image.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://satelite98.github.io"},"headline":"Hexo","image":["https://satelite98.github.io/img/og_image.png"],"author":{"@type":"Person","name":"John Doe"},"publisher":{"@type":"Organization","name":"Hexo","logo":{"@type":"ImageObject","url":"https://satelite98.github.io/img/logo.svg"}},"description":""}</script><link rel="icon" href="/img/favicon.svg"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v6.0.0/css/all.css"><link data-pjax rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@11.7.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link data-pjax rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/css/justifiedGallery.min.css"><!--!--><!--!--><!--!--><style>.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pace-inactive{display:none}.pace .pace-progress{background:#3273dc;position:fixed;z-index:2000;top:0;right:100%;width:100%;height:2px}</style><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js"></script><!--!--><!--!--><!-- hexo injector head_end start --><script>
  (function () {
      function switchTab() {
          if (!location.hash) {
            return;
          }

          const id = '#' + CSS.escape(location.hash.substring(1));
          const $tabMenu = document.querySelector(`.tabs a[href="${id}"]`);
          if (!$tabMenu) {
            return;
          }

          const $tabMenuContainer = $tabMenu.parentElement.parentElement;
          Array.from($tabMenuContainer.children).forEach($menu => $menu.classList.remove('is-active'));
          Array.from($tabMenuContainer.querySelectorAll('a'))
              .map($menu => document.getElementById($menu.getAttribute("href").substring(1)))
              .forEach($content => $content.classList.add('is-hidden'));

          if ($tabMenu) {
              $tabMenu.parentElement.classList.add('is-active');
          }
          const $activeTab = document.querySelector(id);
          if ($activeTab) {
              $activeTab.classList.remove('is-hidden');
          }
      }
      switchTab();
      window.addEventListener('hashchange', switchTab, false);
  })();
  </script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.2.0"></head><body class="is-2-column"><nav class="navbar navbar-main"><div class="container navbar-container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/logo.svg" alt="Hexo" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/about">About</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-8-widescreen"><div class="card"><div class="card-content"><nav class="breadcrumb" aria-label="breadcrumbs"><ul><li><a href="/categories">分类</a></li><li class="is-active"><a href="#" aria-current="page">积累</a></li></ul></nav></div></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2024-06-06T15:00:09.076Z" title="2024/6/6 23:00:09">2024-06-06</time>发表</span><span class="level-item"><time dateTime="2024-06-06T15:01:40.510Z" title="2024/6/6 23:01:40">2024-06-06</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/%E7%A7%AF%E7%B4%AF/">积累</a></span><span class="level-item">20 分钟读完 (大约2964个字)</span></div></div><div class="content"><p>[toc]</p>
<h3 id="问题-：makefile-中-bulid-makefile-mk-这三种文件有什么区别吗？"><a href="#问题-：makefile-中-bulid-makefile-mk-这三种文件有什么区别吗？" class="headerlink" title="问题 ：makefile 中.bulid makefile .mk 这三种文件有什么区别吗？"></a>问题 ：makefile 中.bulid makefile .mk 这三种文件有什么区别吗？</h3><p>在使用 <code>make</code> 工具时，<code>makefile.build</code>、<code>makefile</code> 和 <code>.mk</code> 这三种文件名有一些区别，但主要在于命名惯例和使用习惯方面，而不在于 <code>make</code> 工具本身的功能上。</p>
<ol>
<li><p><strong>makefile</strong>:</p>
<ul>
<li>这是默认的 <code>make</code> 文件名。如果你在命令行中仅输入 <code>make</code> 而不指定任何文件，<code>make</code> 会自动查找名为 <code>makefile</code> 或 <code>Makefile</code> 的文件并执行其中的规则。</li>
</ul>
</li>
</ol>
<ul>
<li>由于这是默认文件名，所以这是最常见的命名方式。</li>
</ul>
<ol start="2">
<li><p><strong>makefile.build</strong>:</p>
<ul>
<li>这不是 <code>make</code> 的默认文件名，需要通过指定 <code>-f</code> 选项来使用。例如，<code>make -f makefile.build</code>。</li>
<li>这种命名通常用于区分不同的构建文件，比如在同一个项目中有多个构建文件时，可以通过不同的后缀来区分其用途（例如，特定的构建配置或步骤）。</li>
</ul>
</li>
<li><p><strong>.mk</strong>:</p>
<ul>
<li>这是另一种常见的命名方式，特别是在更复杂的项目或构建系统中。这种文件通常被包含在主 <code>makefile</code> 中，而不是直接由 <code>make</code> 命令执行。</li>
<li>例如，一个项目可能有一个主 <code>makefile</code> 文件，其中包含了多个 <code>.mk</code> 文件，这些文件可能包含特定的规则或变量定义：<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">include</span> config.mk</span><br><span class="line"><span class="keyword">include</span> rules.mk</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<p>总结：</p>
<ul>
<li><code>makefile</code> 是 <code>make</code> 的默认文件名，最常见。</li>
<li><code>makefile.build</code> 等带有后缀的文件需要通过 <code>make -f</code> 来指定，通常用于区分不同的构建配置或步骤。</li>
<li><code>.mk</code> 文件常用于被主 <code>makefile</code> 包含，帮助组织和管理复杂的构建系统。</li>
</ul>
<p>这些命名差异主要是基于项目的组织结构和开发者的习惯，而不是 <code>make</code> 工具本身的功能差异。</p>
<p><code>.build</code> 文件需要用 <code>make -f</code> 来指定的原因是 <code>make</code> 工具默认只识别特定名称的文件作为其构建脚本，即 <code>makefile</code> 或 <code>Makefile</code>。如果构建脚本的名称不同于这两个默认名称，<code>make</code> 工具就需要明确地告知使用哪个文件。这是通过 <code>-f</code> 选项来实现的。</p>
<p>具体来说，<code>make</code> 在执行时会自动查找当前目录下是否存在名为 <code>makefile</code> 或 <code>Makefile</code> 的文件。如果找不到这两个文件名之一，<code>make</code> 会报错说找不到构建文件。在这种情况下，或者如果你有多个构建文件且希望使用一个非默认名称的构建文件，你需要使用 <code>-f</code> 选项来指定文件名。例如：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make -f makefile.build</span><br></pre></td></tr></table></figure>

<p>这是为了提供灵活性，让开发者能够根据项目需求创建多个不同的构建文件，并通过显式指定来选择要使用的构建脚本。</p>
<p>以下是一些使用场景和原因：</p>
<ol>
<li><p><strong>多配置构建</strong>：</p>
<ul>
<li>一个项目可能有多个配置，比如调试和发布配置，每个配置可以有独立的构建文件。</li>
<li><code>make -f makefile.debug</code> 和 <code>make -f makefile.release</code> 可以分别执行不同的构建配置。</li>
</ul>
</li>
<li><p><strong>模块化构建</strong>：</p>
<ul>
<li>大型项目可能会将构建规则分割到多个文件中，每个文件专注于项目的某个部分或模块。</li>
<li>例如，可以有 <code>makefile.core</code>、<code>makefile.gui</code> 等，然后通过 <code>make -f</code> 来选择构建哪个部分。</li>
</ul>
</li>
<li><p><strong>特殊构建任务</strong>：</p>
<ul>
<li>某些构建任务可能需要特定的构建脚本，例如用于生成文档或运行测试。</li>
<li><code>make -f makefile.docs</code> 可以专门用于生成项目文档，而 <code>make -f makefile.tests</code> 用于运行测试。</li>
</ul>
</li>
</ol>
<p>通过使用 <code>-f</code> 选项指定非默认的构建文件名称，<code>make</code> 工具可以更灵活地处理各种构建场景，满足不同项目和开发流程的需求。</p>
<h3 id="makefile-if-函数"><a href="#makefile-if-函数" class="headerlink" title="makefile $(if ) 函数"></a>makefile $(if ) 函数</h3><p><code>$(if)</code> 函数是 GNU <code>make</code> 提供的一个条件函数，用于在 <code>makefile</code> 中执行简单的条件判断。它的基本语法如下：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">if</span> condition,then-part[,else-part])</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>condition</code>: 这是一个条件表达式。如果这个表达式的值不为空字符串，则被认为是真。</li>
<li><code>then-part</code>: 当 <code>condition</code> 为真时，返回 <code>then-part</code> 的值。</li>
<li><code>else-part</code>（可选）：当 <code>condition</code> 为假时，返回 <code>else-part</code> 的值。如果省略 <code>else-part</code>，则在条件为假时返回空字符串。</li>
</ul>
<ul>
<li>示例</li>
</ul>
<p>假设你有一个变量 <code>DEBUG</code>，用于控制是否进行调试构建。可以使用 <code>$(if)</code> 来决定编译选项：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">DEBUG := 1</span><br><span class="line"></span><br><span class="line">CFLAGS := <span class="variable">$(<span class="built_in">if</span> <span class="variable">$(DEBUG)</span>,-g,-O2)</span></span><br></pre></td></tr></table></figure>

<p>在这个例子中，如果 <code>DEBUG</code> 不为空（即，条件为真），<code>CFLAGS</code> 将被设置为 <code>-g</code>（启用调试信息）。否则，<code>CFLAGS</code> 将被设置为 <code>-O2</code>（优化等级 2）。</p>
<ul>
<li>更复杂的例子</li>
</ul>
<p>你可以嵌套使用 <code>$(if)</code> 函数，创建更复杂的条件逻辑：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">VAR1 := foo</span><br><span class="line">VAR2 := bar</span><br><span class="line"></span><br><span class="line">RESULT := <span class="variable">$(<span class="built_in">if</span> <span class="variable">$(VAR1)</span>,$(<span class="built_in">if</span> <span class="variable">$(VAR2)</span>,both non-empty,<span class="variable">$(VAR1)</span> non-empty)</span>,VAR1 empty)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果 VAR1 和 VAR2 都不为空，则 RESULT 为 &quot;both non-empty&quot;</span></span><br><span class="line"><span class="comment"># 如果 VAR1 不为空但 VAR2 为空，则 RESULT 为 &quot;foo non-empty&quot;</span></span><br><span class="line"><span class="comment"># 如果 VAR1 为空，则 RESULT 为 &quot;VAR1 empty&quot;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>示例：目标文件的选择</li>
</ul>
<p>假设你有两个不同版本的目标文件，你可以使用 <code>$(if)</code> 根据一个变量来选择其中一个：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">VERSION := 1</span><br><span class="line"></span><br><span class="line">OBJ_FILES := <span class="variable">$(<span class="built_in">if</span> <span class="variable">$(VERSION)</span>,version1.o,version2.o)</span></span><br><span class="line"></span><br><span class="line"><span class="section">all: <span class="variable">$(OBJ_FILES)</span></span></span><br><span class="line">	<span class="variable">$(CC)</span> -o my_program <span class="variable">$(OBJ_FILES)</span></span><br></pre></td></tr></table></figure>

<p>在这个例子中，如果 <code>VERSION</code> 不为空，则 <code>OBJ_FILES</code> 将被设置为 <code>version1.o</code>；否则，设置为 <code>version2.o</code>。</p>
<ul>
<li>使用环境变量</li>
</ul>
<p>你也可以结合环境变量来使用 <code>$(if)</code> 函数。例如：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">INSTALL_DIR := <span class="variable">$(<span class="built_in">if</span> <span class="variable">$(PREFIX)</span>,<span class="variable">$(PREFIX)</span>/usr/local,/usr/local)</span></span><br><span class="line"></span><br><span class="line"><span class="section">install:</span></span><br><span class="line">	cp my_program <span class="variable">$(INSTALL_DIR)</span>/bin</span><br></pre></td></tr></table></figure>

<p>在这个例子中，如果环境变量 <code>PREFIX</code> 被设置了，<code>INSTALL_DIR</code> 将使用 <code>PREFIX</code> 指定的目录；否则，将使用默认目录 <code>/usr/local</code>。</p>
<h4 id="wildcard-函数"><a href="#wildcard-函数" class="headerlink" title="$(wildcard) 函数"></a>$(wildcard) 函数</h4><p>在 GNU <code>make</code> 中，<code>$(wildcard)</code> 函数用于扩展模式匹配符并返回与模式匹配的文件列表。它在自动化文件查找和管理中非常有用，特别是在处理源文件或其他需要动态查找的文件时。</p>
<p>其基本语法是：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">wildcard</span> pattern)</span></span><br></pre></td></tr></table></figure>

<p>其中，<code>pattern</code> 是包含通配符（如 <code>*</code>、<code>?</code>）的模式字符串。</p>
<p>假设你在当前目录下有以下文件：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">main.c</span><br><span class="line">utils.c</span><br><span class="line">main.h</span><br><span class="line">utils.h</span><br><span class="line">readme.txt</span><br></pre></td></tr></table></figure>

<p>你可以使用 <code>$(wildcard)</code> 来找到所有 <code>.c</code> 文件：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SRC_FILES := <span class="variable">$(<span class="built_in">wildcard</span> *.c)</span></span><br></pre></td></tr></table></figure>

<p>此时，<code>SRC_FILES</code> 将包含 <code>main.c</code> 和 <code>utils.c</code>。</p>
<p>你还可以将目录名和文件模式结合在变量中使用，例如：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SRC_DIR := src</span><br><span class="line">SRC_FILES := <span class="variable">$(<span class="built_in">wildcard</span> <span class="variable">$(SRC_DIR)</span>/*.c)</span></span><br></pre></td></tr></table></figure>

<p>假设 <code>src</code> 目录下有 <code>file1.c</code> 和 <code>file2.c</code> 文件，则 <code>SRC_FILES</code> 将包含 <code>src/file1.c</code> 和 <code>src/file2.c</code>。</p>
<p>以下是一些具体的使用示例：</p>
<ol>
<li><p>自动生成对象文件列表：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">SRC_FILES := <span class="variable">$(<span class="built_in">wildcard</span> *.c)</span></span><br><span class="line">OBJ_FILES := <span class="variable">$(<span class="built_in">patsubst</span> %.c,%.o,<span class="variable">$(SRC_FILES)</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="section">all: my_program</span></span><br><span class="line"></span><br><span class="line"><span class="section">my_program: <span class="variable">$(OBJ_FILES)</span></span></span><br><span class="line">	<span class="variable">$(CC)</span> -o <span class="variable">$@</span> <span class="variable">$^</span></span><br><span class="line"></span><br><span class="line"><span class="section">%.o: %.c</span></span><br><span class="line">	<span class="variable">$(CC)</span> -c <span class="variable">$&lt;</span> -o <span class="variable">$@</span></span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>SRC_FILES</code> 自动包含当前目录下所有的 <code>.c</code> 文件，并生成对应的 <code>.o</code> 文件列表存储在 <code>OBJ_FILES</code> 变量中。</p>
</li>
<li><p>查找特定类型的文件：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HEADER_FILES := <span class="variable">$(<span class="built_in">wildcard</span> *.h)</span></span><br></pre></td></tr></table></figure>

<p><code>HEADER_FILES</code> 将包含所有 <code>.h</code> 文件。</p>
</li>
</ol>
<p>如果你的项目结构包含子目录，可以使用递归通配符来查找子目录中的文件（GNU make 4.0 及以上版本支持）：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SRC_FILES := <span class="variable">$(<span class="built_in">wildcard</span> src/**/*.c)</span></span><br></pre></td></tr></table></figure>

<p>这个命令将查找 <code>src</code> 目录及其所有子目录中的 <code>.c</code> 文件。</p>
<p>你可以结合 <code>$(wildcard)</code> 和 <code>$(foreach)</code> 实现更复杂的文件查找逻辑。例如，查找多个目录中的文件：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DIRS := src lib tests</span><br><span class="line">SRC_FILES := <span class="variable">$(<span class="built_in">foreach</span> <span class="built_in">dir</span>,<span class="variable">$(DIRS)</span>,$(<span class="built_in">wildcard</span> <span class="variable">$(dir)</span>/*.c)</span>)</span><br></pre></td></tr></table></figure>

<p>这个例子会在 <code>src</code>、<code>lib</code> 和 <code>tests</code> 目录中查找所有的 <code>.c</code> 文件，并将它们存储在 <code>SRC_FILES</code> 中。</p>
<p><code>$(wildcard)</code> 函数在 <code>makefile</code> 中是一个非常强大的工具，能够自动查找匹配特定模式的文件，使得构建过程更加灵活和自动化。通过结合使用变量、模式匹配和其他 <code>make</code> 函数，可以实现复杂的文件管理和构建规则。</p>
<h4 id="patsubst-函数"><a href="#patsubst-函数" class="headerlink" title="$(patsubst) 函数"></a>$(patsubst) 函数</h4><p><code>$(patsubst)</code> 是一个 GNU Make 函数，用于模式替换。它在一组单词中，将符合指定模式的部分替换为另一个字符串。</p>
<p>基本语法：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#          匹配规则  替换结果     替换源</span></span><br><span class="line"><span class="variable">$(<span class="built_in">patsubst</span> pattern,replacement,text)</span>  </span><br></pre></td></tr></table></figure>

<ul>
<li><code>pattern</code>：模式，使用 <code>%</code> 表示通配符。</li>
<li><code>replacement</code>：替换的字符串，同样可以包含 <code>%</code> 以表示与模式中通配符对应的部分。</li>
<li><code>text</code>：要进行模式替换的文本。</li>
</ul>
<p>示例：<br>假设有如下 Makefile 代码：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sources = foo.c bar.c baz.c</span><br><span class="line">objects = <span class="variable">$(<span class="built_in">patsubst</span> %.c,%.o,<span class="variable">$(sources)</span>)</span></span><br></pre></td></tr></table></figure>

<p>在这个例子中：</p>
<ul>
<li><code>sources</code> 定义了一组源文件列表。</li>
<li><code>$(patsubst %.c,%.o,$(sources))</code> 将 <code>sources</code> 列表中每个以 <code>.c</code> 结尾的文件替换成以 <code>.o</code> 结尾的文件。</li>
</ul>
<p>结果：</p>
<ul>
<li><code>objects</code> 将包含 <code>foo.o bar.o baz.o</code>。</li>
</ul>
<h4 id="的用法举例"><a href="#的用法举例" class="headerlink" title="$&lt; 的用法举例"></a>$&lt; 的用法举例</h4><p>在 Makefile 中，<code>$&lt;</code> 是一个自动变量，用于表示第一个依赖文件。它通常用于规则的配方（recipe）中，以便引用目标文件的第一个依赖文件。</p>
<p>下面是一个简单的例子，展示了如何使用 <code>$&lt;</code>：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 定义编译器和编译选项</span></span><br><span class="line">CC = gcc</span><br><span class="line">CFLAGS = -Wall -g</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义目标文件</span></span><br><span class="line">TARGET = myprogram</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义源文件和对象文件</span></span><br><span class="line">SRCS = main.c utils.c</span><br><span class="line">OBJS = $(SRCS:.c=.o)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 默认目标</span></span><br><span class="line"><span class="section">all: <span class="variable">$(TARGET)</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 链接目标文件</span></span><br><span class="line"><span class="variable">$(TARGET)</span>: <span class="variable">$(OBJS)</span></span><br><span class="line">    <span class="variable">$(CC)</span> <span class="variable">$(CFLAGS)</span> -o <span class="variable">$@</span> <span class="variable">$^</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 编译源文件到对象文件</span></span><br><span class="line"><span class="section">%.o: %.c</span></span><br><span class="line">    <span class="variable">$(CC)</span> <span class="variable">$(CFLAGS)</span> -c <span class="variable">$&lt;</span> -o <span class="variable">$@</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 清理生成的文件</span></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">    rm -f <span class="variable">$(OBJS)</span> <span class="variable">$(TARGET)</span></span><br></pre></td></tr></table></figure>

<p>在这个示例中，<code>%.o: %.c</code> 是一个模式规则，表示所有的 <code>.c</code> 文件都会被编译成对应的 <code>.o</code> 文件。在该规则的配方中，<code>$&lt;</code> 用于表示模式匹配的第一个依赖文件，即当前正在被编译的 <code>.c</code> 文件。</p>
<p>例如，当 <code>main.c</code> 需要被编译时，<code>$&lt;</code> 的值就是 <code>main.c</code>，对应的命令行就是：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -Wall -g -c main.c -o main.o</span><br></pre></td></tr></table></figure>

<p>同样地，当 <code>utils.c</code> 需要被编译时，<code>$&lt;</code> 的值就是 <code>utils.c</code>，对应的命令行就是：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -Wall -g -c utils.c -o utils.o</span><br></pre></td></tr></table></figure>

<p>通过使用 <code>$&lt;</code>，可以使 Makefile 更加简洁和灵活，因为它自动引用了当前的源文件，而无需手动指定。</p>
<h4 id="Makefile-什么时候会执行结束"><a href="#Makefile-什么时候会执行结束" class="headerlink" title="Makefile 什么时候会执行结束"></a>Makefile 什么时候会执行结束</h4><p>在Makefile中，行的结束由换行符（\n）或分号（;）来表示。Make会按行读取Makefile，并执行每一行中的命令，直到遇到一个新的规则或者文件结束。</p>
<p>如果一行太长而无法在一行中显示，可以使用反斜杠（\）将其分隔成多行。Make会将多行拼接在一起视为单独的一行。例如：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">target: dependency1 dependency2 \</span></span><br><span class="line">         dependency3</span><br><span class="line">    command1</span><br><span class="line">    command2</span><br></pre></td></tr></table></figure>

<p>这个规则定义了一个名为target的目标，它依赖于dependency1、dependency2和dependency3。当这个目标被执行时，会依次执行command1和command2。Make会将命令1和命令2视为同一行的一部分，直到遇到一个新的规则或文件结束。</p>
<p>因此，Make会根据换行符、分号以及反斜杠来确定命令的结束，而不是根据特定的行结束符。</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2024-06-06T15:00:09.075Z" title="2024/6/6 23:00:09">2024-06-06</time>发表</span><span class="level-item"><time dateTime="2024-06-06T15:02:14.181Z" title="2024/6/6 23:02:14">2024-06-06</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/%E7%A7%AF%E7%B4%AF/">积累</a></span><span class="level-item">1 分钟读完 (大约153个字)</span></div></div><div class="content"><h1 id="配置vscode-clangd-的开发环境："><a href="#配置vscode-clangd-的开发环境：" class="headerlink" title="配置vscode+clangd 的开发环境："></a>配置vscode+clangd 的开发环境：</h1><p>总体可以参考这个文章：</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/ludaoyi88/article/details/135051470">https://blog.csdn.net/ludaoyi88/article/details/135051470</a></p>
<p>改进点：</p>
<ul>
<li>安装的时候：不需要去下载，一般只需要执行下面两个命令</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install clangd</span><br></pre></td></tr></table></figure>

<ul>
<li>设置命令的时候：注意 这里一定是”–”。是对应clangd 命令的。</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">--compile-commands-dir=$&#123;workspaceFolder&#125;</span><br><span class="line">--background-index</span><br><span class="line">--completion-style=detailed</span><br><span class="line">--header-insertion=never</span><br><span class="line">-log=info</span><br></pre></td></tr></table></figure>



<p>总结 有下面的步骤：</p>
<ol>
<li>ubuntu 中安装bear:</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install bear</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><p>vscode 中安装<code>clanged</code>插件</p>
</li>
<li><p>WSL 中安装 clanged</p>
</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install clangd</span><br><span class="line"><span class="comment">/* sudo apt-get install clangd */</span></span><br></pre></td></tr></table></figure>



</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2024-06-06T15:00:09.063Z" title="2024/6/6 23:00:09">2024-06-06</time>发表</span><span class="level-item"><time dateTime="2024-06-06T15:01:46.666Z" title="2024/6/6 23:01:46">2024-06-06</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/%E7%A7%AF%E7%B4%AF/">积累</a></span><span class="level-item">14 分钟读完 (大约2099个字)</span></div></div><div class="content"><ol>
<li>构建ccm1002bc 项目 fpag阶段keil5  base工程<ul>
<li>通过fpga版本协助定位了两个问题：<ul>
<li>最终定位至fpga rom区域未加密的问题。</li>
<li>最终定位至sram ecc错误问题</li>
</ul>
</li>
<li>通过软件rom程序处理，解决了两个问题<ul>
<li>rom启动软件写ram区域的方式解决ram ecc错误问题</li>
<li>在rom中构建软件中断向量表，实现软件的二级跳转解决comtex m0 没有vocter中断向量表重定位寄存器的问题</li>
</ul>
</li>
<li>根据ccm1002bc的中断向量表和M0核的nvic硬件特性，重写了软件中断向量表和NVIC 处理函数。</li>
</ul>
</li>
<li>完成ccm1002bc  LinFlexD 和 CanFD 模块的FPGA case 验证<ul>
<li>阅读ccm1002bc 手册，完成LinflexD 和CanFD的传输、发送、接收、中断的fpga case 覆盖。</li>
<li>定位到两个软件使用注意事项：<ul>
<li>LinFlexD 使用rxdma 必须使能txdma 且用txdma 发送header，否则无法使用dma。</li>
<li>canfd tx buff的写入必须要32位四字节对齐写入，否则会hard fault。</li>
</ul>
</li>
</ul>
</li>
<li>完成ccm1002bc bootloader的设计及开发<ul>
<li>任务进行中：完成lin、can 底层接口。完成Lin 接收上位机数据跳转至 RAM 执行流程。</li>
</ul>
</li>
</ol>
<p>任务1：</p>
<ol>
<li>通过 FPGA case 协助定位到 FPGA ROM 区域未加密 和 SRAM ECC 错误问题。</li>
<li>采用 ROM 启动软件写 RAM 区域的方式解决了 RAM ECC 错误问题。</li>
<li>在 ROM 中构建软件中断向量表，实现了软件的二级跳转，解决了 Comtex M0 缺少 Vocter 中断向量表重定位寄存器的问题。</li>
<li>根据 ccm1002bc 的中断向量表和 M0 核的 NVIC 硬件特性，重写了软件中断向量表和 NVIC 处理函数。</li>
</ol>
<p>任务2</p>
<ol>
<li>阅读 ccm1002bc 手册，成功完成 LinFlexD 和 CanFD 的传输、发送、接收、中断的 FPGA Case 覆盖。</li>
<li>定位到软件注意事项：LinFlexD 使用 RXDMA 必须使能 TXDMA 且用 TXDMA 发送 header，否则无法使用 RXDMA 。</li>
<li>定位到软件注意事项：CanFD TX Buff 的写入必须要 32 位四字节对齐写入，否则可能导致 hard fault。</li>
</ol>
<p>任务3</p>
<p>​	任务进行中：已完成 Lin 和 Can 底层接口，成功实现 Lin 接收上位机数据跳转至 RAM 执行的流程。</p>
<h2 id="12月"><a href="#12月" class="headerlink" title="12月"></a>12月</h2><p>任务1：</p>
<ol>
<li>根据bootrom需求，完成 bootrom 的设计。在项目主管的帮助下确认bootrom方案。落实设计资料文档。</li>
<li>根据bootrom的设计方案，完成bootrom 代码开发。</li>
<li>结合bootrom功能，设计bootrom验证方案。结合验证出现的问题，完成bootrom代码迭代，实现bootrom的定版。</li>
<li>完成CCM1002bc Coremark 和  Dhrystone 测试。</li>
<li>协助同事定位FPGA版本问题和CP test 问题。</li>
</ol>
<p>任务2</p>
<ol>
<li>进行JNS3204 擦除编程Flashmain block对 info区域的实验，协助同事定位到info 区域的问题依旧是擦除编程Flash中por 造成的影响。</li>
</ol>
<p>任务3</p>
<p>​	由于新的工作安排，任务3未开展，转而协助定位CCM3310S-lE的MRAM读写问题。</p>
<p>协助定位CCM3310S-LE mram 写入问题：</p>
<p>工时：2.0天</p>
<p>完成情况：搭建CCM3310S-LE trim环境，增加trim 信号中 wait等待时间，进行mram  读写实验，发现无法写入。</p>
<p>​	</p>
<h2 id="1月"><a href="#1月" class="headerlink" title="1月"></a>1月</h2><p>CCL1100B：</p>
<ol>
<li>在dz100和dz300完成 lin 和can transceiver的功能测试包括通讯、错误处理、唤醒、rxonly&amp;loop 等功能。</li>
<li>验证CCL100B  lin 和can transceiver的数字逻辑功能，构建软件case，定位到多个数字逻辑bug，协助DE问题复现和分析。</li>
<li>根据DE的问题表格，设计软件case，在dz100和dz300上测试，回复DE实际验证结果。</li>
</ol>
<h2 id="2月"><a href="#2月" class="headerlink" title="2月"></a>2月</h2><p>CCL1100B：</p>
<ol>
<li><p>验证CCL100B  lin 和can transceiver的数字逻辑功能，构建软件case，验证通讯、错误处理、唤醒、rxonly&amp;loop 等功能。</p>
</li>
<li><p>针对can唤醒最低有效时间问题，结合应用场景，给出判断依据，完成FPGA版本的补充验证。</p>
</li>
</ol>
<p>CCR4001：</p>
<pre><code>1. 阅读CRV4H和riscv手册，设计CRV4H验证计划，完成coremark和dhrytone的跑分测试。
 2. 对riscv 软件IDE，发现了使用bug并已同步给相关同事。
</code></pre>
<p>计划：</p>
<p>CCR4001：</p>
<pre><code>1. 完成CCR4001 base 工程的搭建。3/5
 2. 完成can、otp、ahbram ip的验证。3/13
 3. 学习NPU相关知识，设计NPU软件验证计划，进行NPU的功能和数据通路的验证。3/31
</code></pre>
<p>CCM1002BC</p>
<p>​	1. 完成芯片EVB阶段的boot、can、lin的验证。3&#x2F;10</p>
<h3 id="3月"><a href="#3月" class="headerlink" title="3月"></a>3月</h3><p>CCM1002BC:</p>
<ol>
<li>完成芯片EVB阶段的bootrom、can、lin的验证。</li>
<li>协助同事定位bootrom 中断问题。</li>
</ol>
<p>CCR4001S:</p>
<ol>
<li>在核心版CRV4H上搭建base工程和中断处理框架，交付给同事进行后续CCR4001S上base 工程搭建。</li>
<li>完成CCR4001S 的dhrystone 和coremark 性能测试。</li>
<li>学习CCR4001S NPU 知识，完成letnet IDE 软仿验证，整理网络部署和NPU验证思路。</li>
<li>在CCR4001S 上成功移植FreeRtos,同时适配中断、串口、浮点处理等功能。完成芯原VIPLite 需要的系统平台的搭建。积极协助应用部门的环境平台搭建，协助推进应用层的网络部署工作。</li>
<li>FPGA环境下跑通 NPU conv1*1 算子。</li>
</ol>
<h5 id="计划"><a href="#计划" class="headerlink" title="计划"></a>计划</h5><p>CCM1002BC：</p>
<ol>
<li>完成bootrom 的修改和验证工作。</li>
</ol>
<p>CCR4001S：</p>
<ol>
<li><p>在FPGA平台上验证已有的NPU DV case验证。</p>
</li>
<li><p>在FPGA平台上，完成NPU寄存器遍历、支持算子遍历、数据通路、中断的验证。</p>
</li>
<li><p>在FPGA平台上，完成常见小网络的部署和性能测试。</p>
</li>
<li><p>完成CCR4001S can ip的验证。</p>
</li>
</ol>
<p>加班申请：</p>
<ol>
<li>在FPGA平台上验证NPU 5个卷积功能算子、2个图像滤波算子case。</li>
<li>验证NPU 在FreeRtos 的中断通路。</li>
<li>阅读芯愿新realse 的NPU driver源码和相关使用手册，排查现在Freertos 适配时的mutex 申请错误和signal 循环等待的问题。</li>
</ol>
<ul>
<li><p>1002BC：完成<strong>FPGA阶段和EVB阶段 lin can</strong> 控制器的验证、<strong>bootrom</strong>的开发及验证。基于1100B 数模混合芯片，完成lin&#x2F;can 收发器ip 数字部分的验证。</p>
</li>
<li><p>CCR4001S：完成CRV4H (riscv core)的coremark 和dhrystone性能测试、中断验证、浮点数和dsp 指令验证、完成NPU Case的验证。在CCR4001S 上成功移植Freertos，同时适配中断、串口、浮点等功能。成功适配芯愿提供的NPU Freertos 接口，且利用芯原提供的工具链，完成resnet 的部署和验证，完成pytorch 算子的导出和验证。</p>
<ul>
<li>初次在SPI FLASH 上调试，发现没有运行成功。在DDR 能够运行的文件，将代码段编译到Flash 上运行。首先确认了是否是XIP的问题，其次修改link文件，做data 数据段的重定位还是不行。追查发现，是在FPGA环境下，CPU 运行频率和 Flsah 的 CLK 频率都比较低，而Freertos的 mtime 中断频率较高，由此导致了频繁进入mtime 中断但是不能执行用户代码。修改mtime 中断时间后问题得到解决。此外，还进行风险性评估，提供elf  给DV 验证仿真，由此判断真实场景下，芯片的处理能力。此外，NPU直接搬运的过程中 NBG 文件和权重文件都有4KB 对齐的要求，通过修改link 脚本和定义section 解决此问题。也可以用__attribute__ ((aligned (0x1000))) 解决此问题。</li>
</ul>
</li>
<li><p>还有一个问题是m0 核没有中断向量表，构建了一个不定位的向量表来实现的内容。</p>
</li>
</ul>
<p>真正想做的，还是能够从系统级层面上holdon 一个产品（软件系统）能够根据具体的问题给出软件的解法。明确数字信息和指标。</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2024-06-06T14:57:29.309Z" title="2024/6/6 22:57:29">2024-06-06</time>发表</span><span class="level-item"><time dateTime="2024-06-06T15:01:26.365Z" title="2024/6/6 23:01:26">2024-06-06</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/%E7%A7%AF%E7%B4%AF/">积累</a></span><span class="level-item">3 分钟读完 (大约391个字)</span></div></div><div class="content"><h1 id="如何理解和配置mcu-的时钟？"><a href="#如何理解和配置mcu-的时钟？" class="headerlink" title="如何理解和配置mcu 的时钟？"></a>如何理解和配置mcu 的时钟？</h1><p>​		目前有项工作为芯片的bootrom工作，在bootrom中如何使能时钟是一个需要小心谨慎的问题（FPGA上不能仿真出clock）,由此梳理了一下如何配置mcu 的时钟。【ps：这确实是初学stm32的时候就接触过的问题，不过当时没有好好分析。】</p>
<h3 id="1-观察系统的时钟结构图"><a href="#1-观察系统的时钟结构图" class="headerlink" title="1. 观察系统的时钟结构图"></a>1. 观察系统的时钟结构图</h3><p>观察系统的时钟树结构，重点要看几个点：</p>
<ul>
<li>系统的时钟输入是什么？有哪些时钟源可供选择和配置？</li>
<li>是否有介绍目标模块的时钟通路？时钟通路上会经历哪些时钟源的选择和分频？</li>
</ul>
<h3 id="2-观察目标模块在体系中的位置"><a href="#2-观察目标模块在体系中的位置" class="headerlink" title="2. 观察目标模块在体系中的位置"></a>2. 观察目标模块在体系中的位置</h3><p>有很多外设时钟在时钟体系中没有明确的表示，打过挂载在apb总线上，由此需要确认目标模块在挂载在哪个总线上，需要打开哪些外设时钟。</p>
<h4 id="3-查看寄存器"><a href="#3-查看寄存器" class="headerlink" title="3.  查看寄存器"></a>3.  查看寄存器</h4><p>经过上述两步，应该知道要使能目标模块时钟的话，需要选择什么时钟源，配置哪些分频。因此需要查看mcu的寄存器的说明，来按顺序配置时钟即可。</p>
<p>引用文章【<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_29344757/article/details/73479924%E3%80%91">https://blog.csdn.net/qq_29344757/article/details/73479924】</a></p>
<p><img src="F:\wxwang\notes_for_public\notes_for_public\zhihu_publish\时钟配置.assets\image-20240425110008258.png" alt="image-20240425110008258"></p>
<p><img src="F:\wxwang\notes_for_public\notes_for_public\zhihu_publish\时钟配置.assets\image-20240425111308768.png" alt="image-20240425111308768"></p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2024-06-06T14:57:29.307Z" title="2024/6/6 22:57:29">2024-06-06</time>发表</span><span class="level-item"><time dateTime="2024-06-06T15:02:09.121Z" title="2024/6/6 23:02:09">2024-06-06</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/%E7%A7%AF%E7%B4%AF/">积累</a></span><span class="level-item">19 分钟读完 (大约2785个字)</span></div></div><div class="content"><h1 id="从0移植Freertos到riscv-core-MCU"><a href="#从0移植Freertos到riscv-core-MCU" class="headerlink" title="从0移植Freertos到riscv-core MCU"></a>从0移植Freertos到riscv-core MCU</h1><p>[toc]</p>
<h2 id="1-下载Freertos及文件准备"><a href="#1-下载Freertos及文件准备" class="headerlink" title="1. 下载Freertos及文件准备"></a>1. 下载Freertos及文件准备</h2><ul>
<li><p>下载</p>
<p>可以从官网下载Freertos 的最新版本，这是github 链接：<a target="_blank" rel="noopener" href="https://github.com/FreeRTOS/FreeRTOS/tree/V10.0.0%EF%BC%8C%E8%BF%99%E4%B8%AA%E6%98%AF10.0%E7%89%88%E6%9C%AC%E7%9A%84%E3%80%82%E6%88%91%E4%B8%8B%E8%BD%BD%E7%9A%84%E7%89%88%E6%9C%AC%E6%98%AF%60FreeRTOSv202212.01%60%E7%89%88%E6%9C%AC">https://github.com/FreeRTOS/FreeRTOS/tree/V10.0.0，这个是10.0版本的。我下载的版本是`FreeRTOSv202212.01`版本</a></p>
</li>
<li><p>目录裁剪</p>
<p>在Freertos解压之后，进入<code>./FreeRtoS</code>目录，里面有下面几个文件夹，我们需要Source文件夹中的源码。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">FreeRTOS</span><br><span class="line">    -&gt;Demo		<span class="comment">/* 不需要 */</span>	</span><br><span class="line">    -&gt;license	<span class="comment">/* 不需要 */</span></span><br><span class="line">    -&gt;Source	</span><br><span class="line">    	-&gt;一系列文件 *.*	 <span class="comment">/* 文件夹下的一系列文件 *.* 都要 */</span></span><br><span class="line">    	-&gt;include	<span class="comment">/* 全要拷贝 */</span></span><br><span class="line">    	-&gt;portable	</span><br><span class="line">    		-&gt;MemMang  <span class="comment">/*拷贝一个需要的malloc 算法就行。我留下的是heap_4.c*/</span></span><br><span class="line">    		-&gt;\GCC\RISC-V\chip_specific_extensions    			\   					 RISCV_MTIME_CLINT_no_extensions\freertos_risc_v_chip_specific_extensions.h <span class="comment">/* 要 */</span>			</span><br><span class="line">    		-&gt;\GCC\RISC-V\ 	 <span class="comment">/* 文件夹下的一系列文件 *.* 都要 */</span></span><br><span class="line">    		-&gt;CMakeList.txt  <span class="comment">/* 要拷贝 */</span></span><br><span class="line">    		-&gt;readme.txt 	 <span class="comment">/* 要拷贝 */</span></span><br><span class="line">    -&gt;test		<span class="comment">/* 不需要 */</span></span><br></pre></td></tr></table></figure>

<p>整体拷贝完之后的目录结构如下图：</p>
<p><img src="/.%5CFreertos.assets%5Cimage-20240529214721028.png" alt="image-20240529214721028"></p>
</li>
<li><p>文件添加</p>
<p>可以新建一个文件夹，添加两个文件<code>main.c</code>和<code>FreeRTOSConfig.h</code>。如果本身已经有对应的main.c的话就不需要新建了，可以保留。</p>
</li>
</ul>
<p>经过以上，我们需要的文件已经设定好了，现在添加及修改内容。</p>
<h2 id="2-修改代码以适配RISCV平台"><a href="#2-修改代码以适配RISCV平台" class="headerlink" title="2. 修改代码以适配RISCV平台"></a>2. 修改代码以适配RISCV平台</h2><h3 id="2-1-创建一个base-工程"><a href="#2-1-创建一个base-工程" class="headerlink" title="2.1 创建一个base 工程"></a>2.1 创建一个base 工程</h3><p>在你的riscv 平台上创建一个base 工程，要求是能够跑进main函数和有printf 串口输出（能跑进main 函数是必须的，printf只是为了方便debug）。这样能保证你的工程至少能初步跑起来，汇编准备的C语言运行环境、硬件环境没有问题。</p>
<h3 id="2-2-将1中的目录结构添加到base-工程中，并且在main-c-文件-和FreeRTOSConfig-h-文件中添加以下内容"><a href="#2-2-将1中的目录结构添加到base-工程中，并且在main-c-文件-和FreeRTOSConfig-h-文件中添加以下内容" class="headerlink" title="2.2 将1中的目录结构添加到base 工程中，并且在main.c 文件 和FreeRTOSConfig.h 文件中添加以下内容"></a>2.2 将1中的目录结构添加到base 工程中，并且在main.c 文件 和FreeRTOSConfig.h 文件中添加以下内容</h3><h4 id="2-2-1-main-函数中需要添加的代码"><a href="#2-2-1-main-函数中需要添加的代码" class="headerlink" title="2.2.1 main 函数中需要添加的代码"></a>2.2.1 main 函数中需要添加的代码</h4><ul>
<li>在main 函数中添加如下代码，在头文件中加入<code>&quot;FreeRTOS.h&quot;</code>和<code>&quot;task.h&quot;</code>就可以调用Freertos的API了。下方添加的内容简单介绍如下：<ul>
<li><p>覆盖了一个测试的case：创建B、C两个任务，每个任务循环10000个**tick **会进行一次调度。</p>
</li>
<li><p>定义了一些hook 函数，当对应的情况发生时，会进入这个HOOK 函数。这些HOOK函数和FreeRTOSConfig.h 中的配置项有对应关系。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/****************************************************************************************************************/</span></span><br><span class="line">	<span class="comment">/**************************************************FOR FreeRtos*************************************************/</span></span><br><span class="line">	<span class="comment">/***************************************************************************************************************/</span></span><br><span class="line">	<span class="type">static</span> TaskHandle_t xHandleTaskB = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="type">static</span> TaskHandle_t xHandleTaskC = <span class="literal">NULL</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="type">static</span> <span class="type">void</span> <span class="title function_">vTaskB</span><span class="params">(<span class="type">void</span> *pvParameters)</span></span><br><span class="line">	&#123;</span><br><span class="line">	    <span class="type">static</span> <span class="type">uint16_t</span> TaskBnum=<span class="number">0</span>;</span><br><span class="line">	    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">	    &#123;</span><br><span class="line">	        TaskBnum++;</span><br><span class="line">	        <span class="built_in">printf</span>(<span class="string">&quot;Task B : %d \r\n&quot;</span>,TaskBnum);</span><br><span class="line">	        vTaskDelay(<span class="number">10000</span>);</span><br><span class="line">	    &#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="type">static</span> <span class="type">void</span> <span class="title function_">vTaskC</span><span class="params">(<span class="type">void</span> *pvParameters)</span></span><br><span class="line">	&#123;</span><br><span class="line">	    <span class="type">static</span> <span class="type">uint16_t</span> TaskCnum=<span class="number">0</span>;</span><br><span class="line">	    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">	    &#123;</span><br><span class="line">	        TaskCnum++;</span><br><span class="line">	        <span class="built_in">printf</span>(<span class="string">&quot;Task C : %d \r\n&quot;</span>,TaskCnum);</span><br><span class="line">	        vTaskDelay(<span class="number">10000</span>);<span class="comment">//退出调度10000个ticks</span></span><br><span class="line">	    &#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="type">static</span> <span class="type">void</span> <span class="title function_">AppTaskCreate</span> <span class="params">(<span class="type">void</span>)</span></span><br><span class="line">	&#123;</span><br><span class="line">	    xTaskCreate(</span><br><span class="line">	                vTaskB,         <span class="comment">/* 任务函数 */</span></span><br><span class="line">	                <span class="string">&quot;vTaskB&quot;</span>,       <span class="comment">/* 任务名 */</span></span><br><span class="line">	                <span class="number">128</span>,            <span class="comment">/* 任务栈大小，单位 word，也就是 4 字节 */</span></span><br><span class="line">	                <span class="literal">NULL</span>,           <span class="comment">/* 任务参数 */</span></span><br><span class="line">	                <span class="number">4</span>,              <span class="comment">/* 任务优先级*/</span></span><br><span class="line">	                &amp;xHandleTaskB   <span class="comment">/* 任务句柄 */</span></span><br><span class="line">	                );</span><br><span class="line">	</span><br><span class="line">	    xTaskCreate(</span><br><span class="line">	                vTaskC,</span><br><span class="line">	                <span class="string">&quot;vTaskC&quot;</span>,</span><br><span class="line">	                <span class="number">128</span>,</span><br><span class="line">	                <span class="literal">NULL</span>,</span><br><span class="line">	                <span class="number">3</span>,</span><br><span class="line">	                &amp;xHandleTaskC</span><br><span class="line">	                );</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/* Prototypes for the standard FreeRTOS callback/hook functions implemented</span></span><br><span class="line"><span class="comment">	within this file. */</span></span><br><span class="line">	<span class="type">void</span> <span class="title function_">vApplicationMallocFailedHook</span><span class="params">( <span class="type">void</span> )</span>;</span><br><span class="line">	<span class="type">void</span> <span class="title function_">vApplicationIdleHook</span><span class="params">( <span class="type">void</span> )</span>;</span><br><span class="line">	<span class="type">void</span> <span class="title function_">vApplicationStackOverflowHook</span><span class="params">( TaskHandle_t pxTask, <span class="type">char</span> *pcTaskName )</span>;</span><br><span class="line">	<span class="type">void</span> <span class="title function_">vApplicationTickHook</span><span class="params">( <span class="type">void</span> )</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="type">static</span> <span class="type">void</span> <span class="title function_">prvSetupHardware</span><span class="params">( <span class="type">void</span> )</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">/* Ensure no interrupts execute while the scheduler is in an inconsistent</span></span><br><span class="line"><span class="comment">		state.  Interrupts are automatically enabled when the scheduler is</span></span><br><span class="line"><span class="comment">		started. */</span></span><br><span class="line">		portDISABLE_INTERRUPTS();</span><br><span class="line">	</span><br><span class="line">		<span class="comment">/* Enable UART port to output messages. */</span></span><br><span class="line">	   <span class="comment">// uart_print_config();</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/*-----------------------------------------------------------*/</span></span><br><span class="line">	</span><br><span class="line">	<span class="type">void</span> <span class="title function_">vAssertCalled</span><span class="params">( <span class="type">const</span> <span class="type">char</span> * pcFile, <span class="type">unsigned</span> <span class="type">long</span> ulLine )</span></span><br><span class="line">	&#123;</span><br><span class="line">	<span class="keyword">volatile</span> <span class="type">unsigned</span> <span class="type">long</span> ul = <span class="number">0</span>;</span><br><span class="line">	</span><br><span class="line">		( <span class="type">void</span> ) pcFile;</span><br><span class="line">		( <span class="type">void</span> ) ulLine;</span><br><span class="line">		</span><br><span class="line">		<span class="built_in">printf</span>( <span class="string">&quot;ASSERT! Line %d, file %s\r\n&quot;</span>, ( <span class="type">int</span> )ulLine, pcFile );</span><br><span class="line">		</span><br><span class="line">		taskENTER_CRITICAL();</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">/* Set ul to a non-zero value using the debugger to step out of this</span></span><br><span class="line"><span class="comment">			function. */</span></span><br><span class="line">			<span class="keyword">while</span>( ul == <span class="number">0</span> )</span><br><span class="line">			&#123;</span><br><span class="line">				portNOP();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		taskEXIT_CRITICAL();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/*-----------------------------------------------------------*/</span></span><br><span class="line">	</span><br><span class="line">	<span class="type">void</span> <span class="title function_">vApplicationMallocFailedHook</span><span class="params">( <span class="type">void</span> )</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">/* vApplicationMallocFailedHook() will only be called if</span></span><br><span class="line"><span class="comment">		configUSE_MALLOC_FAILED_HOOK is set to 1 in FreeRTOSConfig.h.  It is a hook</span></span><br><span class="line"><span class="comment">		function that will get called if a call to pvPortMalloc() fails.</span></span><br><span class="line"><span class="comment">		pvPortMalloc() is called internally by the kernel whenever a task, queue,</span></span><br><span class="line"><span class="comment">		timer or semaphore is created.  It is also called by various parts of the</span></span><br><span class="line"><span class="comment">		demo application.  If heap_1.c, heap_2.c or heap_4.c is being used, then the</span></span><br><span class="line"><span class="comment">		size of the     heap available to pvPortMalloc() is defined by</span></span><br><span class="line"><span class="comment">		configTOTAL_HEAP_SIZE in FreeRTOSConfig.h, and the xPortGetFreeHeapSize()</span></span><br><span class="line"><span class="comment">		API function can be used to query the size of free heap space that remains</span></span><br><span class="line"><span class="comment">		(although it does not provide information on how the remaining heap might be</span></span><br><span class="line"><span class="comment">		fragmented).  See http://www.freertos.org/a00111.html for more</span></span><br><span class="line"><span class="comment">		information. */</span></span><br><span class="line">		vAssertCalled( __FILE__, __LINE__ );</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/*-----------------------------------------------------------*/</span></span><br><span class="line">	</span><br><span class="line">	<span class="type">void</span> <span class="title function_">vApplicationStackOverflowHook</span><span class="params">( TaskHandle_t pxTask, <span class="type">char</span> *pcTaskName )</span></span><br><span class="line">	&#123;</span><br><span class="line">		( <span class="type">void</span> ) pcTaskName;</span><br><span class="line">		( <span class="type">void</span> ) pxTask;</span><br><span class="line">	</span><br><span class="line">		<span class="comment">/* Run time stack overflow checking is performed if</span></span><br><span class="line"><span class="comment">		configCHECK_FOR_STACK_OVERFLOW is defined to 1 or 2.  This hook</span></span><br><span class="line"><span class="comment">		function is called if a stack overflow is detected. */</span></span><br><span class="line">		vAssertCalled( __FILE__, __LINE__ );</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/*-----------------------------------------------------------*/</span></span><br><span class="line">	</span><br><span class="line">	<span class="type">void</span> <span class="title function_">vApplicationIdleHook</span><span class="params">( <span class="type">void</span> )</span></span><br><span class="line">	&#123;</span><br><span class="line">	<span class="keyword">volatile</span> <span class="type">size_t</span> xFreeHeapSpace;</span><br><span class="line">	</span><br><span class="line">		<span class="comment">/* This is just a trivial example of an idle hook.  It is called on each</span></span><br><span class="line"><span class="comment">		cycle of the idle task.  It must *NOT* attempt to block.  In this case the</span></span><br><span class="line"><span class="comment">		idle task just queries the amount of FreeRTOS heap that remains.  See the</span></span><br><span class="line"><span class="comment">		memory management section on the http://www.FreeRTOS.org web site for memory</span></span><br><span class="line"><span class="comment">		management options.  If there is a lot of heap memory free then the</span></span><br><span class="line"><span class="comment">		configTOTAL_HEAP_SIZE value in FreeRTOSConfig.h can be reduced to free up</span></span><br><span class="line"><span class="comment">		RAM. */</span></span><br><span class="line">		xFreeHeapSpace = xPortGetFreeHeapSize();</span><br><span class="line">		</span><br><span class="line">		<span class="comment">/* Remove compiler warning about xFreeHeapSpace being set but never used. */</span></span><br><span class="line">		( <span class="type">void</span> ) xFreeHeapSpace;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/*-----------------------------------------------------------*/</span></span><br><span class="line">	</span><br><span class="line">	<span class="type">void</span> <span class="title function_">vApplicationTickHook</span><span class="params">( <span class="type">void</span> )</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="meta">#<span class="keyword">if</span>( mainSELECTED_APPLICATION == 1 )</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">/* Only the comprehensive demo actually uses the tick hook. */</span></span><br><span class="line">			<span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">vFullDemoTickHook</span><span class="params">( <span class="type">void</span> )</span>;</span><br><span class="line">			vFullDemoTickHook();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/*-----------------------------------------------------------*/</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">/* configUSE_STATIC_ALLOCATION is set to 1, so the application must provide an</span></span><br><span class="line"><span class="comment">	implementation of vApplicationGetIdleTaskMemory() to provide the memory that is</span></span><br><span class="line"><span class="comment">	used by the Idle task. */</span></span><br><span class="line">	<span class="type">void</span> <span class="title function_">vApplicationGetIdleTaskMemory</span><span class="params">( StaticTask_t **ppxIdleTaskTCBBuffer, StackType_t **ppxIdleTaskStackBuffer, <span class="type">uint32_t</span> *pulIdleTaskStackSize )</span></span><br><span class="line">	&#123;</span><br><span class="line">	<span class="comment">/* If the buffers to be provided to the Idle task are declared inside this</span></span><br><span class="line"><span class="comment">	function then they must be declared static - otherwise they will be allocated on</span></span><br><span class="line"><span class="comment">	the stack and so not exists after this function exits. */</span></span><br><span class="line">	<span class="type">static</span> StaticTask_t xIdleTaskTCB;</span><br><span class="line">	<span class="type">static</span> StackType_t uxIdleTaskStack[ configMINIMAL_STACK_SIZE ];</span><br><span class="line">	</span><br><span class="line">		<span class="comment">/* Pass out a pointer to the StaticTask_t structure in which the Idle task&#x27;s</span></span><br><span class="line"><span class="comment">		state will be stored. */</span></span><br><span class="line">		*ppxIdleTaskTCBBuffer = &amp;xIdleTaskTCB;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">/* Pass out the array that will be used as the Idle task&#x27;s stack. */</span></span><br><span class="line">		*ppxIdleTaskStackBuffer = uxIdleTaskStack;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">/* Pass out the size of the array pointed to by *ppxIdleTaskStackBuffer.</span></span><br><span class="line"><span class="comment">		Note that, as the array is necessarily of type StackType_t,</span></span><br><span class="line"><span class="comment">		configMINIMAL_STACK_SIZE is specified in words, not bytes. */</span></span><br><span class="line">		*pulIdleTaskStackSize = configMINIMAL_STACK_SIZE;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/*-----------------------------------------------------------*/</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">/* configUSE_STATIC_ALLOCATION and configUSE_TIMERS are both set to 1, so the</span></span><br><span class="line"><span class="comment">	application must provide an implementation of vApplicationGetTimerTaskMemory()</span></span><br><span class="line"><span class="comment">	to provide the memory that is used by the Timer service task. */</span></span><br><span class="line">	<span class="type">void</span> <span class="title function_">vApplicationGetTimerTaskMemory</span><span class="params">( StaticTask_t **ppxTimerTaskTCBBuffer, StackType_t **ppxTimerTaskStackBuffer, <span class="type">uint32_t</span> *pulTimerTaskStackSize )</span></span><br><span class="line">	&#123;</span><br><span class="line">	<span class="comment">/* If the buffers to be provided to the Timer task are declared inside this</span></span><br><span class="line"><span class="comment">	function then they must be declared static - otherwise they will be allocated on</span></span><br><span class="line"><span class="comment">	the stack and so not exists after this function exits. */</span></span><br><span class="line">	<span class="type">static</span> StaticTask_t xTimerTaskTCB;</span><br><span class="line">	<span class="type">static</span> StackType_t uxTimerTaskStack[ configTIMER_TASK_STACK_DEPTH ];</span><br><span class="line">	</span><br><span class="line">		<span class="comment">/* Pass out a pointer to the StaticTask_t structure in which the Timer</span></span><br><span class="line"><span class="comment">		task&#x27;s state will be stored. */</span></span><br><span class="line">		*ppxTimerTaskTCBBuffer = &amp;xTimerTaskTCB;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">/* Pass out the array that will be used as the Timer task&#x27;s stack. */</span></span><br><span class="line">		*ppxTimerTaskStackBuffer = uxTimerTaskStack;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">/* Pass out the size of the array pointed to by *ppxTimerTaskStackBuffer.</span></span><br><span class="line"><span class="comment">		Note that, as the array is necessarily of type StackType_t,</span></span><br><span class="line"><span class="comment">		configMINIMAL_STACK_SIZE is specified in words, not bytes. */</span></span><br><span class="line">		*pulTimerTaskStackSize = configTIMER_TASK_STACK_DEPTH;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/*-----------------------------------------------------------*/</span></span><br><span class="line">	</span><br><span class="line">	<span class="type">void</span> <span class="title function_">vPreSleepProcessing</span><span class="params">( <span class="type">unsigned</span> <span class="type">long</span> uxModifiableIdleTime )</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">/* Called by the kernel before it places the MCU into a sleep mode because</span></span><br><span class="line"><span class="comment">		configPRE_SLEEP_PROCESSING() is #defined to vPreSleepProcessing().</span></span><br><span class="line"><span class="comment">	</span></span><br><span class="line"><span class="comment">		<span class="doctag">NOTE:</span>  Additional actions can be taken here to get the power consumption</span></span><br><span class="line"><span class="comment">		even lower.  For example, peripherals can be turned	off here, and then back</span></span><br><span class="line"><span class="comment">		on again in the post sleep processing function.  For maximum power saving</span></span><br><span class="line"><span class="comment">		ensure all unused pins are in their lowest power state. */</span></span><br><span class="line">		</span><br><span class="line">		<span class="comment">/* Avoid compiler warnings about the unused parameter. */</span></span><br><span class="line">		( <span class="type">void</span> ) uxModifiableIdleTime;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/*-----------------------------------------------------------*/</span></span><br><span class="line">	</span><br><span class="line">	<span class="type">void</span> <span class="title function_">vPostSleepProcessing</span><span class="params">( <span class="type">unsigned</span> <span class="type">long</span> uxModifiableIdleTime )</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">/* Called by the kernel when the MCU exits a sleep mode because</span></span><br><span class="line"><span class="comment">		configPOST_SLEEP_PROCESSING is #defined to vPostSleepProcessing(). */</span></span><br><span class="line">	</span><br><span class="line">		<span class="comment">/* Avoid compiler warnings about the unused parameter. */</span></span><br><span class="line">		( <span class="type">void</span> ) uxModifiableIdleTime;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h4 id="2-2-2-FreeRTOSConfig-h文件"><a href="#2-2-2-FreeRTOSConfig-h文件" class="headerlink" title="2.2.2 FreeRTOSConfig.h文件"></a>2.2.2 FreeRTOSConfig.h文件</h4><ul>
<li><p>需要添加一个FreeRTOSConfig.h 文件，Freertos编译依赖于它，可以根据SOC&#x2F;MCU 情况更改FreeRTOSConfig.h这个文件。例如下面几点：</p>
<ul>
<li>中断服务程序（ISR）堆栈大小：configISR_STACK_SIZE_WORDS</li>
<li>mtime地址：<code>#define configMTIME_BASE_ADDRESS</code></li>
<li>mcmp 地址：<code>#define configMTIMECMP_BASE_ADDRESS</code></li>
<li>CPU 时钟频率：<code>#define configCPU_CLOCK_HZ </code></li>
<li>systick 节拍：<code>#define configTICK_RATE_HZ</code></li>
<li>堆栈大小：<code>#define configTOTAL_HEAP_SIZE</code></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * FreeRTOS V202212.01</span></span><br><span class="line"><span class="comment"> * Copyright (C) 2020 Amazon.com, Inc. or its affiliates.  All Rights Reserved.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Permission is hereby granted, free of charge, to any person obtaining a copy of</span></span><br><span class="line"><span class="comment"> * this software and associated documentation files (the &quot;Software&quot;), to deal in</span></span><br><span class="line"><span class="comment"> * the Software without restriction, including without limitation the rights to</span></span><br><span class="line"><span class="comment"> * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of</span></span><br><span class="line"><span class="comment"> * the Software, and to permit persons to whom the Software is furnished to do so,</span></span><br><span class="line"><span class="comment"> * subject to the following conditions:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The above copyright notice and this permission notice shall be included in all</span></span><br><span class="line"><span class="comment"> * copies or substantial portions of the Software.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR</span></span><br><span class="line"><span class="comment"> * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS</span></span><br><span class="line"><span class="comment"> * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR</span></span><br><span class="line"><span class="comment"> * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER</span></span><br><span class="line"><span class="comment"> * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN</span></span><br><span class="line"><span class="comment"> * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * https://www.FreeRTOS.org</span></span><br><span class="line"><span class="comment"> * https://github.com/FreeRTOS</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> FREERTOS_CONFIG_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FREERTOS_CONFIG_H</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*-----------------------------------------------------------</span></span><br><span class="line"><span class="comment"> * Application specific definitions.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * These definitions should be adjusted for your particular hardware and</span></span><br><span class="line"><span class="comment"> * application requirements.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * THESE PARAMETERS ARE DESCRIBED WITHIN THE &#x27;CONFIGURATION&#x27; SECTION OF THE</span></span><br><span class="line"><span class="comment"> * FreeRTOS API DOCUMENTATION AVAILABLE ON THE FreeRTOS.org WEB SITE.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * See http://www.freertos.org/a00110.html.</span></span><br><span class="line"><span class="comment"> *----------------------------------------------------------*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> configISR_STACK_SIZE_WORDS          ( 1000 )     <span class="comment">// +</span></span></span><br><span class="line"><span class="comment">//#define CLINT_CTRL_ADDR                     ( 0x40049000UL )</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> configMTIME_BASE_ADDRESS            ( 0x40049000UL + 0xC0UL )</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> configMTIMECMP_BASE_ADDRESS         ( 0x40049000UL + 0x40UL )</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> configUSE_PREEMPTION                1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> configCPU_CLOCK_HZ                  ( ( uint32_t ) ( 16*1000*1000 ) )</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> configTICK_RATE_HZ                  ( ( TickType_t ) 1000 )				<span class="comment">/* irq time = 1s /configTICK_RATE_HZ */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> configMAX_PRIORITIES                ( 7 )</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> configMINIMAL_STACK_SIZE            ( ( uint32_t ) 2048 ) <span class="comment">// 最小任务堆栈大小</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> configTOTAL_HEAP_SIZE               ( ( size_t ) ( 50 * 1024 ) )<span class="comment">// 堆内存总大小（字节）</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> configMAX_TASK_NAME_LEN             ( 16 )</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> configUSE_TRACE_FACILITY            0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> configUSE_16_BIT_TICKS              0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> configIDLE_SHOULD_YIELD             0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> configUSE_MUTEXES                   1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> configQUEUE_REGISTRY_SIZE           8</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> configCHECK_FOR_STACK_OVERFLOW      2</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> configUSE_RECURSIVE_MUTEXES         1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> configUSE_APPLICATION_TASK_TAG      0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> configUSE_COUNTING_SEMAPHORES       1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> configGENERATE_RUN_TIME_STATS       0</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> configUSE_IDLE_HOOK                 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> configUSE_TICK_HOOK                 0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> configUSE_MALLOC_FAILED_HOOK        1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Software timer definitions. */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> configUSE_TIMERS                    1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> configTIMER_TASK_PRIORITY           ( configMAX_PRIORITIES - 1 )</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> configTIMER_QUEUE_LENGTH            4   <span class="comment">// +</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> configTIMER_TASK_STACK_DEPTH        ( configMINIMAL_STACK_SIZE )</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Task priorities.  Allow these to be overridden. */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> uartPRIMARY_PRIORITY</span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> uartPRIMARY_PRIORITY            ( configMAX_PRIORITIES - 3 )</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Set the following definitions to 1 to include the API function, or zero</span></span><br><span class="line"><span class="comment"> * to exclude the API function. */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INCLUDE_vTaskPrioritySet            1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INCLUDE_uxTaskPriorityGet           1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INCLUDE_vTaskDelete                 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INCLUDE_vTaskCleanUpResources       1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INCLUDE_vTaskSuspend                1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INCLUDE_vTaskDelayUntil             1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INCLUDE_vTaskDelay                  1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INCLUDE_eTaskGetState               1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INCLUDE_xTimerPendFunctionCall      0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INCLUDE_xTaskAbortDelay             1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INCLUDE_xTaskGetHandle              1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INCLUDE_xSemaphoreGetMutexHolder    1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Normal assert() semantics without relying on the provision of an assert.h</span></span><br><span class="line"><span class="comment"> * header file. */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> configASSERT( x )                   <span class="keyword">if</span>( ( x ) == 0 ) &#123; taskDISABLE_INTERRUPTS(); __asm volatile( <span class="string">&quot;ebreak&quot;</span> ); for( ;; ); &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Map to the platform write function. */</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">vSendString</span><span class="params">( <span class="type">const</span> <span class="type">char</span> * <span class="type">const</span> pcString )</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> configPRINT_STRING( pcString )      vSendString( pcString )</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* FREERTOS_CONFIG_H */</span></span></span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="2-2-3-修改freertos-risc-v-chip-specific-extensions-h-文件"><a href="#2-2-3-修改freertos-risc-v-chip-specific-extensions-h-文件" class="headerlink" title="2.2.3 修改freertos_risc_v_chip_specific_extensions.h 文件"></a>2.2.3 修改freertos_risc_v_chip_specific_extensions.h 文件</h4><p>由于我的mcu 是利用mtime 来做 sistick 的，所以我需要修改<code>freertos_risc_v_chip_specific_extensions.h</code>中的宏定义，建议使用这种情况不然会需要修改Freertos 的中断处理汇编源码。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> portasmHAS_MTIME                1</span></span><br></pre></td></tr></table></figure>



<h4 id="2-2-4-修改中断向量表入口地址"><a href="#2-2-4-修改中断向量表入口地址" class="headerlink" title="2.2.4 修改中断向量表入口地址"></a>2.2.4 修改中断向量表入口地址</h4><p>由于riscv 的中断向量表的地址存放在<code>mtevc</code>寄存器中，所以我们需要把中断向量表的入口地址赋值给<code>mtevc</code>。在你的<code>startup.s</code>中加入下面代码即可。其中<code>freertos_risc_v_trap_handler</code>定义在<code>Freertos\portable\GCC\RISC-V\portASM.S</code>文件下。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">;#************* prepare the entry of interrupt *****</span><br><span class="line">    la t0, freertos_risc_v_trap_handler</span><br><span class="line">    csrw mtvec, t0</span><br></pre></td></tr></table></figure>

<h4 id="2-2-5-重新定义你自己的外部中断处理函数"><a href="#2-2-5-重新定义你自己的外部中断处理函数" class="headerlink" title="2.2.5 重新定义你自己的外部中断处理函数"></a>2.2.5 重新定义你自己的外部中断处理函数</h4><p>由于mtime 中断是Core 内部的中断，所以使用起来不会经过不同的中断处理器，例如clint&#x2F;MPIC 等，但是不同的MCU可能用的外部中断控制器不同，这里Freertos留了一个接口给我们，让我们能够根据需要重新定义自己的外部中断处理函数，同样是在<code>portASM.S</code>文件中，如下，如果进入中断的话，不是mtime 中断就会调用<code>freertos_risc_v_application_interrupt_handler</code>，然后再产生一次调度。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">handle_interrupt:</span><br><span class="line">#if( portasmHAS_MTIME != 0 )</span><br><span class="line"></span><br><span class="line">    test_if_mtimer:                     /* If there is a CLINT then the mtimer is used to generate the tick interrupt. */</span><br><span class="line">        addi t0, x0, 1</span><br><span class="line">        slli t0, t0, __riscv_xlen - 1   /* LSB is already set, shift into MSB.  Shift 31 on 32-bit or 63 on 64-bit cores. */</span><br><span class="line">        addi t1, t0, 7                  /* 0x8000[]0007 == machine timer interrupt. */</span><br><span class="line">        bne a0, t1, application_interrupt_handler</span><br><span class="line"></span><br><span class="line">        portUPDATE_MTIMER_COMPARE_REGISTER</span><br><span class="line">        call xTaskIncrementTick</span><br><span class="line">        beqz a0, processed_source       /* Don&#x27;t switch context if incrementing tick didn&#x27;t unblock a task. */</span><br><span class="line">        call vTaskSwitchContext</span><br><span class="line">        j processed_source</span><br><span class="line"></span><br><span class="line">#endif /* portasmHAS_MTIME */</span><br><span class="line"></span><br><span class="line">application_interrupt_handler:</span><br><span class="line">    call freertos_risc_v_application_interrupt_handler</span><br><span class="line">    j processed_source</span><br></pre></td></tr></table></figure>

<p>我们可以根据自己的中断控制器，实现<code>freertos_risc_v_application_interrupt_handler</code>如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> __attribute__((aligned(<span class="number">4</span>))) freertos_risc_v_application_interrupt_handler(<span class="type">void</span>) &#123;</span><br><span class="line"><span class="comment">/* 读取外部中断号 */</span></span><br><span class="line"><span class="comment">/* 进入外部handler 函数*/</span></span><br><span class="line"><span class="comment">/* 清除标志位 退出中断 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="3-完成移植，来个测试demo"><a href="#3-完成移植，来个测试demo" class="headerlink" title="3. 完成移植，来个测试demo"></a>3. 完成移植，来个测试demo</h3><p>还记得main 中赋值的创建的两个task任务的测试case 吗，我们可以利用其进行测试。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;FreeRTOS.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;task.h&quot;</span></span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">AppTaskCreate</span> <span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">	<span class="type">int</span> mstatus_val = <span class="number">0</span>,mie_val = <span class="number">0x888</span>;</span><br><span class="line">    uart_init();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;for Freertos ! \r\n&quot;</span>);</span><br><span class="line">	portDISABLE_INTERRUPTS();</span><br><span class="line">	AppTaskCreate();</span><br><span class="line">	vTaskStartScheduler();</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">    	__asm(<span class="string">&quot;nop&quot;</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>预期结果log如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> Freertos ! </span><br><span class="line">Task B : <span class="number">1</span> </span><br><span class="line">Task C : <span class="number">1</span> </span><br><span class="line">Task B : <span class="number">2</span> </span><br><span class="line">Task C : <span class="number">2</span> </span><br><span class="line">Task B : <span class="number">3</span> </span><br><span class="line">Task C : <span class="number">3</span> </span><br><span class="line"> ......</span><br></pre></td></tr></table></figure>





</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2024-06-06T14:57:29.306Z" title="2024/6/6 22:57:29">2024-06-06</time>发表</span><span class="level-item"><time dateTime="2024-06-06T15:02:03.665Z" title="2024/6/6 23:02:03">2024-06-06</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/%E7%A7%AF%E7%B4%AF/">积累</a></span><span class="level-item">9 分钟读完 (大约1421个字)</span></div></div><div class="content"><h1 id="移植coremark-dhrystone要点"><a href="#移植coremark-dhrystone要点" class="headerlink" title="移植coremark &amp; dhrystone要点"></a>移植coremark &amp; dhrystone要点</h1><p>[toc]</p>
<h2 id="1-coremark"><a href="#1-coremark" class="headerlink" title="1. coremark"></a>1. coremark</h2><h3 id="1-1-coremark-计算方法"><a href="#1-1-coremark-计算方法" class="headerlink" title="1.1 coremark 计算方法"></a>1.1 coremark 计算方法</h3><p>​	计算的核心为下方的代码</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">    start_time();</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> (MULTITHREAD &gt; 1)</span></span><br><span class="line"><span class="comment">/* 多线程的情况 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="comment">/*单线程情况*/</span></span><br><span class="line">    iterate(&amp;results[<span class="number">0</span>]);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    stop_time();</span><br></pre></td></tr></table></figure>

<p>​	对于 iterate(&amp;results[0]); 再追进去可以发现</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> * <span class="title function_">iterate</span><span class="params">(voisd *pres)</span></span><br><span class="line">&#123;</span><br><span class="line">    ee_u32        i;</span><br><span class="line">    ee_u16        crc;</span><br><span class="line">    core_results *res        = (core_results *)pres;</span><br><span class="line">    ee_u32        iterations = res-&gt;iterations;</span><br><span class="line">    res-&gt;crc                 = <span class="number">0</span>;</span><br><span class="line">    res-&gt;crclist             = <span class="number">0</span>;</span><br><span class="line">    res-&gt;crcmatrix           = <span class="number">0</span>;</span><br><span class="line">    res-&gt;crcstate            = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; iterations; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        crc      = core_bench_list(res, <span class="number">1</span>);</span><br><span class="line">        res-&gt;crc = crcu16(crc, res-&gt;crc);</span><br><span class="line">        crc      = core_bench_list(res, <span class="number">-1</span>);</span><br><span class="line">        res-&gt;crc = crcu16(crc, res-&gt;crc);</span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">0</span>)</span><br><span class="line">            res-&gt;crclist = res-&gt;crc;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	而这里的iterations 会在<code>results[0].iterations = get_seed_32(4);</code>函数中被赋值为<code>ITERATIONS</code>,所以我们可以知道，其实coremark 就是获取了下面这些参数</p>
<ul>
<li>start_time();</li>
<li>stop_time();</li>
<li>iterations</li>
</ul>
<p>​	然后通过下面的代码算出 <code>循环次数÷时间</code> 的结果，可以看下面的代码，用<code>default_num_contexts * results[0].iterations / time_in_secs(total_time)</code>计算出了目标值。</p>
<p>​	但是实际我们看的分数是<code>Iterations/Sec /MHZ</code>，即最后需要的结果是<code>跑分/(你的时钟/1MHZ)</code>,例如我最后跑分是14，频率是5MHZ，那么我的实际结果是：14&#x2F;(5&#x2F;1) &#x3D; 2.8 coremark&#x2F;Mhz</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">/* and report results */</span></span><br><span class="line">    ee_printf(<span class="string">&quot;CoreMark Size    : %lu\n&quot;</span>, (<span class="type">long</span> <span class="type">unsigned</span>)results[<span class="number">0</span>].size);</span><br><span class="line">    ee_printf(<span class="string">&quot;Total ticks      : %lu\n&quot;</span>, (<span class="type">long</span> <span class="type">unsigned</span>)total_time);</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> HAS_FLOAT</span></span><br><span class="line">	<span class="comment">/* 有浮点的情况 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    ee_printf(<span class="string">&quot;Total time (secs): %d\n&quot;</span>, time_in_secs(total_time));</span><br><span class="line">    <span class="keyword">if</span> (time_in_secs(total_time) &gt; <span class="number">0</span>)</span><br><span class="line">        ee_printf(<span class="string">&quot;Iterations/Sec   : %d\n&quot;</span>,</span><br><span class="line">                  default_num_contexts * results[<span class="number">0</span>].iterations</span><br><span class="line">                      / time_in_secs(total_time));</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="keyword">if</span> (time_in_secs(total_time) &lt; <span class="number">10</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ee_printf(</span><br><span class="line">            <span class="string">&quot;ERROR! Must execute for at least 10 secs for a valid result!\n&quot;</span>);</span><br><span class="line">        total_errors++;</span><br><span class="line">    &#125;</span><br><span class="line">    ee_printf(<span class="string">&quot;Iterations       : %lu\n&quot;</span>,</span><br><span class="line">              (<span class="type">long</span> <span class="type">unsigned</span>)default_num_contexts * results[<span class="number">0</span>].iterations);</span><br><span class="line">    ee_printf(<span class="string">&quot;Compiler version : %s\n&quot;</span>, COMPILER_VERSION);</span><br><span class="line">    ee_printf(<span class="string">&quot;Compiler flags   : %s\n&quot;</span>, COMPILER_FLAGS);</span><br></pre></td></tr></table></figure>



<h3 id="1-2-coremark-移植方法"><a href="#1-2-coremark-移植方法" class="headerlink" title="1.2 coremark 移植方法"></a>1.2 coremark 移植方法</h3><p>由1.1 我们就可以知道，其实coremark 就是跑个程序n 循环，然后计算一个 指令&#x2F;时间&#x2F;频率  这样的结果，所以我们移植只需要给出以下几个参数</p>
<ul>
<li><p>时间获取方式，start_time() 和 stop_time()向里追，最后会有时间函数的实现，这里一般获取的都是cnt 数，需要结合时钟的频率才能具体计算出了时间，即这里忽略了周期。</p>
</li>
<li><p>CLOCKS_PER_SEC 这个宏定义改为你的时钟频率，第一点的获取了这段时间内增加的cnt值，这里有了时间周期，那么<code>time_in_secs(total_time)</code>这个函数就能够计算出执行当前的时间了。其实最后也是<code>cnt 值/频率=时间</code></p>
</li>
<li><p>iterations ，结合时钟频率不同，需要保证coremark 跑10s 以上，即<code>time_in_secs(total_time)</code>计算出来的结果是10s 以上，按照实际的结果给一个值就可以了。</p>
</li>
<li><p>printf 的实现，需要根据实际情况注意是不是要加printf这个宏</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//如果编译的时候加上了  -DHAS_PRINTF,那么这里就不会生效，但是还是代表了HAS_PRINTF</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> HAS_PRINTF</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HAS_PRINTF 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//由于coremark 都是使用的ee_printf，所以需要把ee_printf符号替换为printf</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> HAS_PRINTF</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ee_printf printf</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>以上就是移植的要点，需要哪些文件内容官网readme 有说，就不赘述了。</p>
</li>
</ul>
<h2 id="2-dhrystone"><a href="#2-dhrystone" class="headerlink" title="2. dhrystone"></a>2. dhrystone</h2><h3 id="2-1-dhrystone-计算方式"><a href="#2-1-dhrystone-计算方式" class="headerlink" title="2.1 dhrystone 计算方式"></a>2.1 dhrystone 计算方式</h3><p>​	和coremark 类似，dhrystone的主函数也是进行算 跑dhrystone 程序的时间，以推出来单位时间下跑dhrystone 的个数，再除以MHZ的话就可以推出来 再1MHZ的情况下，1秒能跑多少dhrystone 程序。</p>
<p>​	主题程序如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">/***************/</span></span><br><span class="line">  <span class="comment">/* Start timer */</span></span><br><span class="line">  <span class="comment">/***************/</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> TIMES</span></span><br><span class="line">  times (&amp;time_info);</span><br><span class="line">  Begin_Time = (<span class="type">long</span>) time_info.tms_utime;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> TIME</span></span><br><span class="line">  Begin_Time = time ( (<span class="type">long</span> *) <span class="number">0</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> MSC_CLOCK</span></span><br><span class="line">  Begin_Time = clock();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">  <span class="keyword">for</span> (Run_Index = <span class="number">1</span>; Run_Index &lt;= Number_Of_Runs; ++Run_Index)</span><br><span class="line">  &#123;</span><br><span class="line"></span><br><span class="line">    Proc_5();</span><br><span class="line">    Proc_4();</span><br><span class="line">      <span class="comment">/* Ch_1_Glob == &#x27;A&#x27;, Ch_2_Glob == &#x27;B&#x27;, Bool_Glob == true */</span></span><br><span class="line">    Int_1_Loc = <span class="number">2</span>;</span><br><span class="line">    Int_2_Loc = <span class="number">3</span>;</span><br><span class="line">    <span class="built_in">strcpy</span> (Str_2_Loc, <span class="string">&quot;DHRYSTONE PROGRAM, 2&#x27;ND STRING&quot;</span>);</span><br><span class="line">    Enum_Loc = Ident_2;</span><br><span class="line">    Bool_Glob = ! Func_2 (Str_1_Loc, Str_2_Loc);</span><br><span class="line">      <span class="comment">/* Bool_Glob == 1 */</span></span><br><span class="line">    <span class="keyword">while</span> (Int_1_Loc &lt; Int_2_Loc)  <span class="comment">/* loop body executed once */</span></span><br><span class="line">    &#123;</span><br><span class="line">      Int_3_Loc = <span class="number">5</span> * Int_1_Loc - Int_2_Loc;</span><br><span class="line">        <span class="comment">/* Int_3_Loc == 7 */</span></span><br><span class="line">      Proc_7 (Int_1_Loc, Int_2_Loc, &amp;Int_3_Loc);</span><br><span class="line">        <span class="comment">/* Int_3_Loc == 7 */</span></span><br><span class="line">      Int_1_Loc += <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="comment">/* while */</span></span><br><span class="line">      <span class="comment">/* Int_1_Loc == 3, Int_2_Loc == 3, Int_3_Loc == 7 */</span></span><br><span class="line">    Proc_8 (Arr_1_Glob, Arr_2_Glob, Int_1_Loc, Int_3_Loc);</span><br><span class="line">      <span class="comment">/* Int_Glob == 5 */</span></span><br><span class="line">    Proc_1 (Ptr_Glob);</span><br><span class="line">    <span class="keyword">for</span> (Ch_Index = <span class="string">&#x27;A&#x27;</span>; Ch_Index &lt;= Ch_2_Glob; ++Ch_Index)</span><br><span class="line">                             <span class="comment">/* loop body executed twice */</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> (Enum_Loc == Func_1 (Ch_Index, <span class="string">&#x27;C&#x27;</span>))</span><br><span class="line">          <span class="comment">/* then, not executed */</span></span><br><span class="line">        &#123;</span><br><span class="line">        Proc_6 (Ident_1, &amp;Enum_Loc);</span><br><span class="line">        <span class="built_in">strcpy</span> (Str_2_Loc, <span class="string">&quot;DHRYSTONE PROGRAM, 3&#x27;RD STRING&quot;</span>);</span><br><span class="line">        Int_2_Loc = Run_Index;</span><br><span class="line">        Int_Glob = Run_Index;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">      <span class="comment">/* Int_1_Loc == 3, Int_2_Loc == 3, Int_3_Loc == 7 */</span></span><br><span class="line">    Int_2_Loc = Int_2_Loc * Int_1_Loc;</span><br><span class="line">    Int_1_Loc = Int_2_Loc / Int_3_Loc;</span><br><span class="line">    Int_2_Loc = <span class="number">7</span> * (Int_2_Loc - Int_3_Loc) - Int_1_Loc;</span><br><span class="line">      <span class="comment">/* Int_1_Loc == 1, Int_2_Loc == 13, Int_3_Loc == 7 */</span></span><br><span class="line">    Proc_2 (&amp;Int_1_Loc);</span><br><span class="line">      <span class="comment">/* Int_1_Loc == 5 */</span></span><br><span class="line"></span><br><span class="line">  &#125; <span class="comment">/* loop &quot;for Run_Index&quot; */</span></span><br><span class="line">  <span class="comment">/**************/</span></span><br><span class="line">  <span class="comment">/* Stop timer */</span></span><br><span class="line">  <span class="comment">/**************/</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> TIMES</span></span><br><span class="line">  times (&amp;time_info);</span><br><span class="line">  End_Time = (<span class="type">long</span>) time_info.tms_utime;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> TIME</span></span><br><span class="line">  End_Time = time ( (<span class="type">long</span> *) <span class="number">0</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> MSC_CLOCK</span></span><br><span class="line">  End_Time = clock();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>​	以上就可以通过<code>Begin_Time</code>和<code>End_Time</code>获取运行程序的时间，在有以下的计算程序：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">User_Time = End_Time - Begin_Time;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> TIME</span></span><br><span class="line">	<span class="comment">/*User_Time 已经是具体时间计数了*/</span></span><br><span class="line">    Microseconds = (<span class="type">float</span>) User_Time * Mic_secs_Per_Second </span><br><span class="line">                        / (<span class="type">float</span>) Number_Of_Runs;</span><br><span class="line">    Dhrystones_Per_Second = (<span class="type">float</span>) Number_Of_Runs / (<span class="type">float</span>) User_Time;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">	<span class="comment">/*User_Time 是counter值*/</span></span><br><span class="line">    Microseconds = (<span class="type">float</span>) User_Time * Mic_secs_Per_Second </span><br><span class="line">                        / ((<span class="type">float</span>) HZ * ((<span class="type">float</span>) Number_Of_Runs));</span><br><span class="line">    Dhrystones_Per_Second = ((<span class="type">float</span>) HZ * (<span class="type">float</span>) Number_Of_Runs)</span><br><span class="line">                        / (<span class="type">float</span>) User_Time;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>​	以user_time 是counter值为例：<code>Dhrystones_Per_Second =Number_Of_Runs ÷ 时间 = Number_Of_Runs÷ (counter/频率) </code>，于是就有了上面的公式。</p>
<p>​	对于一般的DMIP_MHZ，上面的结果还需要再除以一个频率，因为是xMhz 跑的，不是1Mhz 跑的。即</p>
<p>​	<code>DMIP_MHZ = Dhrystones_Per_Second ÷（频率/1Mhz）</code>例如  Dhrystones_Per_Second  为12，主频为5Mhz,那么结果就为12&#x2F;5 &#x3D; 2.4.</p>
<p>100000&#x2F;(119900320&#x2F;5000000)&#x2F;5 &#x3D; </p>
<h3 id="2-2-dhrystone-移植要点"><a href="#2-2-dhrystone-移植要点" class="headerlink" title="2.2 dhrystone 移植要点"></a>2.2 dhrystone 移植要点</h3><p>​	理解了第一点，这里就比较简单，其实和coremark 一样。只需要做好以下两点就可以了：</p>
<ul>
<li>提供时间基准，用于获取start time 和 end time ，一般为timer 的计数器。</li>
<li>提供pintf 函数的重定义，用于打印。</li>
<li>注意不要让计数器超过计数范围了。</li>
</ul>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2024-06-04T15:56:27.000Z" title="2024/6/4 23:56:27">2024-06-04</time>发表</span><span class="level-item"><time dateTime="2024-06-06T14:53:41.194Z" title="2024/6/6 22:53:41">2024-06-06</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/%E7%A7%AF%E7%B4%AF/">积累</a></span><span class="level-item">6 分钟读完 (大约941个字)</span></div></div><div class="content"><h4 id="关于链接脚本和汇编导致的数据段初始化错误的问题"><a href="#关于链接脚本和汇编导致的数据段初始化错误的问题" class="headerlink" title="关于链接脚本和汇编导致的数据段初始化错误的问题"></a>关于链接脚本和汇编导致的数据段初始化错误的问题</h4><h4 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h4><p>第一个链接脚本存在data 段初始化失败的问题，第二个link 脚本增加了At&gt;flash就可以正常的运行了，是为什么？如果只是链接错误的话，那么汇编从ram 向同地址的ram 中搬运为什么就会运行出错？</p>
<hr>
<p>链接脚本分别如下：</p>
<ul>
<li>有错误的类型</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">MEMORY</span><br><span class="line">&#123;</span><br><span class="line">  flash (rxai!w) : ORIGIN = <span class="number">0x20000000</span>, LENGTH = <span class="number">256</span>k</span><br><span class="line">  ram   (wxa!ri) : ORIGIN = <span class="number">0x20040000</span>, LENGTH = <span class="number">384</span>k   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  .lalign         :</span><br><span class="line">  &#123;</span><br><span class="line">    . = ALIGN(<span class="number">4</span>);</span><br><span class="line">    PROVIDE( _data_lma = . );</span><br><span class="line">  &#125; &gt; flash</span><br><span class="line"></span><br><span class="line">  .dalign         :</span><br><span class="line">  &#123;</span><br><span class="line">    . = ALIGN(<span class="number">4</span>);</span><br><span class="line">    PROVIDE( _data = . );</span><br><span class="line">  &#125; &gt; ram </span><br><span class="line"></span><br><span class="line">  .data          :</span><br><span class="line">  &#123;</span><br><span class="line">    *(.data .data.*)</span><br><span class="line">    *(.gnu.linkonce.d.*)</span><br><span class="line">    . = ALIGN(<span class="number">8</span>);</span><br><span class="line">    PROVIDE( __global_pointer$ = . + <span class="number">0x800</span> );</span><br><span class="line">    *(.sdata .sdata.*)</span><br><span class="line">    *(.gnu.linkonce.s.*)</span><br><span class="line">    . = ALIGN(<span class="number">8</span>);</span><br><span class="line">    *(.srodata.cst16)</span><br><span class="line">    *(.srodata.cst8)</span><br><span class="line">    *(.srodata.cst4)</span><br><span class="line">    *(.srodata.cst2)</span><br><span class="line">    *(.srodata .srodata.*)</span><br><span class="line">  &#125; &gt; ram </span><br></pre></td></tr></table></figure>

<ul>
<li>没有错误的类型</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">.lalign         :</span><br><span class="line">&#123;</span><br><span class="line">  . = ALIGN(<span class="number">4</span>);</span><br><span class="line">  PROVIDE( _data_lma = . );</span><br><span class="line">&#125; &gt;rom AT&gt;flash :flash</span><br><span class="line"></span><br><span class="line">.dalign         :</span><br><span class="line">&#123;</span><br><span class="line">  . = ALIGN(<span class="number">4</span>);</span><br><span class="line">  PROVIDE( _data = . );</span><br><span class="line">&#125; &gt;ram AT&gt;flash :ram_init</span><br><span class="line"></span><br><span class="line">.data          :</span><br><span class="line">&#123;</span><br><span class="line">  *(.data .data.*)</span><br><span class="line">  *(.gnu.linkonce.d.*)</span><br><span class="line">  . = ALIGN(<span class="number">8</span>);</span><br><span class="line">  PROVIDE( __global_pointer$ = . + <span class="number">0x800</span> );</span><br><span class="line">  *(.sdata .sdata.*)</span><br><span class="line">  *(.gnu.linkonce.s.*)</span><br><span class="line">  . = ALIGN(<span class="number">8</span>);</span><br><span class="line">  *(.srodata.cst16)</span><br><span class="line">  *(.srodata.cst8)</span><br><span class="line">  *(.srodata.cst4)</span><br><span class="line">  *(.srodata.cst2)</span><br><span class="line">  *(.srodata .srodata.*)</span><br><span class="line">&#125; &gt;ram AT&gt;flash :ram_init</span><br></pre></td></tr></table></figure>

<ul>
<li>汇编语言搬运data段的操作</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">	la a0, _data_lma</span><br><span class="line">	la a1, _data</span><br><span class="line">	la a2, _edata</span><br><span class="line">	bgeu a1, a2, <span class="number">2f</span></span><br><span class="line"><span class="number">1</span>:</span><br><span class="line">	lw t0, (a0)</span><br><span class="line">	sw t0, (a1)</span><br><span class="line">	addi a0, a0, <span class="number">4</span></span><br><span class="line">	addi a1, a1, <span class="number">4</span></span><br><span class="line">	bltu a1, a2, <span class="number">1b</span></span><br><span class="line"><span class="number">2</span>:</span><br></pre></td></tr></table></figure>

<h4 id="分析如下："><a href="#分析如下：" class="headerlink" title="分析如下："></a>分析如下：</h4><ul>
<li><p>原来存在的问题和分析思路</p>
<ul>
<li>问题：上诉所说第一个链接脚本存在data 段初始化失败的问题，第二个link 脚本增加了At&gt;flash就可以正常的运行了，是为什么？如果只是链接错误的话，那么汇编从ram 向同地址的ram 中搬运为什么就会运行出错？</li>
<li>解决思路：<ul>
<li><ol>
<li>确认链接器会把data 段的数据放在哪里？</li>
<li>真正代码跑起来的时候，mcu 会去哪里取代码？这个是由谁决定的？连接器还是编译器？</li>
<li>目前问题的逻辑解释</li>
</ol>
</li>
<li>对于问题1：一般情况下不加AT 属性就会编译在哪个内存空间，就存放在哪个内存空间。</li>
<li>对于问题2：真正代码跑起来的时候，mcu 会去ram 中取data段，这个是由连接器决定的（连接器会 为每个符号分配地址？），因为两个lds 文件都是把data 段放在了ram 的区域。</li>
</ul>
</li>
<li>原因解释，对应这个问题，有以下几点<ul>
<li><ol>
<li>符号的定义，结合上面的lds 源码，_data_lma 永远在 flash地址，_data永远在ram地址</li>
<li>汇编代码：结合汇编，永远是从_data_lma  搬运 到data 地址处</li>
<li>链接脚本：第一种错误的链接脚本，没有加<code>At&gt;flash</code>,data 段存放和使用地址都在 ram区域（<em>data</em> 地址开始），这个时候汇编代码还将_data_lma_ 的数据搬运到 <em>data</em> 处就会导致将错误的数据覆盖了正确的数据。</li>
<li>第二种正确的链接脚本，加个<code>At&gt;flash</code>，data 段存放地址在_data_lma_ 开始的地址和使用地址在_data_开始的地址，这个时候利用汇编代码将_data_lma_ 的数据搬运到 <em>data</em> 处，就是将数据搬运到了改在的位置，程序能正常运行。</li>
</ol>
</li>
</ul>
</li>
</ul>
</li>
<li><p>对于符号的数值定义很重要</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">MEMORY</span><br><span class="line">&#123;</span><br><span class="line">  flash (rxai!w) : ORIGIN = <span class="number">0x20000000</span>, LENGTH = <span class="number">256</span>k</span><br><span class="line">  ram   (wxa!ri) : ORIGIN = <span class="number">0x20040000</span>, LENGTH = <span class="number">384</span>k   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  .lalign         :</span><br><span class="line">  &#123;</span><br><span class="line">    . = ALIGN(<span class="number">4</span>);</span><br><span class="line">    PROVIDE( _data_lma = . ); <span class="comment">/* 这里的_data_lma  可以看到就是flash 中的地址 */</span></span><br><span class="line">  &#125; &gt; flash</span><br><span class="line"></span><br><span class="line">  .dalign         :</span><br><span class="line">  &#123;</span><br><span class="line">    . = ALIGN(<span class="number">4</span>);</span><br><span class="line">    PROVIDE( _data = . ); <span class="comment">/*  这里的 _data 地址是ram中的地址*/</span></span><br><span class="line">  &#125; &gt; ram </span><br></pre></td></tr></table></figure>
</li>
<li><p>由于链接的时候选择了将.data 段编译到了ram 中，所以实际的时候取数会去ram的地址取值。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> .data          :</span><br><span class="line"> &#123;</span><br><span class="line">、、、、、、</span><br><span class="line"> &#125; &gt;ram</span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="待后续补充"><a href="#待后续补充" class="headerlink" title="待后续补充"></a>待后续补充</h5><ul>
<li>用readelf 查看两种编译方式编译出来的section的区别</li>
</ul>
</div></article></div></div><div class="column column-left is-4-tablet is-4-desktop is-4-widescreen  order-1"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar" src="/img/my.png" alt="Satellite"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">Satellite</p><p class="is-size-6 is-block">none</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>SZHOU,CHINA</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/archives"><p class="title">13</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/categories"><p class="title">2</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/tags"><p class="title">0</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/ppoffice" target="_blank" rel="me noopener">关注我</a></div></div></div><!--!--><div class="card widget" data-type="links"><div class="card-content"><div class="menu"><h3 class="menu-label">链接</h3><ul class="menu-list"><li><a class="level is-mobile" href="https://hexo.io" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Hexo</span></span><span class="level-right"><span class="level-item tag">hexo.io</span></span></a></li><li><a class="level is-mobile" href="https://bulma.io" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Bulma</span></span><span class="level-right"><span class="level-item tag">bulma.io</span></span></a></li></ul></div></div></div><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">分类</h3><ul class="menu-list"><li><a class="level is-mobile" href="/categories/uboot-linux/"><span class="level-start"><span class="level-item">uboot_linux</span></span><span class="level-end"><span class="level-item tag">6</span></span></a></li><li><a class="level is-mobile" href="/categories/%E7%A7%AF%E7%B4%AF/"><span class="level-start"><span class="level-item">积累</span></span><span class="level-end"><span class="level-item tag">7</span></span></a></li></ul></div></div></div><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">最新文章</h3><article class="media"><div class="media-content"><p class="date"><time dateTime="2024-06-06T15:00:09.076Z">2024-06-06</time></p><p class="title"><a href="/2024/06/06/%E7%A7%AF%E7%B4%AF/%E9%9A%8F%E7%AC%94%E9%97%AE%E9%A2%98/"> </a></p><p class="categories"><a href="/categories/%E7%A7%AF%E7%B4%AF/">积累</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2024-06-06T15:00:09.075Z">2024-06-06</time></p><p class="title"><a href="/2024/06/06/%E7%A7%AF%E7%B4%AF/vscode+clangd/"> </a></p><p class="categories"><a href="/categories/%E7%A7%AF%E7%B4%AF/">积累</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2024-06-06T15:00:09.074Z">2024-06-06</time></p><p class="title"><a href="/2024/06/06/uboot&amp;linux/uboot_analyse/"> </a></p><p class="categories"><a href="/categories/uboot-linux/">uboot_linux</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2024-06-06T15:00:09.072Z">2024-06-06</time></p><p class="title"><a href="/2024/06/06/uboot&amp;linux/uboot_3/"> </a></p><p class="categories"><a href="/categories/uboot-linux/">uboot_linux</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2024-06-06T15:00:09.071Z">2024-06-06</time></p><p class="title"><a href="/2024/06/06/uboot&amp;linux/uboot_2/"> </a></p><p class="categories"><a href="/categories/uboot-linux/">uboot_linux</a></p></div></article></div></div><div class="card widget" data-type="archives"><div class="card-content"><div class="menu"><h3 class="menu-label">归档</h3><ul class="menu-list"><li><a class="level is-mobile" href="/archives/2024/06/"><span class="level-start"><span class="level-item">六月 2024</span></span><span class="level-end"><span class="level-item tag">13</span></span></a></li></ul></div></div></div><!--!--><div class="card widget" data-type="subscribe-email"><div class="card-content"><div class="menu"><h3 class="menu-label">订阅更新</h3><form action="https://feedburner.google.com/fb/a/mailverify" method="post" target="popupwindow" onsubmit="window.open(&#039;https://feedburner.google.com/fb/a/mailverify?uri=&#039;,&#039;popupwindow&#039;,&#039;scrollbars=yes,width=550,height=520&#039;);return true"><input type="hidden" value="" name="uri"><input type="hidden" name="loc" value="en_US"><div class="field has-addons"><div class="control has-icons-left is-expanded"><input class="input" name="email" type="email" placeholder="Email"><span class="icon is-small is-left"><i class="fas fa-envelope"></i></span></div><div class="control"><input class="button" type="submit" value="订阅"></div></div></form></div></div></div><div class="card widget"><div class="card-content"><div class="notification is-danger">You need to set <code>client_id</code> and <code>slot_id</code> to show this AD unit. Please set it in <code>_config.yml</code>.</div></div></div><div class="card widget" data-type="subscribe-email"><div class="card-content"><div class="menu"><h3 class="menu-label">follow.it</h3><form action="" method="post" target="_blank"><div class="field has-addons"><div class="control has-icons-left is-expanded"><input class="input" name="email" type="email" placeholder="Email"><span class="icon is-small is-left"><i class="fas fa-envelope"></i></span></div><div class="control"><input class="button" type="submit" value="订阅"></div></div></form></div></div></div></div><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/logo.svg" alt="Hexo" height="28"></a><p class="is-size-7"><span>&copy; 2024 John Doe</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p><p class="is-size-7">© 2019</p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("zh-cn");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script data-pjax src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script data-pjax src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "此网站使用Cookie来改善您的体验。",
          dismiss: "知道了！",
          allow: "允许使用Cookie",
          deny: "拒绝",
          link: "了解更多",
          policy: "Cookie政策",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/pjax@0.2.8/pjax.min.js"></script><script src="/js/pjax.js"></script><!--!--><!--!--><!--!--><script data-pjax src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>