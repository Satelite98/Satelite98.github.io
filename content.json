{"posts":[{"title":"","text":"cp15_init 函数详解 关于CP 的操作，参考这个链接：https://www.cnblogs.com/schips/p/11270644.html /************************************************************************* * * cpu_init_cp15 * * Setup CP15 registers (cache, MMU, TLBs). The I-cache is turned on unless * CONFIG_SYS_ICACHE_OFF is defined. * *************************************************************************/ENTRY(cpu_init_cp15) /* * Invalidate L1 I/D */ mov r0, #0 @ set up for MCR mcr p15, 0, r0, c8, c7, 0 @ 无效整个数据和指令TLB mcr p15, 0, r0, c7, c5, 0 @无效整个指令cache mcr p15, 0, r0, c7, c5, 6 @ 无效整个跳转目标cache mcr p15, 0, r0, c7, c10, 4 @ 清空写缓存区 mcr p15, 0, r0, c7, c5, 4 @ 清空预取缓存区 /* * disable MMU stuff and caches */ mrc p15, 0, r0, c1, c0, 0 @把cp15-c1 的值读到r0中 bic r0, r0, #0x00002000 @ 设置低端一场中断向量表，且在可重定位状态 bic r0, r0, #0x00000007 @ 关闭mmu、地址对齐、禁止cache orr r0, r0, #0x00000002 @ 使能地址对齐检查 orr r0, r0, #0x00000800 @ 使能跳转预测#ifdef CONFIG_SYS_ICACHE_OFF bic r0, r0, #0x00001000 @ 关闭 I-cahe#else orr r0, r0, #0x00001000 @ 使能 I-cahe#endif mcr p15, 0, r0, c1, c0, 0#ifdef CONFIG_ARM_ERRATA_716044 --使能跳转预测 mrc p15, 0, r0, c1, c0, 0 @ read system control register orr r0, r0, #1 &lt;&lt; 11 @ set bit #11 mcr p15, 0, r0, c1, c0, 0 @ write system control register#endif// --C15 寄存器会随着设计的不同而不同。#if (defined(CONFIG_ARM_ERRATA_742230) || defined(CONFIG_ARM_ERRATA_794072)) mrc p15, 0, r0, c15, c0, 1 @ read diagnostic register orr r0, r0, #1 &lt;&lt; 4 @ set bit #4 mcr p15, 0, r0, c15, c0, 1 @ write diagnostic register#endif#ifdef CONFIG_ARM_ERRATA_743622 mrc p15, 0, r0, c15, c0, 1 @ read diagnostic register orr r0, r0, #1 &lt;&lt; 6 @ set bit #6 mcr p15, 0, r0, c15, c0, 1 @ write diagnostic register#endif#ifdef CONFIG_ARM_ERRATA_751472 mrc p15, 0, r0, c15, c0, 1 @ read diagnostic register orr r0, r0, #1 &lt;&lt; 11 @ set bit #11 mcr p15, 0, r0, c15, c0, 1 @ write diagnostic register#endif#ifdef CONFIG_ARM_ERRATA_761320 mrc p15, 0, r0, c15, c0, 1 @ read diagnostic register orr r0, r0, #1 &lt;&lt; 21 @ set bit #21 mcr p15, 0, r0, c15, c0, 1 @ write diagnostic register#endif#ifdef CONFIG_ARM_ERRATA_845369 mrc p15, 0, r0, c15, c0, 1 @ read diagnostic register orr r0, r0, #1 &lt;&lt; 22 @ set bit #22 mcr p15, 0, r0, c15, c0, 1 @ write diagnostic register#endif mov r5, lr @ Store my Caller mrc p15, 0, r1, c0, c0, 0 @ 把cp15-c0 读到r1 mov r3, r1, lsr #20 @ get variant field and r3, r3, #0xf @ r3 has CPU variant and r4, r1, #0xf @ r4 has CPU revision mov r2, r3, lsl #4 @ shift variant field for combined value orr r2, r4, r2 @ r2 has combined CPU variant + revision#ifdef CONFIG_ARM_ERRATA_798870 cmp r2, #0x30 @ Applies to lower than R3p0 bge skip_errata_798870 @ skip if not affected rev cmp r2, #0x20 @ Applies to including and above R2p0 blt skip_errata_798870 @ skip if not affected rev mrc p15, 1, r0, c15, c0, 0 @ read l2 aux ctrl reg orr r0, r0, #1 &lt;&lt; 7 @ Enable hazard-detect timeout push {r1-r5} @ Save the cpu info registers bl v7_arch_cp15_set_l2aux_ctrl isb @ Recommended ISB after l2actlr update pop {r1-r5} @ Restore the cpu info - fall throughskip_errata_798870:#endif#ifdef CONFIG_ARM_ERRATA_801819 cmp r2, #0x24 @ Applies to lt including R2p4 bgt skip_errata_801819 @ skip if not affected rev cmp r2, #0x20 @ Applies to including and above R2p0 blt skip_errata_801819 @ skip if not affected rev mrc p15, 0, r0, c0, c0, 6 @ pick up REVIDR reg and r0, r0, #1 &lt;&lt; 3 @ check REVIDR[3] cmp r0, #1 &lt;&lt; 3 beq skip_errata_801819 @ skip erratum if REVIDR[3] is set mrc p15, 0, r0, c1, c0, 1 @ read auxilary control register orr r0, r0, #3 &lt;&lt; 27 @ Disables streaming. All write-allocate @ lines allocate in the L1 or L2 cache. orr r0, r0, #3 &lt;&lt; 25 @ Disables streaming. All write-allocate @ lines allocate in the L1 cache. push {r1-r5} @ Save the cpu info registers bl v7_arch_cp15_set_acr pop {r1-r5} @ Restore the cpu info - fall throughskip_errata_801819:#endif#ifdef CONFIG_ARM_ERRATA_454179 cmp r2, #0x21 @ Only on &lt; r2p1 bge skip_errata_454179 mrc p15, 0, r0, c1, c0, 1 @ Read ACR orr r0, r0, #(0x3 &lt;&lt; 6) @ Set DBSM(BIT7) and IBE(BIT6) bits push {r1-r5} @ Save the cpu info registers bl v7_arch_cp15_set_acr pop {r1-r5} @ Restore the cpu info - fall throughskip_errata_454179:#endif#ifdef CONFIG_ARM_ERRATA_430973 cmp r2, #0x21 @ Only on &lt; r2p1 bge skip_errata_430973 mrc p15, 0, r0, c1, c0, 1 @ Read ACR orr r0, r0, #(0x1 &lt;&lt; 6) @ Set IBE bit push {r1-r5} @ Save the cpu info registers bl v7_arch_cp15_set_acr pop {r1-r5} @ Restore the cpu info - fall throughskip_errata_430973:#endif#ifdef CONFIG_ARM_ERRATA_621766 cmp r2, #0x21 @ Only on &lt; r2p1 bge skip_errata_621766 mrc p15, 0, r0, c1, c0, 1 @ Read ACR orr r0, r0, #(0x1 &lt;&lt; 5) @ Set L1NEON bit push {r1-r5} @ Save the cpu info registers bl v7_arch_cp15_set_acr pop {r1-r5} @ Restore the cpu info - fall throughskip_errata_621766:#endif mov pc, r5 @ back to my callerENDPROC(cpu_init_cp15)","link":"/2024/06/06/uboot&linux/cp15_init/"},{"title":"","text":"从头理清uboot（2）-启动流程分析 1.总体流程图 2. 逐步分析 2.1 上电后执行的第一条指令 2.2 初始化中断向量表 2.3 初始化工作模式 &amp; 初始化中断向量表。 2.4 cpu_init_cp15 &amp; cpu_init_crit 2.5 进入_main 函数 2.6 执行board_init_r函数，开始最后的初始化 3. 整体函数调用框架 [toc] 1.总体流程图 graph TB上电--&gt;a[entry: start] --&gt;设置中断向量表,跳转到reset--&gt;设置处理器工作模式--&gt;设置CP的值/初始化中断向量表--&gt;关闭mmu,初始化堆栈值--&gt;初始化gd结构体:完成内存布局初步分配--&gt;c[利用函数指针初始化函数]c--&gt;代码重定位--&gt;dyn段的table值重定位+向量表重定位--&gt;再次执行函数指针数组--&gt;进入main_loop函数 2. 逐步分析 2.1 上电后执行的第一条指令 由于在编译的时候有下面的链接命令： arm-linux-gnueabihf-ld.bfd -pie --gc-sections -Bstatic -Ttext 0x87800000 -o u-boot -T u-boot.lds arch/arm/cpu/armv7/start.o --start-group arch/arm/cpu/built-in.o ...... test/dm/built-in.o --end-group arch/arm/lib/eabi_compat.o -L /usr/lib/gcc-cross/arm-linux-gnueabihf/9 -lgcc -Map u-boot.map 所以其实是利用u-boot.lds来链接整个bin 文件的。那么就可以在lds 中看到uboot 的程序入口： ENTRY(_start)SECTIONS{ . = 0x00000000; . = ALIGN(4); .text : { *(.__image_copy_start) *(.vectors) arch/arm/cpu/armv7/start.o (.text*) *(.text*) } 在arch/arm/lib/vector.s中能够找到_start的具体实现： _start:#ifdef CONFIG_SYS_DV_NOR_BOOT_CFG .word CONFIG_SYS_DV_NOR_BOOT_CFG#endif b reset ldr pc, _undefined_instruction ldr pc, _software_interrupt ldr pc, _prefetch_abort ldr pc, _data_abort ldr pc, _not_used ldr pc, _irq ldr pc, _fiq ​ 由此我们找到了程序上电执行的第一条指令。 2.2 初始化中断向量表 ​ 由上可知，_start的汇编代码的作用便是初始化了中断向量表，并且跳转像了reset函数。至于为什么这里实现了跳转了中断向量表，可先参考这个blog 学习： https://www.cnblogs.com/liangliangge/p/12549087.html ==TODO：补充armv7 中断处理功能== 2.3 初始化工作模式 &amp; 初始化中断向量表。 ​ 在_start函数中，会跳到reset函数（在arch/arm/cpu/armv7/start.s）中，其函数如下： .globl reset .globl save_boot_params_retreset: ......//中间代码边分析边给出 bl _main ​ 进入reset 之后，首先执行的就是b save_boot_params但是又会跳回save_boot_params_ret:，在reset 中再次执行，由于定义是week 的，最后实际实现还可以再覆盖。见下方代码： ENTRY(save_boot_params) b save_boot_params_retENDPROC(save_boot_params) .weak save_boot_params ​ 之后便会初始化处理器的工作模式及关闭中断，见下方代码，注释已经写入其中。 https://blog.csdn.net/zhoutaopower/article/details/113746587 mrs r0, cpsr //读cpsr 的值到r0and r1, r0, #0x1f //取 低五位到r1teq r1, #0x1a //判断是，即判断是不是HYP模式bicne r0, r0, #0x1f //不是，就清除低五位orrne r0, r0, #0x13 //不是，设置为SVC 模式orr r0, r0, #0xc0 //关闭FIQ 和IRQmsr cpsr,r0 //把新的r0 值写入CPSR ​ 其次就会设置SCTLR 的值，这里会涉及到armv7 的CP 寄存器，可以见这篇文章：协处理器CP15介绍—MCR/MRC指令(6) - 诺谦 - 博客园 (cnblogs.com)，uboot 汇编相关见下方注释： #if !(defined(CONFIG_OMAP44XX) &amp;&amp; defined(CONFIG_SPL_BUILD)) /* Set V=0 in CP15 SCTLR register - for VBAR to point to vector */ mrc p15, 0, r0, c1, c0, 0 //把cp15寄存器中c1控制位 读到r0中 bic r0, #CR_V //清除r0 中的 CR_V 控制位，表示向量表地址为0x00000000,且可以重定位向量表。 mcr p15, 0, r0, c1, c0, 0 //把r0写回 cp15-c1 /* Set vector address in CP15 VBAR register */ ldr r0, =_start mcr p15, 0, r0, c12, c0, 0 //把_start设置为向量表地址，写入 cp15-c12#endif 2.4 cpu_init_cp15 &amp; cpu_init_crit ​ 在设置好中断向量表之后，在reset 中会做两个CPU 核相关的init动作，之后便会跳转到_main执行，见下方代码： #ifndef CONFIG_SKIP_LOWLEVEL_INIT bl cpu_init_cp15 bl cpu_init_crit#endif bl _main 我们依次分析这两个函数都做了什么事情： 2.4.1 cpu_init_cp15 ​ 通过下方代码，可以看出，功能为：关闭指令cache、清空写和预取缓存区，关闭mmu、使能地址跳转预测、获取CPU信息并且根据CPU info 信息的不同来做处理。下方直接将注释写入下方代码段中： /************************************************************************* * * cpu_init_cp15 * * Setup CP15 registers (cache, MMU, TLBs). The I-cache is turned on unless * CONFIG_SYS_ICACHE_OFF is defined. * *************************************************************************/ENTRY(cpu_init_cp15) /* * Invalidate L1 I/D */ mov r0, #0 @ set up for MCR mcr p15, 0, r0, c8, c7, 0 @ 无效整个数据和指令TLB mcr p15, 0, r0, c7, c5, 0 @无效整个指令cache mcr p15, 0, r0, c7, c5, 6 @ 无效整个跳转目标cache mcr p15, 0, r0, c7, c10, 4 @ 清空写缓存区 mcr p15, 0, r0, c7, c5, 4 @ 清空预取缓存区 /* * disable MMU stuff and caches */ mrc p15, 0, r0, c1, c0, 0 @把cp15-c1 的值读到r0中 bic r0, r0, #0x00002000 @ 设置低端一场中断向量表，且在可重定位状态 bic r0, r0, #0x00000007 @ 关闭mmu、地址对齐、禁止cache orr r0, r0, #0x00000002 @ 使能地址对齐检查 orr r0, r0, #0x00000800 @ 使能跳转预测#ifdef CONFIG_SYS_ICACHE_OFF bic r0, r0, #0x00001000 @ 关闭 I-cahe#else orr r0, r0, #0x00001000 @ 使能 I-cahe#endif mcr p15, 0, r0, c1, c0, 0#ifdef CONFIG_ARM_ERRATA_716044 --使能跳转预测 mrc p15, 0, r0, c1, c0, 0 @ read system control register orr r0, r0, #1 &lt;&lt; 11 @ set bit #11 mcr p15, 0, r0, c1, c0, 0 @ write system control register#endif --C15 寄存器会随着设计的不同而不同。#if (defined(CONFIG_ARM_ERRATA_742230) || defined(CONFIG_ARM_ERRATA_794072)) mrc p15, 0, r0, c15, c0, 1 @ read diagnostic register orr r0, r0, #1 &lt;&lt; 4 @ set bit #4 mcr p15, 0, r0, c15, c0, 1 @ write diagnostic register#endif . . @中间为相似判断，省略 . . . . mov r5, lr @ Store my Caller 保存下lr指针，保存函数返回地址 mrc p15, 0, r1, c0, c0, 0 @ 把cp15-c0-主标识符 读到r1 mov r3, r1, lsr #20 @ 将r1 右移20bit ,存储到r3 and r3, r3, #0xf @获取r1[23:20] and r4, r1, #0xf @ 获取r1[4:0] mov r2, r3, lsl #4 @ shift variant field for combined value orr r2, r4, r2 @ r2= r1[23:20] + r1[4:0] = c0[23:20] + c0[4:0] CPU variant + revision . . @中间为相似判断，省略 . . . .#ifdef CONFIG_ARM_ERRATA_621766 cmp r2, #0x21 @ Only on &lt; r2p1 bge skip_errata_621766 mrc p15, 0, r0, c1, c0, 1 @ Read ACR orr r0, r0, #(0x1 &lt;&lt; 5) @ Set L1NEON bit push {r1-r5} @ Save the cpu info registers bl v7_arch_cp15_set_acr pop {r1-r5} @ Restore the cpu info - fall throughskip_errata_621766:#endif mov pc, r5 @ 退出函数执行，跳回。ENDPROC(cpu_init_cp15) 2.4.1 cpu_init_crit ​ 跳入 lowlevel_init函数，在arch/arm/cpu/armv7/lowlevel_init.s中有定义，可见初步作用是初始化栈，调用s_init函数，定义在arch/arm/cpu/armv7/mx6/soc.c，但是对于imax6ull而言就是个空函数，故整体而言，这里只是做了一个获取CONFIG_SYS_INIT_SP_ADDR的值，做了下sp 的初始化，给GD_SIZE留出空间。 ENTRY(lowlevel_init) ldr sp, =CONFIG_SYS_INIT_SP_ADDR bic sp, sp, #7 /*8byte对齐*/#ifdef CONFIG_SPL_DM mov r9, #0#else#ifdef CONFIG_SPL_BUILD ldr r9, =gdata#else sub sp, sp, #GD_SIZE @减去 GD_SIZE 的值。 bic sp, sp, #7 /*8byte对齐*/ mov r9, sp#endif#endif push {ip, lr} @将IP 和 lr 都压入栈中 bl s_init pop {ip, pc} @将IP 和 lr 都出栈ENDPROC(lowlevel_init) ​ 对于CONFIG_SYS_INIT_SP_ADDR和``在include/configs/mx6sllevk.h中有定义： #define CONFIG_SYS_INIT_RAM_ADDR IRAM_BASE_ADDR#define CONFIG_SYS_INIT_RAM_SIZE IRAM_SIZE#define CONFIG_SYS_INIT_SP_OFFSET \\ (CONFIG_SYS_INIT_RAM_SIZE - GENERATED_GBL_DATA_SIZE)#define CONFIG_SYS_INIT_SP_ADDR \\ (CONFIG_SYS_INIT_RAM_ADDR + CONFIG_SYS_INIT_SP_OFFSET) ​ 其中IRAM_BASE_ADDR和 IRAM_SIZE在``arch/arm/include/asm/arch-mx6/imx-regs.h`中有定义,可以看出，这应该是CPU内部的ram： #define IRAM_BASE_ADDR 0x00900000#if !(defined(CONFIG_MX6SX) || defined(CONFIG_MX6UL) || \\ defined(CONFIG_MX6SLL) || defined(CONFIG_MX6SL))#define IRAM_SIZE 0x00040000#else#define IRAM_SIZE 0x00020000#endif ​ 我们还需要知道GENERATED_GBL_DATA_SIZE和GD_SIZE的值，都定义在include/generated/generic-asm-offsets.h中，有以下定义： #define GENERATED_GBL_DATA_SIZE 256 /* (sizeof(struct global_data) + 15) &amp; ~15 @ */#define GENERATED_BD_INFO_SIZE 80 /* (sizeof(struct bd_info) + 15) &amp; ~15 @ */#define GD_SIZE 248 /* sizeof(struct global_data) @ */#define GD_BD 0 /* offsetof(struct global_data, bd) @ */#define GD_MALLOC_BASE 188 /* offsetof(struct global_data, malloc_base) @ */#define GD_RELOCADDR 44 /* offsetof(struct global_data, relocaddr) @ */#define GD_RELOC_OFF 64 /* offsetof(struct global_data, reloc_off) @ */#define GD_START_ADDR_SP 60 /* offsetof(struct global_data, start_addr_sp) @ */ ​ 由此我们可以得到当前的栈指针的值： * sp = CONFIG_SYS_INIT_SP_ADDR = (CONFIG_SYS_INIT_RAM_ADDR + CONFIG_SYS_INIT_RAM_SIZE - GENERATED_GBL_DATA_SIZE) = 0x00900000 + 0x00020000 -256 = 0x0091FF00* sp = sp - GD_SIZE = 0x0091FF00 - 248 = 0x0091FE08 * bic sp, sp, #7 --&gt; sp = 0x0091FE00 2.5 进入_main 函数 ​ ==补充重点：==建议看crt0.S 中关于_main 函数的作用，里面解释了为什么会有这些流程 ​ 在上面步骤，应该是初步完成了CPU的一些配置，解下来会进入_main函数，进一步完成系统级的初始化工作。 __main函数定义在 arch/arm/lib/crt0.S中。【crt0.S 作用是 准备计入C语言需要的环境。】 ​ 首先判断是否定义了SPL build 相关，初始化栈sp 指针。然后会分别调用board_init_f_alloc_reserve、board_init_f_init_reserve、board_init_f(r0 ==0),可见下方代码： ENTRY(_main)/* * Set up initial C runtime environment and call board_init_f(0). */#if defined(CONFIG_SPL_BUILD) &amp;&amp; defined(CONFIG_SPL_STACK) ldr sp, =(CONFIG_SPL_STACK)#else ldr sp, =(CONFIG_SYS_INIT_SP_ADDR)#endif#if defined(CONFIG_CPU_V7M) /* v7M forbids using SP as BIC destination */ mov r3, sp bic r3, r3, #7 mov sp, r3#else bic sp, sp, #7 /* 8-byte alignment for ABI compliance */#endif mov r0, sp bl board_init_f_alloc_reserve mov sp, r0 /* set up gd here, outside any C code */ mov r9, r0 bl board_init_f_init_reserve mov r0, #0 bl board_init_f#if ! defined(CONFIG_SPL_BUILD)/* * Set up intermediate environment (new sp and gd) and call * relocate_code(addr_moni). Trick here is that we'll return * 'here' but relocated. */ ldr sp, [r9, #GD_START_ADDR_SP] /* sp = gd-&gt;start_addr_sp */ ....... 2.5.1 board_init_f_alloc_reserve（sp） ​ 其中调用的board_init_f_alloc_reserve（sp）在common/init/board_init.c中，这个函数有一个传参，实际为sp 的值，可见这个函数的作用为在栈中留出CONFIG_SYS_MALLOC_F_LEN = 0x400大小和global_data结构体的大小(GD_SIZE)空间区域后，进行一个16byte 的对齐操作。 ulong board_init_f_alloc_reserve(ulong top){ /* Reserve early malloc arena */#if defined(CONFIG_SYS_MALLOC_F) top -= CONFIG_SYS_MALLOC_F_LEN;#endif /* LAST : reserve GD (rounded up to a multiple of 16 bytes) */ top = rounddown(top-sizeof(struct global_data), 16); return top;} ​ 所以当前的sp 为：0x0091FF00 - 0x400 - 248 = 0x0091Fa00 。出栈后会把算好的r0 在赋值给sp，同时赋值g给r9。 2.5.2 board_init_f_init_reserve（sp） ​ 之后会调用board_init_f_init_reserve，对于imax6ull 条件编译之后见下方，可见主要作用为： ​ 将当前sp 设置为global_data的基地址、global_data区域清0、然后把gd-&gt;malloc_base设置为base 加上struct global_data并且16字节取整，之后base 加上CONFIG_SYS_MALLOC_F_LEN长度。那么这个函数就是把global_data初始化了，把malloc地址指向了 0x0091FF00 - 0x400，然后把base设置为了0x0091FF00 再赋值给r0了。 ​ 作用：这里留出一块内存用于保存global_data和 执行后面的函数的内存空间 void board_init_f_init_reserve(ulong base){ struct global_data *gd_ptr; /* * clear GD entirely and set it up. * Use gd_ptr, as gd may not be properly set yet. */ gd_ptr = (struct global_data *)base; /* zero the area */#ifdef _USE_MEMCPY memset(gd_ptr, '\\0', sizeof(*gd)); /* next alloc will be higher by one GD plus 16-byte alignment */ base += roundup(sizeof(struct global_data), 16); /* * record early malloc arena start. * Use gd as it is now properly set for all architectures. */#if defined(CONFIG_SYS_MALLOC_F) /* go down one 'early malloc arena' */ gd-&gt;malloc_base = base; /* next alloc will be higher by one 'early malloc arena' size */ base += CONFIG_SYS_MALLOC_F_LEN;#endif} 2.5.3 board_init_f(0) ​ board_init_f函数定义在 common/board_f.c中，经过条件编译之后的结果为下图所示： void board_init_f(ulong boot_flags){ gd-&gt;flags = boot_flags; gd-&gt;have_console = 0; if (initcall_run_list(init_sequence_f)) hang();#if !defined(CONFIG_ARM) &amp;&amp; !defined(CONFIG_SANDBOX) &amp;&amp; \\ !defined(CONFIG_EFI_APP) /* NOTREACHED - jump_to_copy() does not return */ hang();#endif /* Light up LED1 */ imx6_light_up_led1();} ​ gd-&gt;have_console = 0;表明现在还没有窗口。 ​ 其中boot_flags == 0作为输入传入，后续主要是执行initcall_run_list(init_sequence_f)这个函数，我们需要先看函数输入init_sequence_f的定义(已经经过条件编译，见下方)。 ​ 其中init_fnc_t的定义为typedef int (*init_fnc_t)(void);，由此这是一个函数指针结构体，而在board_init_f中调用的initcall_run_list函数就是会遍历执行下方的init_sequence_f函数结构体，来执行板级的初始化。对于被遍历的函数，大致功能见注释。 static init_fnc_t init_sequence_f[] = { setup_mon_len, //gd-&gt;mon_len = (ulong)&amp;__bss_end - (ulong)_start; 设置mon_len 为代码长度 initf_malloc, //gd-&gt;malloc_limit = 0x40; 当前内存池大小。 initf_console_record, //return 0; arch_cpu_init, /* basic arch cpu dependent setup */ initf_dm, //初始化驱动模型相关 arch_cpu_init_dm, mark_bootstage, /* need timer, go after init dm */#if defined(CONFIG_BOARD_EARLY_INIT_F) board_early_init_f, //，I.MX6ULL 用来初始化串口的 IO 配置#endif#if defined(CONFIG_ARM) || defined(CONFIG_MIPS) || \\ defined(CONFIG_BLACKFIN) || defined(CONFIG_NDS32) || \\ defined(CONFIG_SPARC) timer_init, //初始化内部定时器#endif #if defined(CONFIG_BOARD_POSTCLK_INIT) board_postclk_init, //设置 VDDSOC 电压#endif#if defined(CONFIG_SYS_FSL_CLK) || defined(CONFIG_M68K) get_clocks, //可以配置获取多种时钟值，I.MX6ULL 获取的是 sdhc_clk 时钟#endif env_init, //gd-&gt;env_addr = (ulong)&amp;default_environment[0]; 设置gd ENV 地址 init_baud_rate, /* 根据 “baudrate” 环境变量配置波特率 */ serial_init, /* 串口初始化 会调用函数指针 */ console_init_f, /* gd-&gt;have_console = 1; 配置输出窗口*/ display_options, /* 在窗口上显示输出 */ display_text_info, /* 在窗口上打印文本输出*/ print_cpuinfo, /* 打印CPU 信息 */ #if defined(CONFIG_DISPLAY_BOARDINFO) show_board_info, /* 打印板子 信息 */ #endif INIT_FUNC_WATCHDOG_INIT /*初始化看门狗， I.MX6ULL 来说是空函数 */ INIT_FUNC_WATCHDOG_RESET /*喂狗， I.MX6ULL 来说是空函数 */#if defined(CONFIG_HARD_I2C) || defined(CONFIG_SYS_I2C) init_func_i2c, /* 初始化IIC */#endif announce_dram_init, /* TODO: unify all these dram functions? */#if defined(CONFIG_ARM) || defined(CONFIG_X86) || defined(CONFIG_NDS32) || \\ defined(CONFIG_MICROBLAZE) || defined(CONFIG_AVR32) dram_init, /*gd-&gt;ram_size = imx_ddr_size();把 外部能用的DDR大小付给gd-&gt;ram_size */#endif INIT_FUNC_WATCHDOG_RESET INIT_FUNC_WATCHDOG_RESET INIT_FUNC_WATCHDOG_RESET setup_dest_addr, /* 这个函数下方详细介绍 */ reserve_round_4k, /* gd-&gt;relocaddr &amp;= ~(4096 - 1);重定位地址4k 对齐 */#if !(defined(CONFIG_SYS_ICACHE_OFF) &amp;&amp; defined(CONFIG_SYS_DCACHE_OFF)) &amp;&amp; \\ defined(CONFIG_ARM) reserve_mmu, /* 这个函数下方详细介绍 */#endif reserve_trace, /*留出debug 空间，I.MX6ULL 来说是空函数*/#if !defined(CONFIG_BLACKFIN) reserve_uboot, /*留出 uboot code空间 */#endif#ifndef CONFIG_SPL_BUILD reserve_malloc, /*留出malloc 空间 TOTAL_MALLOC_LEN*/ reserve_board, /* 留出 sizeof(bd_t) 的空间*/#endif setup_machine, /* 设置机器id 等设置，I.MX6ULL 来说是空函数 */ reserve_global_data, /*留出sizeof(gd_t)的空间 */ reserve_fdt, /* 留出 fdt_size 的空间,I.MX6ULL 无效 */ reserve_arch, /* I.MX6ULL 来说是空函数 */ reserve_stacks, /*gd-&gt;start_addr_sp 栈顶做16字节对齐 */ setup_dram_config, /* 设置Dram的地址和大小，后续告诉linux 内核 */ show_dram_config, /* 打印上述信息 */ display_new_sp, /* 打印sp-栈顶 */ INIT_FUNC_WATCHDOG_RESET reloc_fdt, /* I.MX6ULL 没有用到 */重要：setup_reloc, /*设置一些重定位要用的参数，并且将gd 从ram中拷贝到DDR中* / NULL,}; 可以看出，board_init_f(0)总体上是围绕global_data展开的，关于global_data可以参考这篇文档：https://blog.csdn.net/wenjin359/article/details/82849492， setup_dest_addr 函数 作用：初始化gd-&gt;ram_siz、gd-&gt;ram_top、gd-&gt;relocaddr 。 static int setup_dest_addr(void){ gd-&gt;ram_size = board_reserve_ram_top(gd-&gt;ram_size);// ram_szie 前面已经init过了，是imx_ddr_size()#ifdef CONFIG_SYS_SDRAM_BASE gd-&gt;ram_top = CONFIG_SYS_SDRAM_BASE; //设置为DDR base 地址CONFIG_SYS_SDRAM_BASE#endif gd-&gt;ram_top += get_effective_memsize();// base + gd-&gt;ram_size gd-&gt;ram_top = board_get_usable_ram_top(gd-&gt;mon_len); gd-&gt;relocaddr = gd-&gt;ram_top; //重定位地址 = gd-&gt;ram_top debug(&quot;Ram top: %08lX\\n&quot;, (ulong)gd-&gt;ram_top); return 0;} reserve_round_4k 函数，把刚刚初始化的gd-&gt;relocaddr地址4K对齐。gd-&gt;relocaddr &amp;= ~(4096 - 1); reserve_mmu: 作用：在DDR中留出PGTABLE_SIZE大小的空间用于做tlb。 static int reserve_mmu(void){ /* reserve TLB table */ gd-&gt;arch.tlb_size = PGTABLE_SIZE; gd-&gt;relocaddr -= gd-&gt;arch.tlb_size; /* round down to next 64 kB limit */ gd-&gt;relocaddr &amp;= ~(0x10000 - 1); gd-&gt;arch.tlb_addr = gd-&gt;relocaddr; debug(&quot;TLB table from %08lx to %08lx\\n&quot;, gd-&gt;arch.tlb_addr, gd-&gt;arch.tlb_addr + gd-&gt;arch.tlb_size); return 0;} ==reserve_uboot：== 作用：留出code_len 的空间，并且把此时relocaddr地址付给start_addr_sp。注意，这里开始gd-&gt;relocaddr不再继续减小了，因为已经到了代码段都拷完的地方了，重定位的地址已经确定好了！！！ static int reserve_uboot(void){ gd-&gt;relocaddr -= gd-&gt;mon_len; gd-&gt;relocaddr &amp;= ~(4096 - 1); debug(&quot;Reserving %ldk for U-Boot at: %08lx\\n&quot;, gd-&gt;mon_len &gt;&gt; 10, gd-&gt;relocaddr); gd-&gt;start_addr_sp = gd-&gt;relocaddr; return 0;} 其余剩余的reserve_xxx 函数都是在DDR 内存中，划分出对应区域给对应功能实用。有以下几个参数需要注意一下 重定位offset 偏移：gd-&gt;reloc_off = gd-&gt;relocaddr - CONFIG_SYS_TEXT_BASE; 会有一次gd 的搬运：，其中gd 的宏定义展开见下方，由于之前将将cpu ram 的gd 指针存储在R9中，所以芯片内部的ram 中有一份global_data结构体。新的gd 会放在全局变量后面：参考reserve_global_data函数 //搬运：`memcpy(gd-&gt;new_gd, (char *)gd, sizeof(gd_t));`//获取老gd 地址：__asm__ volatile(&quot;mov %0, r9\\n&quot; : &quot;=r&quot; (gd_ptr));//新GD 地址 gd-&gt;new_gd = (gd_t *)map_sysmem(gd-&gt;start_addr_sp, sizeof(gd_t)); 总结：由此 board_info 就执行完了，主要是初始化了DDR的内存布局，并且对golobal data 进行初始化，同时拷贝进了DDR中。 2.5.4 再次回到 _main 函数 执行完DDR区域分配及配置好gd 之后，会执行下面的操作： 把 sp设置到DDR上：ldr sp, [r9, #GD_START_ADDR_SP] /* sp = gd-&gt;start_addr_sp */ 初始化栈，之后会执行代码段的重定位，需要注意lr的值，再次返回时就已经到DDR中的重定位地址了。 问题：当前代码在什么地址？**R:**根据obj dump 来看，在87802800 &lt;_main&gt;:DDR 中。 ==追问：==那为什么需要再搬运一次地址？新搬运的地址在哪里？**R:**搬运的地址是board_init_f()中设置的地址，提高了灵活性？ #if defined(CONFIG_CPU_V7M) /* v7M forbids using SP as BIC destination */ mov r3, sp bic r3, r3, #7 mov sp, r3 #else bic sp, sp, #7 /* 8-byte alignment for ABI compliance */ #endif ldr r9, [r9, #GD_BD] /* r9 = gd-&gt;bd */ sub r9, r9, #GD_SIZE /* new GD is below bd */ 获取新gd的位置？ adr lr, here ldr r0, [r9, #GD_RELOC_OFF] /* r0 = gd-&gt;reloc_off */ add lr, lr, r0 lr = here 地址 + gd-&gt;reloc_off #if defined(CONFIG_CPU_V7M) orr lr, #1 /* As required by Thumb-only */ #endif ldr r0, [r9, #GD_RELOCADDR] /* r0 = gd-&gt;relocaddr */ b relocate_code /*代码从定位*/ 所以执行完这个，跳回的时候就已经在DDR中了？ here: /* * now relocate vectors */ bl relocate_vectors /* Set up final (full) environment */bl c_runtime_cpu_setup /* we still call old routine here */ #endif 执行relocate_code函数 ​ 见下方代码，r1是代码段起始地址，r0是传入的gd-&gt;relocaddr重定位地址，整体作用是判断起始地址和relocaddr是否相等，不相等的话就会进行代码段的搬运（__image_copy_start ~ image_copy_end）。然后进行dyn段，即动态代码段的符号表地址的更改。【此处涉及到elf文件的表示，有兴趣的可以查阅elf 文件格式，了解动态代码是如何执行的。】 注意：这里跳转使用的是b而不是bl就是不需要更改LR的值，因为LR 已经被重定位了。 ENTRY(relocate_code) ldr r1, =__image_copy_start /* r1 &lt;- SRC &amp;__image_copy_start */ subs r4, r0, r1 /* r4 &lt;- relocation offset */ beq relocate_done /* skip relocation */ ldr r2, =__image_copy_end /* r2 &lt;- SRC &amp;__image_copy_end */copy_loop: ldmia r1!, {r10-r11} /* copy from source address [r1] */ stmia r0!, {r10-r11} /* copy to target address [r0] */ cmp r1, r2 /* until source end address [r2] */ blo copy_loop /* * fix .rel.dyn relocations */ ldr r2, =__rel_dyn_start /* r2 &lt;- SRC &amp;__rel_dyn_start */ ldr r3, =__rel_dyn_end /* r3 &lt;- SRC &amp;__rel_dyn_end */fixloop: ldmia r2!, {r0-r1} /* (r0,r1) &lt;- (SRC location,fixup) */ and r1, r1, #0xff cmp r1, #23 /* relative fixup? */ bne fixnext /* relative fix: increase location by offset */ add r0, r0, r4 ldr r1, [r0] add r1, r1, r4 str r1, [r0]fixnext: cmp r2, r3 blo fixlooprelocate_done: bx lrENDPROC(relocate_code) 向量表的重定位： 由于arm处理器将向量表放在代码头部，所以这里中断向量表的重定位也是设置 cp15-c12 的值，将其设置为gd-&gt;relocaddr，即重定位代码段的首地址。编译后的程序如下所示： ENTRY(relocate_vectors) ldr r0, [r9, #GD_RELOCADDR] /* r0 = gd-&gt;relocaddr */ mcr p15, 0, r0, c12, c0, 0 /* Set VBAR */ bx lrENDPROC(relocate_vectors) 执行c_runtime_cpu_setup 函数，此代码在arch/arm/cpu/armv7/start.S 中，作用是关闭指令cache 执行清除BSS段的汇编代码 跳转执行到board_init_r()，至此**—main**函数运行结束。 2.6 执行board_init_r函数，开始最后的初始化 board_init_r函数如下，如同board_init_f 函数，主要是遍历了init_sequence_r这样一个函数指针结构提。 void board_init_r(gd_t *new_gd, ulong dest_addr){ if (initcall_run_list(init_sequence_r)) hang(); /* NOTREACHED - run_main_loop() does not return */ hang();} 同样，对于init_sequence_r这样一个函数指针数据，我们分析其条件条件编译之后的参数项 init_fnc_t init_sequence_r[] = { initr_trace, /* 初始化追踪调试内容 */ initr_reloc, /* gd-&gt;flags |= GD_FLG_RELOC | GD_FLG_FULL_MALLOC_INIT; 表示重定位完成 */ /* TODO: could x86/PPC have this also perhaps? */#ifdef CONFIG_ARM initr_caches,/* 使能cache */#endif initr_reloc_global_data, /* 修改重定位之后的 gd 参数 */ initr_barrier, /* I.MX6ULL 来说是空函数 */ initr_malloc, /* 初始化 malloc 的内存空间，一些全局变量参数 */ initr_console_record, /* I.MX6ULL 来说是空函数 */ bootstage_relocate, /* bootstage重定位-但实际未看到*/ initr_bootstage, /* 初始化 bootstage*/#if defined(CONFIG_ARM) || defined(CONFIG_NDS32) board_init, /* Setup chipselects - 片上外设初始化在这里 USB IIC FEC QSPI 等等*/#endif stdio_init_tables, /* 初始化 STDIO */ initr_serial, /* 串行设备初始化 */ initr_announce, INIT_FUNC_WATCHDOG_RESET power_init_board, /* 电源初始化- imx6ull 来说是空函数*/#ifdef CONFIG_GENERIC_MMC initr_mmc, /* 初始化mmc */#endif initr_env, /* 环境变量初始化 */ INIT_FUNC_WATCHDOG_RESET initr_secondary_cpu, /* 多核初始化,I.MX6ULL 来说是空函数 */ stdio_add_devices, /* 各种输入输出外设初始化 */ initr_jumptable, /* 初始化跳转表 */ console_init_r, /* 人机交互控制台初始化 */ interrupt_init, /* 中断堆栈初始化 */#if defined(CONFIG_ARM) || defined(CONFIG_AVR32) initr_enable_interrupts, /* 中断使能 */#endif #ifdef CONFIG_CMD_NET initr_ethaddr, /* 获取环境变量“ethaddr” 来初始化MAC的值 */#endif#ifdef CONFIG_BOARD_LATE_INIT board_late_init, /* 后续初始化，如果环境变量需要存储在EMMC/SD 中的话， 会初始化EMMC,并且调用了 cmd 接口*/#endif#ifdef CONFIG_CMD_NET INIT_FUNC_WATCHDOG_RESET initr_net, /* 网口初始化 */#endif imx6_light_up_led2, run_main_loop, /* uboot 的主命令循环 */}; 由上注释可见，调用board_init_r函数更多的是板级初始化的设置，让整个SOC板子和外设能够正常的运行起来，进入到main_loop 的函数。 3. 整体函数调用框架 graph LRa[reset]--&gt;|set scv mode|cpu_init_cp15a--&gt;cpu_init_crit--&gt;lowlevel_init--&gt;s_inita--&gt;b[_main]b--&gt;board_init_f_alloc_reserveb--&gt;board_init_f_init_reserveb--&gt;board_init_f--&gt;initcall_run_list-init_sequence_fb--&gt;relocate_codeb--&gt;relocate_vectorsb--&gt;|bss-init|c_runtime_cpu_setupb--&gt;board_init_r 有了整体框架之后我们依次简短的介绍下各个函数的作用 cpu_init_cp15：在进入SVC 模式之后，关闭各种Cache、MMU，读取CPU variant + revisionCPU 信息。 cpu_init_crit：第一次初始化 SP 在CPU内部的SRAM中。并且给结构体数组gd_date留出空间，把gd_data的指针赋值给r9，后面可以直接通过r9寄存器调用gd。（sram内部）然后调用s_init了。 board_init_f_alloc_reserve：在_main 函数中会重新设定sp的值为CONFIG_SYS_INIT_SP_ADDR，在此函数中会在sram中留出malloc 和 global_data的空间 board_init_f_init_reserve：把global_data 的空间清0，并且设定malloc 的空间起始地址。为执行C语言的环境做准备。 board_init_f：调用initcall_run_list(init_sequence_f)函数来初步板级初始化（CPU特性、时钟、环境变量、串行显示等）和对内存的划分（boot 使用的内存空间、global_date、relocate、mmu_TLB、ENV）信息的存储。 relocate_code &amp; relocate_vectors：代码和中断向量的重定位 board_init_r：调用initcall_run_list(init_sequence_r)函数来进一步初始化板级外设、设置和开启中断，最后进入run_main_loop函数等待执行命令。","link":"/2024/06/06/uboot&linux/uboot_1/"},{"title":"","text":"从头理清uboot（1）-makefile 分析 1.简单介绍及背景 2. makefile分析 2.1 执行make mx6ull_14x14_ddr512_emmc_defconfig 之后会发生什么？ 2.2 对于实际命令的进一步分析 2.3 生成.config 之后的编译流程 make -j12 [toc] 1.简单介绍及背景 u-boot 的作用及背景：初始化外设、下载代码、搬运执行、boot kernel。（这个有很多解释了，就不再过多解释了^ - ^） 2. makefile分析 2.1 执行make mx6ull_14x14_ddr512_emmc_defconfig 之后会发生什么？ 在uboot的编译中，我们会先利用make mx6ull_14x14_ddr512_emmc_defconfig类似指令去生成一个默认的.config文件，之后uboot 会根据这个.config文件编译成uboot.bin。 执行这个命令，在顶层makefile中会有下面这个规则和其匹配，可以看出其依赖于scripts_basic outputmakefile FORCE 这三个变量。 %config: scripts_basic outputmakefile FORCE $(Q)$(MAKE) $(build)=scripts/kconfig $@ 其中需要处理的变量分别如下： 1. scripts_basic : scripts_basic: $(Q)$(MAKE) $(build)=scripts/basic $(Q)rm -f .tmp_quiet_recordmcount ​ 分析其中几个变量的初始化值： $(Q)在开头有如下定义，其中$(origin V)是判断V 的来源是不是输入的command line。在编译config 的时候，我们没有定义v于是KBUILD_VERBOSE =0进而quiet 和Q 都不是空 会有什么影响：在makefile中 @ 和 quiet_ 都是用于抑制输出。加载命令行前就不会输出对应的makefile命令行 ifeq (&quot;$(origin V)&quot;, &quot;command line&quot;) KBUILD_VERBOSE = $(V)endififndef KBUILD_VERBOSE KBUILD_VERBOSE = 0endififeq ($(KBUILD_VERBOSE),1) quiet = Q =else quiet=quiet_ Q = @endif $(make) 一般为对应的make 指令,为make 或者gmake. $(build) buiild 在顶层makefile 没有被调用，在scripts/Kbuild.include的文件中有定义如下： #### Shorthand for $(Q)$(MAKE) -f scripts/Makefile.build obj=# Usage:# $(Q)$(MAKE) $(build)=dirbuild := -f $(srctree)/scripts/Makefile.build obj 那么有以下问题： 怎么会包含这个Kbuild.include？ R: 因为主makefile 包含了这个文件：include scripts/Kbuild.include。 $(srctree)的值是多少？R:见下面的makefile语法，由于变量KBUILD_SRC没有被定义，所以srctree := .，其中:= 表示立即赋值，在尽显赋值时机会被计算展开，否则采用=时，只会在使用时展开。 ifeq ($(KBUILD_SRC),) # building in the source tree srctree := . else ifeq ($(KBUILD_SRC)/,$(dir $(CURDIR))) # building in a subdirectory of the source tree srctree := .. else srctree := $(KBUILD_SRC) endifendif 由此我们可以 知道：build := -f ./scripts/Makefile.build obj 由此我们可以知道scripts_basic的最后定义为： scripts_basic: @make -f ./scripts/Makefile.build obj=scripts/basic @rm -f .tmp_quiet_recordmcount 2. outputmakefile 由于变量KBUILD_SRC 没有定义，所以此项为空。 outputmakefile:ifneq ($(KBUILD_SRC),) $(Q)ln -fsn $(srctree) source $(Q)$(CONFIG_SHELL) $(srctree)/scripts/mkmakefile \\ $(srctree) $(objtree) $(VERSION) $(PATCHLEVEL)endif 3.FORCE FORCE 的值为常空，由此，FORCE是没有依赖的，每次重新编译，都会更新，由此所有依赖FORCE的编译选项也都会重新更新。 PHONY += FORCEFORCE: 经过上面三点的分析，我们回溯一下，makefile 实际上执行了这两个步骤： scripts_basic: @make -f ./scripts/Makefile.build obj=scripts/basic %config: scripts_basic outputmakefile FORCE @make -f ./scripts/Makefile.build obj=scripts/kconfig \\ mx6ull_14x14_ddr512_emmc_defconfig# 在makefile 中 $@ 会被替换为当前正在构建的目标的名称 2.2 对于实际命令的进一步分析 由上文的命令分析可知，其实最后就是分析上面两条命令，由此分别分析如下： 1) @make -f ./scripts/Makefile.build obj=scripts/basic 同上，根据makefile的执行规则，由于我们没有指定目标文件，所以在./scripts/Makefile.build中会执行默认的第一个makefile目标： __build: $(if $(KBUILD_BUILTIN),$(builtin-target) $(lib-target) $(extra-y)) \\ $(if $(KBUILD_MODULES),$(obj-m) $(modorder-target)) \\ $(subdir-ym) $(always) @: # 由于在顶层makefile中有以下定义：KBUILD_MODULES :=KBUILD_BUILTIN := 1 所以上诉依赖可以转化为： __build: $(builtin-target) $(lib-target) $(extra-y) $(subdir-ym) $(always) 这里我们不再继续分析，采用打印的方式： # 添加内容： @: @echo builtin-target = $(builtin-target) @echo lib-target = $(lib-target) @echo extra-y = $(extra-y) @echo subdir-ym = $(subdir-ym) @echo always = $(always)#得到结果builtin-target =lib-target =extra-y =subdir-ym =always = scripts/basic/fixdep 所以可知，执行上述命令后，会生成scripts/basic/fixdep 这个可执行文件。 查阅相关资料，得到下面结果：fixdep 在 U-Boot 构建系统中的作用是解析和处理头文件的依赖关系，确保 Makefile 能正确地跟踪文件之间的依赖性，从而保证编译结果的一致性和正确性。 2) @make -f ./scripts/Makefile.build obj=scripts/kconfig \\ mx6ull_14x14_ddr512_emmc_defconfig 和第一条编译指令不同，此make 指令含有编译目标文件mx6ull_14x14_ddr512_emmc_defconfig，且makefile.build 中没有对应目标项，自上向下分析./scripts/Makefile.build有以下： # Modified for U-Bootprefix := tplsrc := $(patsubst $(prefix)/%,%,$(obj))ifeq ($(obj),$(src))prefix := splsrc := $(patsubst $(prefix)/%,%,$(obj))ifeq ($(obj),$(src))prefix := .endifendif 其中$(patsubst pattern,replacement,src )是makefile 的官方函数，就是从 src 中判断没有没pattern 有的话 就替换为replacement。所以上面的makefile 是判断$(obj) 是不是分别在tpl/ 和spl/ 目录下，如果是的，就把src替换掉，prefix 赋值为tpl 或者spl。 对于我们的make 指令肯定不是，由此有： src := scripts/kconfigprefix := . 发现makefile会包含下面的文件 # The filename Kbuild has precedence over Makefilekbuild-dir := $(if $(filter /%,$(src)),$(src),$(srctree)/$(src))kbuild-file := $(if $(wildcard $(kbuild-dir)/Kbuild),$(kbuild-dir)/Kbuild,$(kbuild-dir)/Makefile)include $(kbuild-file) 其中我们可以知道： kbuild-dir := ./scripts/kconfig# 因为./scripts/kconfig/Kbuild 不存在，kbuild-file := ./scripts/kconfig/Makefileinclude ./scripts/kconfig/Makefile 同时在 ./scripts/kconfig/Makefile中下面对应的目标项内容： %_defconfig: $(obj)/conf $(Q)$&lt; $(silent) --defconfig=arch/$(SRCARCH)/configs/$@ $(Kconfig) # 可以转化为下面的方式：%_defconfig: scripts/kconfig/conf @$&lt; -S --defconfig=arch/../configs/mx6ull_14x14_ddr512_emmc_defconfig Kconfig 逐步分析其中用到的参数： $(Q) 以前聊过，根据命令行中是否有V @ or 空 $(silent) 根据以下的输入为空 或者-s(静默模式) ifeq ($(quiet),silent_)silent := -sendif $&lt; 表示第一个依赖文件，$@ 表示目标文件 $(SRCARCH) 的值是… 这个搜索一下就能找到SRCARCH := .. $(Kconfig) 的值为 Kconfig ifdef KBUILD_KCONFIGKconfig := $(KBUILD_KCONFIG)elseKconfig := Kconfigendif 综上对于命令再一次解析： # 可以转化为下面的方式：%_defconfig: scripts/kconfig/conf @$&lt; -S --defconfig=arch/../configs/mx6ull_14x14_ddr512_emmc_defconfig就是：@scripts/kconfig/conf -S --defconfig=arch/../configs/mx6ull_14x14_ddr512_emmc_defconfig Kconfig 这行命令中的 $&lt; 是一个自动变量，用于表示规则的第一个依赖文件，也就是 conf 脚本本身的文件路径。在这个命令中，$&lt; 被用作脚本的输入文件。 整个命令的含义是运行 scripts/kconfig/conf 脚本，并指定一些选项： -S 选项告诉脚本只生成配置文件，而不进行任何交互式配置。 --defconfig=arch/../configs/mx6ull_14x14_ddr512_emmc_defconfig 选项指定了一个默认的配置文件，这个配置文件将被用作输入。 因此，该命令的目的是使用给定的默认配置文件运行 Kconfig 配置脚本，生成配置文件而不进行交互式配置。 结论 执行上述的命令最后结果是能够调用scripts/kconfig/conf去处理我们定义好的arch/../configs/mx6ull_14x14_ddr512_emmc_defconfig文件，最后会生成一个.conifg 文件，被uboot 编译使用。 2.3 生成.config 之后的编译流程 make -j12 由于没有直接的目标文件，就会编译下面的文件 # That's our default target when none is given on the command linePHONY := _all_all:#而 _all 又依赖于 all:ifeq ($(KBUILD_EXTMOD),)_all: allelse_all: modulesendif# 之后会依赖这个文件$(ALL-y) all: $(ALL-y)ifneq ($(CONFIG_SYS_GENERIC_BOARD),y) @echo &quot;===================== WARNING ======================&quot; @echo &quot;Please convert this board to generic board.&quot; @echo &quot;Otherwise it will be removed by the end of 2014.&quot; @echo &quot;See doc/README.generic-board for further information&quot; @echo &quot;====================================================&quot;endififeq ($(CONFIG_DM_I2C_COMPAT),y) @echo &quot;===================== WARNING ======================&quot; @echo &quot;This board uses CONFIG_DM_I2C_COMPAT. Please remove&quot; @echo &quot;(possibly in a subsequent patch in your series)&quot; @echo &quot;before sending patches to the mailing list.&quot; @echo &quot;====================================================&quot;endif 对于不同的.config中的配置选项，$(all-y)会有下面的不同内容 # Always append ALL so that arch config.mk's can add custom onesALL-y += u-boot.srec u-boot.bin u-boot.sym System.map u-boot.cfg binary_size_checkALL-$(CONFIG_ONENAND_U_BOOT) += u-boot-onenand.bin ... ... ...# Add optional build target if defined in board/cpu/soc headersifneq ($(CONFIG_BUILD_TARGET),)ALL-y += $(CONFIG_BUILD_TARGET:&quot;%&quot;=%)endif 其中的处理方式都相同，如果在.config 定义了某一项的话,all-y就需要加上这一项。 例如 CONFIG_ONENAND_U_BOOT=y的话ALL-$(CONFIG_ONENAND_U_BOOT) += u-boot-onenand.bin就变成了ALL-y += u-boot-onenand.bin，就会产生新的依赖。 1） 对于u-boot.bin的分析 ifeq ($(CONFIG_OF_SEPARATE),y) # 不成立u-boot-dtb.bin: u-boot-nodtb.bin dts/dt.dtb FORCE $(call if_changed,cat)u-boot.bin: u-boot-dtb.bin FORCE $(call if_changed,copy)elseu-boot.bin: u-boot-nodtb.bin FORCE #依赖于这个，没有dtb $(call if_changed,copy)endif### 会继续依赖这个u-boot-nodtb.bin: u-boot FORCE $(call if_changed,objcopy) $(call DO_STATIC_RELA,$&lt;,$@,$(CONFIG_SYS_TEXT_BASE)) $(BOARD_SIZE_CHECK) 其中$(call if_changed,copy) 其中$(call ...)是用于调用自定义函数的接口。 # Execute command if command has changed or prerequisite(s) are updated.#if_changed = $(if $(strip $(any-prereq) $(arg-check)), \\ @set -e; \\ $(echo-cmd) $(cmd_$(1)); \\ printf '%s\\n' 'cmd_$@ := $(make-cmd)' &gt; $(dot-target).cmd) 这里面涉及到函数的处理流程，大意是实现copy的函数。从log 中可以看到下方log ，即就是单纯的copy u-boot-nodtb.bin。 cp u-boot-nodtb.bin u-boot.bin 2）对于 u-boot-nodtb.bin的分析 通过log 可以看出，依赖于uboot，并且是通过obj-ccopy 指令生成的： arm-linux-gnueabihf-objcopy --gap-fill=0xff -j .text -j .secure_text -j .rodata -j .hash -j .data -j .got -j .got.plt -j .u_boot_list -j .rel.dyn -O binary u-boot u-boot-nodtb.bin 由上可知，这是通过提取u-boot 的各个section 生成的。 3）对于u-boot的分析： 根据log 可以看出使用的link 文件和依赖的.o 文件 arm-linux-gnueabihf-ld.bfd -pie --gc-sections -Bstatic -Ttext 0x87800000 -o u-boot -T u-boot.lds arch/arm/cpu/armv7/start.o --start-group arch/arm/cpu/built-in.o arch/arm/cpu/armv7/built-in.o arch/arm/imx-common/built-in.o arch/arm/lib/built-in.o board/freescale/common/built-in.o board/freescale/mx6ullevk/built-in.o cmd/built-in.o common/built-in.o disk/built-in.o drivers/built-in.o drivers/dma/built-in.o drivers/gpio/built-in.o drivers/i2c/built-in.o drivers/mmc/built-in.o drivers/mtd/built-in.o drivers/mtd/onenand/built-in.o drivers/mtd/spi/built-in.o drivers/net/built-in.o drivers/net/phy/built-in.o drivers/pci/built-in.o drivers/power/built-in.o drivers/power/battery/built-in.o drivers/power/fuel_gauge/built-in.o drivers/power/mfd/built-in.o drivers/power/pmic/built-in.o drivers/power/regulator/built-in.o drivers/serial/built-in.o drivers/spi/built-in.o drivers/usb/dwc3/built-in.o drivers/usb/emul/built-in.o drivers/usb/eth/built-in.o drivers/usb/gadget/built-in.o drivers/usb/gadget/udc/built-in.o drivers/usb/host/built-in.o drivers/usb/musb-new/built-in.o drivers/usb/musb/built-in.o drivers/usb/phy/built-in.o drivers/usb/ulpi/built-in.o fs/built-in.o lib/built-in.o net/built-in.o test/built-in.o test/dm/built-in.o --end-group arch/arm/lib/eabi_compat.o -L /usr/lib/gcc-cross/arm-linux-gnueabihf/9 -lgcc -Map u-boot.map 从makefile 角度再分析uboot 的生成： u-boot: $(u-boot-init) $(u-boot-main) u-boot.lds FORCE $(call if_changed,u-boot__)ifeq ($(CONFIG_KALLSYMS),y) $(call cmd,smap) $(call cmd,u-boot__) common/system_map.oendif 其中： u-boot-init := $(head-y)u-boot-main := $(libs-y) 其中$(head-y) 在arch/arm/Makefile 中有定义，而$(libs-y) 在顶层Makefile 中有定义： head-y := arch/arm/cpu/$(CPU)/start.o #即为：head-y := arch/arm/cpu/armv7/start.o libs-y += lib/libs-$(HAVE_VENDOR_COMMON_LIB) += board/$(VENDOR)/common/libs-$(CONFIG_OF_EMBED) += dts/libs-y += fs/ ... ...libs-y += $(if $(BOARDDIR),board/$(BOARDDIR)/)libs-y := $(sort $(libs-y))u-boot-dirs := $(patsubst %/,%,$(filter %/, $(libs-y))) tools examplesu-boot-alldirs := $(sort $(u-boot-dirs) $(patsubst %/,%,$(filter %/, $(libs-))))libs-y := $(patsubst %/, %/built-in.o, $(libs-y)) 由上可知，依赖会分别获取 一个架构的启动文件和library 文件，并且在获取libs-y 之后，做一次排序，之后利用$(patsubst %/, %/built-in.o, $(libs-y))将所有的子目录 以/结尾的变成/built-in.o，即将fs/变为fs/built-in.o类似。 对于 XXX/built-in.o通过log 可以看出（一个例子） arm-linux-gnueabihf-ld.bfd -r -o board/freescale/common/built-in.o board/freescale/common/mmc.o 其实是通过连接器，通过重定位+重命名的方式，链接成一个.o文件，上述是将mmc.o 链接成 了built-in.o。 总结 综上，对于Makefile的bin 文件生成有以上关系： graph TBA[XXX/built-in.o]--&gt;B[libs-y//u-boot-main]C[xxx/start.o]--&gt;D[head-y/u-boot-init]B--&gt;|u-boot.lds|e[u-boot]D--&gt;|u-boot.lds|ee--&gt;|arm-linux-gnueabihf-objcopy|f[u-boot-nodtb.bin]f--&gt;|copy|G[u-boot.bin]","link":"/2024/06/06/uboot&linux/makefile_analyse/"},{"title":"","text":"从头理清uboot（4）-boot_cmd 的处理 1. 默认的bootcmd 包含了哪些内容？ 1.1 mmcboot 1.2 netboot 1.3 小总结 1.4 关于bootargs 2. boot-linux 函数过程 2.1 结构体简单介绍 2.2 do_bootz函数分析 2.2.2 do_bootm_states 函数 2.2.3 do_bootm_linux函数 2.2.4 boot_jump_linux函数 3. 一些指令是如何实现的? [toc] 上次我们分析到，uboot在启动linux的过程中，最后是执行bootcmd这个环境变量，那么我们今天来分析，这个环境变量到底执行了哪些功能，这些功能调用了哪些函数，最后是如何实现linux的boot的？ ==关于环境变量：==对于imax6ull来说，都是存储在/include/configs/mx6ullevk.h和include/env_dedault.h 1. 默认的bootcmd 包含了哪些内容？ 在default_environment中有定义：于是查找CONFIG_BOOTCOMMAND #ifdef CONFIG_BOOTCOMMAND &quot;bootcmd=&quot; CONFIG_BOOTCOMMAND &quot;\\0&quot;#endif 在./include/configs/mx6ullevk.h中有定义： #define CONFIG_BOOTCOMMAND \\ &quot;run findfdt;&quot; \\ &quot;mmc dev ${mmcdev};&quot; \\ &quot;mmc dev ${mmcdev}; if mmc rescan; then &quot; \\ &quot;if run loadbootscript; then &quot; \\ &quot;run bootscript; &quot; \\ &quot;else &quot; \\ &quot;if run loadimage; then &quot; \\ &quot;run mmcboot; &quot; \\ &quot;else run netboot; &quot; \\ &quot;fi; &quot; \\ &quot;fi; &quot; \\ &quot;else run netboot; fi&quot;#endif 其中,有以下环境变量： findfdt：其中会用到fdt_file=undefined，board_name=EVK，board_rev=14X14 这三个变量，用于寻找.dtb 文件 &quot;findfdt=&quot;\\ &quot;if test $fdt_file = undefined; then &quot; \\ &quot;if test $board_name = EVK &amp;&amp; test $board_rev = 9X9; then &quot; \\ &quot;setenv fdt_file imx6ull-9x9-evk.dtb; fi; &quot; \\ &quot;if test $board_name = EVK &amp;&amp; test $board_rev = 14X14; then &quot; \\ &quot;setenv fdt_file imx6ull-14x14-evk.dtb; fi; &quot; \\ &quot;if test $fdt_file = undefined; then &quot; \\ &quot;echo WARNING: Could not determine dtb to use; fi; &quot; \\ &quot;fi;\\0&quot; \\ mmc dev ${mmcdev} : 用于切换mmc 设置mmc 设备 mmc rescan ：执行mmc 扫描检查，成功执行run loadbootscript失败就执行run netboot网络boot。 run loadbootscript ： &quot;loadbootscript=&quot; \\ &quot;fatload mmc ${mmcdev}:${mmcpart} ${loadaddr} ${script};\\0&quot; \\ 其中 mmcdev=1，mmcpart=1，loadaddr=0x80800000，script= boot.scr因此展开之后为下面指令，就是从 mmc1 的分区 1 中读取文件 boot.src 到 DRAM 的 0X80800000 处，如果成功的话就执行bootscript不行就会执行run loadimage loadbootscript=fatload mmc 1:1 0x80800000 boot.scr; bootscript：只是一个输出语句 &quot;bootscript=echo Running bootscript from mmc ...; &quot; \\ run loadimage：见下方注释为从mmc 加载zImage到0x80800000地址处。 &quot;loadimage=fatload mmc ${mmcdev}:${mmcpart} ${loadaddr} ${image}\\0&quot; \\ /* 其中： mmcdev=1、mmcpart=1 loadaddr=0x80800000、image = zImage 所以展开之后就是：*/ loadimage=fatload mmc 1:1 0x80800000 zImage 1.1 mmcboot mmcboot 的源码如下： &quot;mmcboot=echo Booting from mmc ...; &quot; \\ &quot;run mmcargs; &quot; \\ &quot;if test ${boot_fdt} = yes || test ${boot_fdt} = try; then &quot; \\ &quot;if run loadfdt; then &quot; \\ &quot;bootz ${loadaddr} - ${fdt_addr}; &quot; \\ &quot;else &quot; \\ &quot;if test ${boot_fdt} = try; then &quot; \\ &quot;bootz; &quot; \\ &quot;else &quot; \\ &quot;echo WARN: Cannot load the DT; &quot; \\ &quot;fi; &quot; \\ &quot;fi; &quot; \\ &quot;else &quot; \\ &quot;bootz; &quot; \\ &quot;fi;\\0&quot; \\ 其中第一行是设置boot 参数 &quot;mmcargs=setenv bootargs console=${console},${baudrate} &quot; \\CONFIG_BOOTARGS_CMA_SIZE \\ CONFIG_MFG_NAND_PARTITION \\ &quot;root=${mmcroot}\\0&quot; \\ /*&quot;console=ttymxc&quot; baudrate=115200 mmcroot=&quot;/dev/mmcblk1p2&quot;rootwait rw */ 所以这句话为：mmcargs=setenv bootargs console=ttymxc0,115200 &quot;&quot; &quot;&quot; root=/dev/mmcblk1p2 rootwait rw 由于&quot;boot_fdt=try\\0&quot; \\所以执行loadfdt,由于fdt_file在之前findfdt时候初始化过了，所以额这里就是load dtb 文件到0x83000000。 &quot;loadfdt=fatload mmc ${mmcdev}:${mmcpart} ${fdt_addr} ${fdt_file}\\0&quot; \\ /* mmcdev=1、mmcpart=1 fdt_addr=0x83000000 、fdt_file= imx6ull-14x14-evk.dtb \\0 */ fatload mmc 1:1 0x83000000 imx6ull-14x14-evk.dtb * 于是` run loadfdt`执行成功，就会执行指令： ```c bootz ${loadaddr} - ${fdt_addr}; /* loadaddr = 0x80800000 fdt_addr=0x83000000*/ bootz 0x80800000 - 0x83000000 1.2 netboot &quot;netboot=echo Booting from net ...; &quot; \\&quot;run netargs; &quot; \\&quot;if test ${ip_dyn} = yes; then &quot; \\ &quot;setenv get_cmd dhcp; &quot; \\&quot;else &quot; \\ &quot;setenv get_cmd tftp; &quot; \\&quot;fi; &quot; \\&quot;${get_cmd} ${image}; &quot; \\&quot;if test ${boot_fdt} = yes || test ${boot_fdt} = try; then &quot; \\ &quot;if ${get_cmd} ${fdt_addr} ${fdt_file}; then &quot; \\ &quot;bootz ${loadaddr} - ${fdt_addr}; &quot; \\ &quot;else &quot; \\ &quot;if test ${boot_fdt} = try; then &quot; \\ &quot;bootz; &quot; \\ &quot;else &quot; \\ &quot;echo WARN: Cannot load the DT; &quot; \\ &quot;fi; &quot; \\ &quot;fi; &quot; \\&quot;else &quot; \\ &quot;bootz; &quot; \\&quot;fi;\\0&quot; \\ 1.3 小总结 对于mmc_boot有效的信息如下： 给findfdt赋值，设置dtb文件：setenv fdt_file imx6ull-14x14-evk.dtb 设置mmc 设备: mmc dev 1 加载镜像：fatload mmc 1:1 0x80800000 zImage 设置bootargs：setenv bootargs console=ttymxc0,115200 &quot;&quot; &quot;&quot; root=/dev/mmcblk1p2 rootwait rw 加载dtb：fatload mmc 1:1 0x83000000 imx6ull-14x14-evk.dtb 启动：bootz 0x80800000 - 0x83000000 1.4 关于bootargs bootargs 是uboot 传递给linux 中的参数，上述解析之后的参数见下方： mmcargs=setenv bootargs console=ttymxc0,115200 &quot;&quot; &quot;&quot; root=/dev/mmcblk1p2 rootwait rw 其中有三个设置点： console ：设置Linux的输出窗口，由于mx6ull中，串口0的表示是/dev/ttymxc0所以设置输出窗口为这个。 root ：设置根文件系统的位置，告诉Linux在哪里寻找根文件系统。/dev/mmcblk1p2 表示在ima6ull的分区2中。后续还有“rootwait rw”数据，表示等待根文件系统挂载完毕才加载，rw表示文件系统是可读写的。 2. boot-linux 函数过程 ​ 上面分析到，在把image和dtb 搬运到固定地址之后，执行bootz 0x80800000 - 0x83000000指令，进入linux 的boot 阶段。bootz指令的定义如下，于是可以发现是执行do_bootz函数。 U_BOOT_CMD( bootz, CONFIG_SYS_MAXARGS, 1, do_bootz, &quot;boot Linux zImage image from memory&quot;, bootz_help_text); 2.1 结构体简单介绍 uboot 中 定义了bootm_headers_t和image_header_t结构体分别用来抽象image 信息和 image 头部信息。 typedef struct bootm_headers { /* * Legacy os image header, if it is a multi component image * then boot_get_ramdisk() and get_fdt() will attempt to get * data from second and third component accordingly. */ image_header_t *legacy_hdr_os; /* image header pointer */ image_header_t legacy_hdr_os_copy; /* header copy */ ulong legacy_hdr_valid; #ifndef USE_HOSTCC image_info_t os; /* os image info */ ulong ep; /* entry point of OS */ ulong rd_start, rd_end;/* ramdisk start/end */ char *ft_addr; /* flat dev tree address */ ulong ft_len; /* length of flat device tree */ ulong initrd_start; ulong initrd_end; ulong cmdline_start; ulong cmdline_end; bd_t *kbd;#endif int verify; /* getenv(&quot;verify&quot;)[0] != 'n' */#define BOOTM_STATE_START (0x00000001)#define BOOTM_STATE_FINDOS (0x00000002)#define BOOTM_STATE_FINDOTHER (0x00000004)#define BOOTM_STATE_LOADOS (0x00000008)#define BOOTM_STATE_RAMDISK (0x00000010)#define BOOTM_STATE_FDT (0x00000020)#define BOOTM_STATE_OS_CMDLINE (0x00000040)#define BOOTM_STATE_OS_BD_T (0x00000080)#define BOOTM_STATE_OS_PREP (0x00000100)#define BOOTM_STATE_OS_FAKE_GO (0x00000200) /* 'Almost' run the OS */#define BOOTM_STATE_OS_GO (0x00000400) int state;#ifdef CONFIG_LMB struct lmb lmb; /* for memory mgmt */#endif} bootm_headers_t;extern bootm_headers_t images;/* 其中，header 再定义为： */ typedef struct image_header { __be32 ih_magic; /* Image Header Magic Number */ __be32 ih_hcrc; /* Image Header CRC Checksum */ __be32 ih_time; /* Image Creation Timestamp */ __be32 ih_size; /* Image Data Size */ __be32 ih_load; /* Data Load Address */ __be32 ih_ep; /* Entry Point Address */ __be32 ih_dcrc; /* Image Data CRC Checksum */ uint8_t ih_os; /* Operating System */ uint8_t ih_arch; /* CPU architecture */ uint8_t ih_type; /* Image Type */ uint8_t ih_comp; /* Compression Type */ uint8_t ih_name[IH_NMLEN]; /* Image Name */} image_header_t; 2.2 do_bootz函数分析 ​ do_bootz会调用bootz_start准备好环境之后，关闭中断，在设置要启动的系统是IH_OS_LINUX之后，就会利用do_bootm_states函数启动linux。源码如下： int do_bootz(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[]){ int ret; /* Consume 'bootz' 过滤掉bootz 参数，这样子addr= argv[0] */ argc--; argv++; if (bootz_start(cmdtp, flag, argc, argv, &amp;images)) return 1; bootm_disable_interrupts(); images.os.os = IH_OS_LINUX; ret = do_bootm_states(cmdtp, flag, argc, argv, BOOTM_STATE_OS_PREP | BOOTM_STATE_OS_FAKE_GO | BOOTM_STATE_OS_GO, &amp;images, 1); return ret;} 2.2.1 bootz_start 函数 见下方，bootz_start的主要功能为： 调用 do_bootm_states,且把状态设置为 BOOTM_STATE_START 准备环境，释放原来images占用的区域。 设置images-&gt;ep这个地址是image 的启动地址（entry-point）。 把images-&gt;ep头部指针传递给bootz_setup,在里面会做是否是linux 系统image 的判定，并且获得起始和结束位置，如果不是的话会报错，给image 指针重定位。 调用lmb_reserve将image 占用的内存大小和区域设置为已经使用的区域。 调用bootm_find_images去找到dtb 文件，并且将地址和长度信息，存储到全局变量images中。 做完以上之后，就会调用do_bootm_states,并且设置对应状态 启动inux。 static int bootz_start(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[], bootm_headers_t *images){ int ret; ulong zi_start, zi_end; ret = do_bootm_states(cmdtp, flag, argc, argv, BOOTM_STATE_START, images, 1); /* */ /* Setup Linux kernel zImage entry point */ if (!argc) { images-&gt;ep = load_addr; debug(&quot;* kernel: default image load address = 0x%08lx\\n&quot;, load_addr); } else { images-&gt;ep = simple_strtoul(argv[0], NULL, 16); debug(&quot;* kernel: cmdline image address = 0x%08lx\\n&quot;, images-&gt;ep); } ret = bootz_setup(images-&gt;ep, &amp;zi_start, &amp;zi_end); if (ret != 0) return 1; lmb_reserve(&amp;images-&gt;lmb, images-&gt;ep, zi_end - zi_start); if (bootm_find_images(flag, argc, argv)) return 1; return 0;} 2.2.2 do_bootm_states 函数 do_bootm_states 能够根据不同的状态执行不同的函数，在imax6ull 中，起到了下面这些作用： 调用bootm_start函数，释放原来images指向的区域并清0。 调用bootm_load_os函数，设置对应的地址。 ==调用bootm_os_get_boot_func函数:==找到boot 中真正使用的函数。本次boot 的os 在之前已经设置过了为IH_OS_LINUX于是会调用do_bootm_linux。后面执行的boot_fn(BOOTM_STATE_OS_CMDLINE, argc, argv, images);函数实际上都是由do_bootm_linux函数执行。 int do_bootm_states(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[], int states, bootm_headers_t *images, int boot_progress){ boot_os_fn *boot_fn; ulong iflag = 0; int ret = 0, need_boot_fn; images-&gt;state |= states; /* * Work through the states and see how far we get. We stop on * any error. */ if (states &amp; BOOTM_STATE_START) ret = bootm_start(cmdtp, flag, argc, argv); if (!ret &amp;&amp; (states &amp; BOOTM_STATE_FINDOS)) ret = bootm_find_os(cmdtp, flag, argc, argv); if (!ret &amp;&amp; (states &amp; BOOTM_STATE_FINDOTHER)) { ret = bootm_find_other(cmdtp, flag, argc, argv); argc = 0; /* consume the args */ } ...... boot_fn = bootm_os_get_boot_func(images-&gt;os.os); need_boot_fn = states &amp; (BOOTM_STATE_OS_CMDLINE | BOOTM_STATE_OS_BD_T | BOOTM_STATE_OS_PREP | BOOTM_STATE_OS_FAKE_GO | BOOTM_STATE_OS_GO); ...... /* 这里实际执行的都是do_bootm_linux 函数了！ */ /* Call various other states that are not generally used */ if (!ret &amp;&amp; (states &amp; BOOTM_STATE_OS_CMDLINE)) ret = boot_fn(BOOTM_STATE_OS_CMDLINE, argc, argv, images); if (!ret &amp;&amp; (states &amp; BOOTM_STATE_OS_BD_T)) ret = boot_fn(BOOTM_STATE_OS_BD_T, argc, argv, images); if (!ret &amp;&amp; (states &amp; BOOTM_STATE_OS_PREP)) ret = boot_fn(BOOTM_STATE_OS_PREP, argc, argv, images); ...... /* Now run the OS! We hope this doesn't return */ if (!ret &amp;&amp; (states &amp; BOOTM_STATE_OS_GO)) ret = boot_selected_os(argc, argv, BOOTM_STATE_OS_GO, images, boot_fn);} 2.2.3 do_bootm_linux函数 上面说到，在本次启动过程中，最后实际调用的是do_bootm_linux于是再继续分析这个函数。 我们在do_bootz的时候，实际调用的是这调用整个宏BOOTM_STATE_OS_PREP ，会调用boot_prep_linux(images); 这个函数进行启动前的准备。 int do_bootm_linux(int flag, int argc, char * const argv[], bootm_headers_t *images){ /* No need for those on ARM */ if (flag &amp; BOOTM_STATE_OS_BD_T || flag &amp; BOOTM_STATE_OS_CMDLINE) return -1; if (flag &amp; BOOTM_STATE_OS_PREP) { boot_prep_linux(images); return 0; } if (flag &amp; (BOOTM_STATE_OS_GO | BOOTM_STATE_OS_FAKE_GO)) { boot_jump_linux(images, flag); return 0; } boot_prep_linux(images); boot_jump_linux(images, flag); return 0;} 后面do_bootz会调用boot_selected_os函数，之后继续调用do_bootm_linux并且将flag 设置为BOOTM_STATE_OS_GO，执行boot_jump_linux(images, flag); boot_selected_os(argc, argv, BOOTM_STATE_OS_GO, images, boot_fn);/* 实际还是调用了 boot_fn(state, argc, argv, images); *//* 在bootlinux 的情况下，实际执行的是：do_bootm_linux*/ do_bootm_linux (BOOTM_STATE_OS_GO,argc,argv，images) 2.2.4 boot_jump_linux函数 可见boot_jump_linux的作用如下： 定义函数指针并且赋值为images-&gt;ep,作为程序跳转到linux 的入口。 获取id值和环境变量machid比较，判断是否相等。 清除CPU的cache 环境。 设置函数指针kernel_entry的参数，分别是0、machid、fdt地址/或者bi_boot_params。如果不使用设备数的话，就是bootargs /* Subcommand: GO */static void boot_jump_linux(bootm_headers_t *images, int flag){ unsigned long machid = gd-&gt;bd-&gt;bi_arch_number; char *s; void (*kernel_entry)(int zero, int arch, uint params);/* 定义函数指针 */ unsigned long r2; int fake = (flag &amp; BOOTM_STATE_OS_FAKE_GO); kernel_entry = (void (*)(int, int, uint))images-&gt;ep; /*给函数指针赋值为*/ s = getenv(&quot;machid&quot;); /* 比较id 是不是和环境变量是相同的 */ if (s) { if (strict_strtoul(s, 16, &amp;machid) &lt; 0) { debug(&quot;strict_strtoul failed!\\n&quot;); return; } printf(&quot;Using machid 0x%lx from environment\\n&quot;, machid); } debug(&quot;## Transferring control to Linux (at address %08lx)&quot; \\ &quot;...\\n&quot;, (ulong) kernel_entry); bootstage_mark(BOOTSTAGE_ID_RUN_OS); announce_and_cleanup(fake); /* CPU clean up,把cache 都刷掉了。 */ if (IMAGE_ENABLE_OF_LIBFDT &amp;&amp; images-&gt;ft_len)/* 把 r2 寄存器设置为ft_addr 或者 bi_boot_params*/ r2 = (unsigned long)images-&gt;ft_addr; else r2 = gd-&gt;bd-&gt;bi_boot_params; if (!fake) {#ifdef CONFIG_ARMV7_NONSEC if (armv7_boot_nonsec()) { armv7_init_nonsec(); secure_ram_addr(_do_nonsec_entry)(kernel_entry, 0, machid, r2); } else#endif kernel_entry(0, machid, r2); }#endif} 小问题，之前提到的bootargs 是在哪里设定的呢，怎么传递过去的？ 如果不适用fdt的话，参数r2 就是bootargs的值。 3. 一些指令是如何实现的? 由前面分析我们可以知道，uboot 的命令都是由U_BOOT_CMD实现的，所以我们可以在boot 的文件夹下搜索我们关心的命令，例如上面频繁的用到了fatload命令，我们可以搜索如下： :~/for_study/imax6ull/uboot$: grep -nr &quot;U_BOOT_CMD&quot; | grep -n &quot;fat&quot; /* 得到下面结果 */1244:cmd/fat.c:27:U_BOOT_CMD(1245:cmd/fat.c:41:U_BOOT_CMD(1246:cmd/fat.c:61:U_BOOT_CMD(1247:cmd/fat.c:93:U_BOOT_CMD(1248:cmd/fat.c:145:U_BOOT_CMD( 可以发现，是在这些命令都在cmd/fat.c里面，由此可以找到命令的定义和回调函数，具体的实现就需要深入研究源码了。 U_BOOT_CMD( fatload, 7, 0, do_fat_fsload, ...... }","link":"/2024/06/06/uboot&linux/uboot_3/"},{"title":"","text":"uboot 相关的一些备注 https://www.cnblogs.com/liangliangge/p/12549087.html cortex-A7 的中断处理流程 //程序入口_start:#ifdef CONFIG_SYS_DV_NOR_BOOT_CFG .word CONFIG_SYS_DV_NOR_BOOT_CFG#endif b reset //strart 会 直接跳转到reset 地址去 ldr pc, _undefined_instruction //发生异常时，会跳到该指令处，然后执行指令ldr pc, _undefined_instruction ，便会跳转到_undefined_instruction 这个符号地址去了。 ldr pc, _software_interrupt ldr pc, _prefetch_abort ldr pc, _data_abort ldr pc, _not_used ldr pc, _irq ldr pc, _fiq 全局配置的结构体 typedef struct global_data { bd_t *bd; unsigned long flags; unsigned int baudrate; unsigned long cpu_clk; /* CPU clock in Hz! */ unsigned long bus_clk; /* We cannot bracket this with CONFIG_PCI due to mpc5xxx */ unsigned long pci_clk; unsigned long mem_clk;#if defined(CONFIG_LCD) || defined(CONFIG_VIDEO) unsigned long fb_base; /* Base address of framebuffer mem */#endif#if defined(CONFIG_POST) || defined(CONFIG_LOGBUFFER) unsigned long post_log_word; /* Record POST activities */ unsigned long post_log_res; /* success of POST test */ unsigned long post_init_f_time; /* When post_init_f started */#endif#ifdef CONFIG_BOARD_TYPES unsigned long board_type;#endif unsigned long have_console; /* serial_init() was called */#ifdef CONFIG_PRE_CONSOLE_BUFFER unsigned long precon_buf_idx; /* Pre-Console buffer index */#endif unsigned long env_addr; /* Address of Environment struct */ unsigned long env_valid; /* Checksum of Environment valid? */ unsigned long ram_top; /* Top address of RAM used by U-Boot */ unsigned long relocaddr; /* Start address of U-Boot in RAM */ phys_size_t ram_size; /* RAM size */#ifdef CONFIG_SYS_MEM_RESERVE_SECURE#define MEM_RESERVE_SECURE_SECURED 0x1#define MEM_RESERVE_SECURE_MAINTAINED 0x2#define MEM_RESERVE_SECURE_ADDR_MASK (~0x3) /* * Secure memory addr * This variable needs maintenance if the RAM base is not zero, * or if RAM splits into non-consecutive banks. It also has a * flag indicating the secure memory is marked as secure by MMU. * Flags used: 0x1 secured * 0x2 maintained */ phys_addr_t secure_ram;#endif unsigned long mon_len; /* monitor len */ unsigned long irq_sp; /* irq stack pointer */ unsigned long start_addr_sp; /* start_addr_stackpointer */ unsigned long reloc_off; struct global_data *new_gd; /* relocated global data */#ifdef CONFIG_DM struct udevice *dm_root; /* Root instance for Driver Model */ struct udevice *dm_root_f; /* Pre-relocation root instance */ struct list_head uclass_root; /* Head of core tree */#endif#ifdef CONFIG_TIMER struct udevice *timer; /* Timer instance for Driver Model */#endif const void *fdt_blob; /* Our device tree, NULL if none */ void *new_fdt; /* Relocated FDT */ unsigned long fdt_size; /* Space reserved for relocated FDT */ struct jt_funcs *jt; /* jump table */ char env_buf[32]; /* buffer for getenv() before reloc. */#ifdef CONFIG_TRACE void *trace_buff; /* The trace buffer */#endif#if defined(CONFIG_SYS_I2C) int cur_i2c_bus; /* current used i2c bus */#endif#ifdef CONFIG_SYS_I2C_MXC void *srdata[10];#endif unsigned long timebase_h; unsigned long timebase_l;#ifdef CONFIG_SYS_MALLOC_F_LEN unsigned long malloc_base; /* base address of early malloc() */ unsigned long malloc_limit; /* limit address */ unsigned long malloc_ptr; /* current address */#endif#ifdef CONFIG_PCI struct pci_controller *hose; /* PCI hose for early use */ phys_addr_t pci_ram_top; /* top of region accessible to PCI */#endif#ifdef CONFIG_PCI_BOOTDELAY int pcidelay_done;#endif struct udevice *cur_serial_dev; /* current serial device */ struct arch_global_data arch; /* architecture-specific data */#ifdef CONFIG_CONSOLE_RECORD struct membuff console_out; /* console output */ struct membuff console_in; /* console input */#endif#ifdef CONFIG_DM_VIDEO ulong video_top; /* Top of video frame buffer area */ ulong video_bottom; /* Bottom of video frame buffer area */#endif} gd_t;#endif 这句话 是怎么实现函数指针跳转到对应函数的？-后面有具体实现的，只是clangd没有跳转过去。 typedef int (*init_fnc_t)(void);int initcall_run_list(const init_fnc_t init_sequence[]);int initcall_run_list(const init_fnc_t init_sequence[]){ const init_fnc_t *init_fnc_ptr; for (init_fnc_ptr = init_sequence; *init_fnc_ptr; ++init_fnc_ptr) { unsigned long reloc_ofs = 0; int ret; if (gd-&gt;flags &amp; GD_FLG_RELOC) reloc_ofs = gd-&gt;reloc_off;#ifdef CONFIG_EFI_APP reloc_ofs = (unsigned long)image_base;#endif debug(&quot;initcall: %p&quot;, (char *)*init_fnc_ptr - reloc_ofs); if (gd-&gt;flags &amp; GD_FLG_RELOC) debug(&quot; (relocated to %p)\\n&quot;, (char *)*init_fnc_ptr); else debug(&quot;\\n&quot;); ret = (*init_fnc_ptr)(); if (ret) { printf(&quot;initcall sequence %p failed at call %p (err=%d)\\n&quot;, init_sequence, (char *)*init_fnc_ptr - reloc_ofs, ret); return -1; } } return 0;} uboot 命令分析 #define U_BOOT_CMD_MKENT_COMPLETE(_name, _maxargs, _rep, _cmd, \\ _usage, _help, _comp) \\ { #_name, _maxargs, _rep, _cmd, _usage, \\ _CMD_HELP(_help) _CMD_COMPLETE(_comp) }#define U_BOOT_CMD_MKENT(_name, _maxargs, _rep, _cmd, _usage, _help) \\ U_BOOT_CMD_MKENT_COMPLETE(_name, _maxargs, _rep, _cmd, \\ _usage, _help, NULL)#define U_BOOT_CMD_COMPLETE(_name, _maxargs, _rep, _cmd, _usage, _help, _comp) \\ ll_entry_declare(cmd_tbl_t, _name, cmd) = \\ U_BOOT_CMD_MKENT_COMPLETE(_name, _maxargs, _rep, _cmd, \\ _usage, _help, _comp);#define U_BOOT_CMD(_name, _maxargs, _rep, _cmd, _usage, _help) \\ U_BOOT_CMD_COMPLETE(_name, _maxargs, _rep, _cmd, _usage, _help, NULL) 可以看出有以下几点： U_BOOT_CMD就是U_BOOT_CMD_COMPLETE的宏参数最后一个为NULL U_BOOT_CMD_COMPLETE会继续调用ll_entry_declare和U_BOOT_CMD_MKENT_COMPLETE函数。分别显示如下 #define ll_entry_declare(_type, _name, _list) \\ _type _u_boot_list_2_##_list##_2_##_name __aligned(4) \\ __attribute__((unused, \\ section(&quot;.u_boot_list_2_&quot;#_list&quot;_2_&quot;#_name))) * ```python #define U_BOOT_CMD_MKENT_COMPLETE(_name, _maxargs, _rep, _cmd,\\ _usage, _help, _comp) \\ { #_name, _maxargs, _rep, _cmd, _usage, \\ _CMD_HELP(_help) _CMD_COMPLETE(_comp) } 其中再次调用了_CMD_HELP(_help) _CMD_COMPLETE(_comp)这两部分定义如下(相关宏已经定义了)： #ifdef CONFIG_AUTO_COMPLETE//# define _CMD_COMPLETE(x) x,#else//# define _CMD_COMPLETE(x)//#endif#ifdef CONFIG_SYS_LONGHELP# define _CMD_HELP(x) x,#else//# define _CMD_HELP(x)//#endif 利用一个CMD来分析 U_BOOT_CMD( spibootldr, 2, 0, do_spibootldr, &quot;boot ldr image from spi&quot;, &quot;[offset]\\n&quot; &quot; - boot ldr image stored at offset into spi\\n&quot;); 经过上述的分析，此命令可以被解析为： --ll_entry_declare(_type, _name, _list) -&gt; cmd_tbl_t _u_boot_list_2_spibootldr_2_spibootldr __aligned(4) \\ __attribute__((unused, \\ section(&quot;.u_boot_list_2_do_spibootldr_2_spibootldr)))--{ &quot;spibootldr&quot;, 2, 0, do_spibootldr,&quot; boot ldr image from spi&quot;, \\ &quot;[offset]\\n&quot;&quot;- boot ldr image stored at offset into spi\\n&quot;, NULL, } ## 连接符:表示后面直接链接 # 字符串化：表示将传来的参数字符串化。 所以最后实现的语句如下所示： cmd_tbl_t _u_boot_list_2_spibootldr_2_spibootldr __aligned(4) \\__attribute__((unused, section(&quot;.u_boot_list_2_do_spibootldr_2_spibootldr&quot;))) = { &quot;spibootldr&quot;, 2, 0, do_spibootldr, &quot; boot ldr image from spi&quot;, &quot;[offset]\\n&quot;&quot;- boot ldr image stored at offset into spi\\n&quot;, NULL, } 4字节对齐定义了一个cmd_tbl_t的结构体变量_u_boot_list_2_spibootldr_2_spibootldr，且被划分到了u_boot_list_2_do_spibootldr_2_spibootldr section。 其中对于cmd_tbl_t 有以下定义: struct cmd_tbl_s { char *name; /* Command Name */ int maxargs; /* maximum number of arguments */ int repeatable; /* autorepeat allowed? */ /* Implementation function */ int (*cmd)(struct cmd_tbl_s *, int, int, char * const []); /* 函数指针 */ char *usage; /* Usage message (short) */#ifdef CONFIG_SYS_LONGHELP char *help; /* Help message (long) */#endif#ifdef CONFIG_AUTO_COMPLETE /* do auto completion on the arguments */ int (*complete)(int argc, char * const argv[], char last_char, int maxv, char *cmdv[]);#endif}; section 在内存中的存储位置如下所示：四字节对齐之后存储在rodata 段之后。 .rodata : { *(SORT_BY_ALIGNMENT(SORT_BY_NAME(.rodata*))) }. = ALIGN(4);.data : { *(.data*)}. = ALIGN(4);. = .;. = ALIGN(4);.u_boot_list : { KEEP(*(SORT(.u_boot_list*)));} 对于命令结构体的处理方法如下所示： enum command_ret_t cmd_process(int flag, int argc, char * const argv[], int *repeatable, ulong *ticks){ enum command_ret_t rc = CMD_RET_SUCCESS; cmd_tbl_t *cmdtp; /* Look up command in command table */ cmdtp = find_cmd(argv[0]); if (cmdtp == NULL) { printf(&quot;Unknown command '%s' - try 'help'\\n&quot;, argv[0]); return 1; } /* found - check max args */ if (argc &gt; cmdtp-&gt;maxargs) rc = CMD_RET_USAGE;#if defined(CONFIG_CMD_BOOTD) /* avoid &quot;bootd&quot; recursion */ else if (cmdtp-&gt;cmd == do_bootd) { if (flag &amp; CMD_FLAG_BOOTD) { puts(&quot;'bootd' recursion detected\\n&quot;); rc = CMD_RET_FAILURE; } else { flag |= CMD_FLAG_BOOTD; } }#endif /* If OK so far, then do the command */ if (!rc) { if (ticks) *ticks = get_timer(0); rc = cmd_call(cmdtp, flag, argc, argv); if (ticks) *ticks = get_timer(*ticks); *repeatable &amp;= cmdtp-&gt;repeatable; } if (rc == CMD_RET_USAGE) rc = cmd_usage(cmdtp); return rc;} boot z 命令执行","link":"/2024/06/06/uboot&linux/uboot_analyse/"},{"title":"","text":"从头理清uboot（3）-main_loop 及 CMD实现 1. main—loop 函数 2. cmd_process 函数分析 3. cmd 定义流程 [toc] 1. main—loop 函数 上篇引导启动的分析最后会调用run_main_loop,在其中会循环调用main_loop()函数。见下方： static int run_main_loop(void){ for (;;) main_loop(); return 0;} 而在main_loop中，执行的语句如下： void main_loop(void){ const char *s; bootstage_mark_name(BOOTSTAGE_ID_MAIN_LOOP, &quot;main_loop&quot;); //打印启动进度 cli_init(); /*初始化 hash shell 相关 */ run_preboot_environment_command(); /*获取 preboot 环境变量 */ s = bootdelay_process(); /*读取环境变量 bootdelay和bootcmd 的内容*/ if (cli_process_fdt(&amp;s)) /* 此次uboot 直接返回uboot */ cli_secure_boot_cmd(s); autoboot_command(s);/* 如果延时到了，没有打断就执行默认的boot-arg */ cli_loop(); /* 命令执行函数 */} bootdelay_process 函数解析：初始化好了bootdelay的参数，并且返回的命令是bootcmd 环境变量。 const char *bootdelay_process(void){ char *s; int bootdelay; s = getenv(&quot;bootdelay&quot;); bootdelay = s ? (int)simple_strtol(s, NULL, 10) : CONFIG_BOOTDELAY;#if !defined(CONFIG_FSL_FASTBOOT) &amp;&amp; defined(is_boot_from_usb) if (is_boot_from_usb()) { disconnect_from_pc(); printf(&quot;Boot from USB for mfgtools\\n&quot;); bootdelay = 0; set_default_env(&quot;Use default environment for \\ mfgtools\\n&quot;); } else { printf(&quot;Normal Boot\\n&quot;); }#endif bootretry_init_cmd_timeout(); s = getenv(&quot;bootcmd&quot;);#if !defined(CONFIG_FSL_FASTBOOT) &amp;&amp; defined(is_boot_from_usb) if (is_boot_from_usb()) { s = getenv(&quot;bootcmd_mfg&quot;); printf(&quot;Run bootcmd_mfg: %s\\n&quot;, s); }#endif process_fdt_options(gd-&gt;fdt_blob); stored_bootdelay = bootdelay; return s;} 其中的get_env函数：可见这个函数根据命令的不同，从哈希表和遍历两种方式，去现有得环境变量中查找对应命令。 char *getenv(const char *name){ /* after import into hashtable */ if (gd-&gt;flags &amp; GD_FLG_ENV_READY) { ENTRY e, *ep; WATCHDOG_RESET(); e.key = name; e.data = NULL; hsearch_r(e, FIND, &amp;ep, &amp;env_htab, 0); return ep ? ep-&gt;data : NULL; } /* restricted capabilities before import */ if (getenv_f(name, (char *)(gd-&gt;env_buf), sizeof(gd-&gt;env_buf)) &gt; 0) return (char *)(gd-&gt;env_buf); return NULL;} autoboot_command的函数代码精简如下，可见有三个参数，stored_bootdelay是刚刚初始化好的bootdelay环境变量的值，S 是bootcmd的值，这两个都条件成立。 void autoboot_command(const char *s){ debug(&quot;### main_loop: bootcmd=\\&quot;%s\\&quot;\\n&quot;, s ? s : &quot;&lt;UNDEFINED&gt;&quot;); if (stored_bootdelay != -1 &amp;&amp; s &amp;&amp; !abortboot(stored_bootdelay)) { run_command_list(s, -1, 0); } } 进一步分析abortboot(stored_bootdelay)发现里面会每次delay 1000ms 就会把传入的stored_bootdelay参数减一，所以当stored_bootdelay 递减到0的时候，会执行run_command_list(s, -1, 0)。 但是其中有个函数是tstc()有效的话，就会导致提前break ,不再执行run_command_list(s, -1, 0)。进入指令处理流程。 while ((bootdelay &gt; 0) &amp;&amp; (!abort)) { --bootdelay; /* delay 1000 ms */ ts = get_timer(0); do { if (tstc()) { /* we got a key press */ abort = 1; /* don't auto boot */ bootdelay = 0; /* no more delay */ (void) getc(); /* consume input */ break; } udelay(10000); } while (!abort &amp;&amp; get_timer(ts) &lt; 1000); printf(&quot;\\b\\b\\b%2d &quot;, bootdelay);} 正常的autoboot流程-- run_command_list 函数分析： 会调用：rcode = parse_string_outer(buff, FLAG_PARSE_SEMICOLON); 进而调用：rcode = parse_stream_outer(&amp;input, flag); 有按键输入，执行解析命令-cli_loop函数： parse_file_outer(); -&gt;调用：parse_stream_outer(&amp;input, FLAG_PARSE_SEMICOLON); 所以这种方式都会把接收到的命令交给parse_stream_outer函数执行。 -&gt; 调用: rcode = parse_stream(&amp;temp, &amp;ctx, inp, flag &amp; FLAG_CONT_ON_NEWLINE ? -1 : '\\n'); /* 解析输入的命令 */-&gt; 调用: code = run_list(ctx.list_head); /* 执行命令*/ -&gt;run_list_real(pi); -&gt;run_pipe_real(pi); -&gt;cmd_process(flag, child-&gt;argc, child-&gt;argv, &amp;flag_repeat, NULL); /* 实际的处理流程*/ 2. cmd_process 函数分析 ​ 在看函数处理之前，可以先了解uboot cmd 结构体的组成，其中参数见下图注释 struct cmd_tbl_s { char *name; /* Command Name */ int maxargs; /* maximum number of arguments */ int repeatable; /* autorepeat allowed? */ /* Implementation function */ int (*cmd)(struct cmd_tbl_s *, int, int, char * const []);/*调用函数*/ char *usage; /*简短提示信息*/}; ​ cmd_process 的处理流程如下所示， 可见主要流程为：查找命令-&gt;判断参数数量-&gt;回调函数调用。 enum command_ret_t cmd_process(int flag, int argc, char * const argv[], int *repeatable, ulong *ticks){ enum command_ret_t rc = CMD_RET_SUCCESS; cmd_tbl_t *cmdtp; /* Look up command in command table */ cmdtp = find_cmd(argv[0]); if (cmdtp == NULL) { printf(&quot;Unknown command '%s' - try 'help'\\n&quot;, argv[0]); return 1; } /* found - check max args */ if (argc &gt; cmdtp-&gt;maxargs) rc = CMD_RET_USAGE;#if defined(CONFIG_CMD_BOOTD) /* avoid &quot;bootd&quot; recursion */ else if (cmdtp-&gt;cmd == do_bootd) { if (flag &amp; CMD_FLAG_BOOTD) { puts(&quot;'bootd' recursion detected\\n&quot;); rc = CMD_RET_FAILURE; } else { flag |= CMD_FLAG_BOOTD; } }#endif /* If OK so far, then do the command */ if (!rc) { if (ticks) *ticks = get_timer(0); rc = cmd_call(cmdtp, flag, argc, argv);/*利用回调函数执行*/ if (ticks) *ticks = get_timer(*ticks); *repeatable &amp;= cmdtp-&gt;repeatable; } if (rc == CMD_RET_USAGE) rc = cmd_usage(cmdtp); return rc;} 3. cmd 定义流程 uboot 命令分析，在include/command.h中有定义： #define U_BOOT_CMD_MKENT_COMPLETE(_name, _maxargs, _rep, _cmd, \\ _usage, _help, _comp) \\ { #_name, _maxargs, _rep, _cmd, _usage, \\ _CMD_HELP(_help) _CMD_COMPLETE(_comp) }#define U_BOOT_CMD_MKENT(_name, _maxargs, _rep, _cmd, _usage, _help) \\ U_BOOT_CMD_MKENT_COMPLETE(_name, _maxargs, _rep, _cmd, \\ _usage, _help, NULL)#define U_BOOT_CMD_COMPLETE(_name, _maxargs, _rep, _cmd, _usage, _help, _comp) \\ ll_entry_declare(cmd_tbl_t, _name, cmd) = \\ U_BOOT_CMD_MKENT_COMPLETE(_name, _maxargs, _rep, _cmd, \\ _usage, _help, _comp);#define U_BOOT_CMD(_name, _maxargs, _rep, _cmd, _usage, _help) \\ U_BOOT_CMD_COMPLETE(_name, _maxargs, _rep, _cmd, _usage, _help, NULL) 可以看出有以下几点： U_BOOT_CMD就是U_BOOT_CMD_COMPLETE的宏参数最后一个为NULL U_BOOT_CMD_COMPLETE会继续调用ll_entry_declare和U_BOOT_CMD_MKENT_COMPLETE函数。分别显示如下 #define ll_entry_declare(_type, _name, _list) \\ _type _u_boot_list_2_##_list##_2_##_name __aligned(4) \\ __attribute__((unused, \\ section(&quot;.u_boot_list_2_&quot;#_list&quot;_2_&quot;#_name))) * ```asm #define U_BOOT_CMD_MKENT_COMPLETE(_name, _maxargs, _rep, _cmd,\\ _usage, _help, _comp) \\ { #_name, _maxargs, _rep, _cmd, _usage, \\ _CMD_HELP(_help) _CMD_COMPLETE(_comp) } 其中再次调用了_CMD_HELP(_help) _CMD_COMPLETE(_comp)这两部分定义如下(相关宏已经定义了)： #ifdef CONFIG_AUTO_COMPLETE//# define _CMD_COMPLETE(x) x,#else//# define _CMD_COMPLETE(x)//#endif#ifdef CONFIG_SYS_LONGHELP# define _CMD_HELP(x) x,#else//# define _CMD_HELP(x)//#endif 利用一个CMD来分析 U_BOOT_CMD( spibootldr, 2, 0, do_spibootldr, &quot;boot ldr image from spi&quot;, &quot;[offset]\\n&quot; &quot; - boot ldr image stored at offset into spi\\n&quot;); 经过上述的分析，此命令可以被解析为： --ll_entry_declare(_type, _name, _list) -&gt; cmd_tbl_t _u_boot_list_2_spibootldr_2_spibootldr __aligned(4) \\ __attribute__((unused, \\ section(&quot;.u_boot_list_2_do_spibootldr_2_spibootldr))) --{ &quot;spibootldr&quot;, 2, 0, do_spibootldr,&quot; boot ldr image from spi&quot;, \\ &quot;[offset]\\n&quot;&quot;- boot ldr image stored at offset into spi\\n&quot;, NULL, } ## 连接符:表示后面直接链接 # 字符串化：表示将传来的参数字符串化。 所以最后实现的语句如下所示： cmd_tbl_t _u_boot_list_2_spibootldr_2_spibootldr __aligned(4) \\ __attribute__((unused, section(&quot;.u_boot_list_2_do_spibootldr_2_spibootldr&quot;))) = { &quot;spibootldr&quot;, 2, 0, do_spibootldr, &quot; boot ldr image from spi&quot;, &quot;[offset]\\n&quot;&quot;- boot ldr image stored at offset into spi\\n&quot;, NULL, } ​ 4字节对齐定义了一个cmd_tbl_t的结构体变量_u_boot_list_2_spibootldr_2_spibootldr，且被划分到了u_boot_list_2_do_spibootldr_2_spibootldr section。 其中对于cmd_tbl_t 有以下定义: struct cmd_tbl_s { char *name; /* Command Name */ int maxargs; /* maximum number of arguments */ int repeatable; /* autorepeat allowed? */ /* Implementation function */ int (*cmd)(struct cmd_tbl_s *, int, int, char * const []); /* 函数指针 */ char *usage; /* Usage message (short) */#ifdef CONFIG_SYS_LONGHELP char *help; /* Help message (long) */#endif#ifdef CONFIG_AUTO_COMPLETE /* do auto completion on the arguments */ int (*complete)(int argc, char * const argv[], char last_char, int maxv, char *cmdv[]);#endif}; section 在内存中的存储位置如下所示：四字节对齐之后存储在rodata 段之后。 .rodata : { *(SORT_BY_ALIGNMENT(SORT_BY_NAME(.rodata*))) }. = ALIGN(4);.data : { *(.data*)}. = ALIGN(4);. = .;. = ALIGN(4);.u_boot_list : { KEEP(*(SORT(.u_boot_list*)));} **注意：**这里有一次SORT排序，结合下面的代码，就会发现能够获取板子的整个命令段。函数内部静态定义也会存在全局变量中。 #define ll_entry_start(_type, _list)\\ ({\\ static char start[0] __aligned(4) __attribute__((unused, \\ section(&quot;.u_boot_list_2_&quot;#_list&quot;_1&quot;))); \\ (_type *)&amp;start; \\ }) #define ll_entry_end(_type, _list)\\ ({ \\ static char end[0] __aligned(4) __attribute__((unused, \\ section(&quot;.u_boot_list_2_&quot;#_list&quot;_3&quot;))); \\ (_type *)&amp;end; \\ })","link":"/2024/06/06/uboot&linux/uboot_2/"},{"title":"","text":"从0移植Freertos到riscv-core MCU 1. 下载Freertos及文件准备 2. 修改代码以适配RISCV平台 2.1 创建一个base 工程 2.2 将1中的目录结构添加到base 工程中，并且在main.c 文件 和FreeRTOSConfig.h 文件中添加以下内容 3. 完成移植，来个测试demo [toc] 1. 下载Freertos及文件准备 下载 可以从官网下载Freertos 的最新版本，这是github 链接：https://github.com/FreeRTOS/FreeRTOS/tree/V10.0.0，这个是10.0版本的。我下载的版本是`FreeRTOSv202212.01`版本 目录裁剪 在Freertos解压之后，进入./FreeRtoS目录，里面有下面几个文件夹，我们需要Source文件夹中的源码。 FreeRTOS -&gt;Demo /* 不需要 */ -&gt;license /* 不需要 */ -&gt;Source -&gt;一系列文件 *.* /* 文件夹下的一系列文件 *.* 都要 */ -&gt;include /* 全要拷贝 */ -&gt;portable -&gt;MemMang /*拷贝一个需要的malloc 算法就行。我留下的是heap_4.c*/ -&gt;\\GCC\\RISC-V\\chip_specific_extensions \\ RISCV_MTIME_CLINT_no_extensions\\freertos_risc_v_chip_specific_extensions.h /* 要 */ -&gt;\\GCC\\RISC-V\\ /* 文件夹下的一系列文件 *.* 都要 */ -&gt;CMakeList.txt /* 要拷贝 */ -&gt;readme.txt /* 要拷贝 */ -&gt;test /* 不需要 */ 整体拷贝完之后的目录结构如下图： 文件添加 可以新建一个文件夹，添加两个文件main.c和FreeRTOSConfig.h。如果本身已经有对应的main.c的话就不需要新建了，可以保留。 经过以上，我们需要的文件已经设定好了，现在添加及修改内容。 2. 修改代码以适配RISCV平台 2.1 创建一个base 工程 在你的riscv 平台上创建一个base 工程，要求是能够跑进main函数和有printf 串口输出（能跑进main 函数是必须的，printf只是为了方便debug）。这样能保证你的工程至少能初步跑起来，汇编准备的C语言运行环境、硬件环境没有问题。 2.2 将1中的目录结构添加到base 工程中，并且在main.c 文件 和FreeRTOSConfig.h 文件中添加以下内容 2.2.1 main 函数中需要添加的代码 在main 函数中添加如下代码，在头文件中加入&quot;FreeRTOS.h&quot;和&quot;task.h&quot;就可以调用Freertos的API了。下方添加的内容简单介绍如下： 覆盖了一个测试的case：创建B、C两个任务，每个任务循环10000个**tick **会进行一次调度。 定义了一些hook 函数，当对应的情况发生时，会进入这个HOOK 函数。这些HOOK函数和FreeRTOSConfig.h 中的配置项有对应关系。 /****************************************************************************************************************/ /**************************************************FOR FreeRtos*************************************************/ /***************************************************************************************************************/ static TaskHandle_t xHandleTaskB = NULL; static TaskHandle_t xHandleTaskC = NULL; static void vTaskB(void *pvParameters) { static uint16_t TaskBnum=0; while(1) { TaskBnum++; printf(&quot;Task B : %d \\r\\n&quot;,TaskBnum); vTaskDelay(10000); } } static void vTaskC(void *pvParameters) { static uint16_t TaskCnum=0; while(1) { TaskCnum++; printf(&quot;Task C : %d \\r\\n&quot;,TaskCnum); vTaskDelay(10000);//退出调度10000个ticks } } static void AppTaskCreate (void) { xTaskCreate( vTaskB, /* 任务函数 */ &quot;vTaskB&quot;, /* 任务名 */ 128, /* 任务栈大小，单位 word，也就是 4 字节 */ NULL, /* 任务参数 */ 4, /* 任务优先级*/ &amp;xHandleTaskB /* 任务句柄 */ ); xTaskCreate( vTaskC, &quot;vTaskC&quot;, 128, NULL, 3, &amp;xHandleTaskC ); } /* Prototypes for the standard FreeRTOS callback/hook functions implemented within this file. */ void vApplicationMallocFailedHook( void ); void vApplicationIdleHook( void ); void vApplicationStackOverflowHook( TaskHandle_t pxTask, char *pcTaskName ); void vApplicationTickHook( void ); static void prvSetupHardware( void ) { /* Ensure no interrupts execute while the scheduler is in an inconsistent state. Interrupts are automatically enabled when the scheduler is started. */ portDISABLE_INTERRUPTS(); /* Enable UART port to output messages. */ // uart_print_config(); } /*-----------------------------------------------------------*/ void vAssertCalled( const char * pcFile, unsigned long ulLine ) { volatile unsigned long ul = 0; ( void ) pcFile; ( void ) ulLine; printf( &quot;ASSERT! Line %d, file %s\\r\\n&quot;, ( int )ulLine, pcFile ); taskENTER_CRITICAL(); { /* Set ul to a non-zero value using the debugger to step out of this function. */ while( ul == 0 ) { portNOP(); } } taskEXIT_CRITICAL(); } /*-----------------------------------------------------------*/ void vApplicationMallocFailedHook( void ) { /* vApplicationMallocFailedHook() will only be called if configUSE_MALLOC_FAILED_HOOK is set to 1 in FreeRTOSConfig.h. It is a hook function that will get called if a call to pvPortMalloc() fails. pvPortMalloc() is called internally by the kernel whenever a task, queue, timer or semaphore is created. It is also called by various parts of the demo application. If heap_1.c, heap_2.c or heap_4.c is being used, then the size of the heap available to pvPortMalloc() is defined by configTOTAL_HEAP_SIZE in FreeRTOSConfig.h, and the xPortGetFreeHeapSize() API function can be used to query the size of free heap space that remains (although it does not provide information on how the remaining heap might be fragmented). See http://www.freertos.org/a00111.html for more information. */ vAssertCalled( __FILE__, __LINE__ ); } /*-----------------------------------------------------------*/ void vApplicationStackOverflowHook( TaskHandle_t pxTask, char *pcTaskName ) { ( void ) pcTaskName; ( void ) pxTask; /* Run time stack overflow checking is performed if configCHECK_FOR_STACK_OVERFLOW is defined to 1 or 2. This hook function is called if a stack overflow is detected. */ vAssertCalled( __FILE__, __LINE__ ); } /*-----------------------------------------------------------*/ void vApplicationIdleHook( void ) { volatile size_t xFreeHeapSpace; /* This is just a trivial example of an idle hook. It is called on each cycle of the idle task. It must *NOT* attempt to block. In this case the idle task just queries the amount of FreeRTOS heap that remains. See the memory management section on the http://www.FreeRTOS.org web site for memory management options. If there is a lot of heap memory free then the configTOTAL_HEAP_SIZE value in FreeRTOSConfig.h can be reduced to free up RAM. */ xFreeHeapSpace = xPortGetFreeHeapSize(); /* Remove compiler warning about xFreeHeapSpace being set but never used. */ ( void ) xFreeHeapSpace; } /*-----------------------------------------------------------*/ void vApplicationTickHook( void ) { #if( mainSELECTED_APPLICATION == 1 ) { /* Only the comprehensive demo actually uses the tick hook. */ extern void vFullDemoTickHook( void ); vFullDemoTickHook(); } #endif } /*-----------------------------------------------------------*/ /* configUSE_STATIC_ALLOCATION is set to 1, so the application must provide an implementation of vApplicationGetIdleTaskMemory() to provide the memory that is used by the Idle task. */ void vApplicationGetIdleTaskMemory( StaticTask_t **ppxIdleTaskTCBBuffer, StackType_t **ppxIdleTaskStackBuffer, uint32_t *pulIdleTaskStackSize ) { /* If the buffers to be provided to the Idle task are declared inside this function then they must be declared static - otherwise they will be allocated on the stack and so not exists after this function exits. */ static StaticTask_t xIdleTaskTCB; static StackType_t uxIdleTaskStack[ configMINIMAL_STACK_SIZE ]; /* Pass out a pointer to the StaticTask_t structure in which the Idle task's state will be stored. */ *ppxIdleTaskTCBBuffer = &amp;xIdleTaskTCB; /* Pass out the array that will be used as the Idle task's stack. */ *ppxIdleTaskStackBuffer = uxIdleTaskStack; /* Pass out the size of the array pointed to by *ppxIdleTaskStackBuffer. Note that, as the array is necessarily of type StackType_t, configMINIMAL_STACK_SIZE is specified in words, not bytes. */ *pulIdleTaskStackSize = configMINIMAL_STACK_SIZE; } /*-----------------------------------------------------------*/ /* configUSE_STATIC_ALLOCATION and configUSE_TIMERS are both set to 1, so the application must provide an implementation of vApplicationGetTimerTaskMemory() to provide the memory that is used by the Timer service task. */ void vApplicationGetTimerTaskMemory( StaticTask_t **ppxTimerTaskTCBBuffer, StackType_t **ppxTimerTaskStackBuffer, uint32_t *pulTimerTaskStackSize ) { /* If the buffers to be provided to the Timer task are declared inside this function then they must be declared static - otherwise they will be allocated on the stack and so not exists after this function exits. */ static StaticTask_t xTimerTaskTCB; static StackType_t uxTimerTaskStack[ configTIMER_TASK_STACK_DEPTH ]; /* Pass out a pointer to the StaticTask_t structure in which the Timer task's state will be stored. */ *ppxTimerTaskTCBBuffer = &amp;xTimerTaskTCB; /* Pass out the array that will be used as the Timer task's stack. */ *ppxTimerTaskStackBuffer = uxTimerTaskStack; /* Pass out the size of the array pointed to by *ppxTimerTaskStackBuffer. Note that, as the array is necessarily of type StackType_t, configMINIMAL_STACK_SIZE is specified in words, not bytes. */ *pulTimerTaskStackSize = configTIMER_TASK_STACK_DEPTH; } /*-----------------------------------------------------------*/ void vPreSleepProcessing( unsigned long uxModifiableIdleTime ) { /* Called by the kernel before it places the MCU into a sleep mode because configPRE_SLEEP_PROCESSING() is #defined to vPreSleepProcessing(). NOTE: Additional actions can be taken here to get the power consumption even lower. For example, peripherals can be turned off here, and then back on again in the post sleep processing function. For maximum power saving ensure all unused pins are in their lowest power state. */ /* Avoid compiler warnings about the unused parameter. */ ( void ) uxModifiableIdleTime; } /*-----------------------------------------------------------*/ void vPostSleepProcessing( unsigned long uxModifiableIdleTime ) { /* Called by the kernel when the MCU exits a sleep mode because configPOST_SLEEP_PROCESSING is #defined to vPostSleepProcessing(). */ /* Avoid compiler warnings about the unused parameter. */ ( void ) uxModifiableIdleTime; } 2.2.2 FreeRTOSConfig.h文件 需要添加一个FreeRTOSConfig.h 文件，Freertos编译依赖于它，可以根据SOC/MCU 情况更改FreeRTOSConfig.h这个文件。例如下面几点： 中断服务程序（ISR）堆栈大小：configISR_STACK_SIZE_WORDS mtime地址：#define configMTIME_BASE_ADDRESS mcmp 地址：#define configMTIMECMP_BASE_ADDRESS CPU 时钟频率：#define configCPU_CLOCK_HZ systick 节拍：#define configTICK_RATE_HZ 堆栈大小：#define configTOTAL_HEAP_SIZE /* * FreeRTOS V202212.01 * Copyright (C) 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved. * * Permission is hereby granted, free of charge, to any person obtaining a copy of * this software and associated documentation files (the &quot;Software&quot;), to deal in * the Software without restriction, including without limitation the rights to * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of * the Software, and to permit persons to whom the Software is furnished to do so, * subject to the following conditions: * * The above copyright notice and this permission notice shall be included in all * copies or substantial portions of the Software. * * THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. * * https://www.FreeRTOS.org * https://github.com/FreeRTOS * */#ifndef FREERTOS_CONFIG_H#define FREERTOS_CONFIG_H/*----------------------------------------------------------- * Application specific definitions. * * These definitions should be adjusted for your particular hardware and * application requirements. * * THESE PARAMETERS ARE DESCRIBED WITHIN THE 'CONFIGURATION' SECTION OF THE * FreeRTOS API DOCUMENTATION AVAILABLE ON THE FreeRTOS.org WEB SITE. * * See http://www.freertos.org/a00110.html. *----------------------------------------------------------*/#define configISR_STACK_SIZE_WORDS ( 1000 ) // +//#define CLINT_CTRL_ADDR ( 0x40049000UL )#define configMTIME_BASE_ADDRESS ( 0x40049000UL + 0xC0UL )#define configMTIMECMP_BASE_ADDRESS ( 0x40049000UL + 0x40UL )#define configUSE_PREEMPTION 1#define configCPU_CLOCK_HZ ( ( uint32_t ) ( 16*1000*1000 ) )#define configTICK_RATE_HZ ( ( TickType_t ) 1000 ) /* irq time = 1s /configTICK_RATE_HZ */#define configMAX_PRIORITIES ( 7 )#define configMINIMAL_STACK_SIZE ( ( uint32_t ) 2048 ) // 最小任务堆栈大小#define configTOTAL_HEAP_SIZE ( ( size_t ) ( 50 * 1024 ) )// 堆内存总大小（字节）#define configMAX_TASK_NAME_LEN ( 16 )#define configUSE_TRACE_FACILITY 0#define configUSE_16_BIT_TICKS 0#define configIDLE_SHOULD_YIELD 0#define configUSE_MUTEXES 1#define configQUEUE_REGISTRY_SIZE 8#define configCHECK_FOR_STACK_OVERFLOW 2#define configUSE_RECURSIVE_MUTEXES 1#define configUSE_APPLICATION_TASK_TAG 0#define configUSE_COUNTING_SEMAPHORES 1#define configGENERATE_RUN_TIME_STATS 0#define configUSE_IDLE_HOOK 1#define configUSE_TICK_HOOK 0#define configUSE_MALLOC_FAILED_HOOK 1/* Software timer definitions. */#define configUSE_TIMERS 1#define configTIMER_TASK_PRIORITY ( configMAX_PRIORITIES - 1 )#define configTIMER_QUEUE_LENGTH 4 // +#define configTIMER_TASK_STACK_DEPTH ( configMINIMAL_STACK_SIZE )/* Task priorities. Allow these to be overridden. */#ifndef uartPRIMARY_PRIORITY #define uartPRIMARY_PRIORITY ( configMAX_PRIORITIES - 3 )#endif/* Set the following definitions to 1 to include the API function, or zero * to exclude the API function. */#define INCLUDE_vTaskPrioritySet 1#define INCLUDE_uxTaskPriorityGet 1#define INCLUDE_vTaskDelete 1#define INCLUDE_vTaskCleanUpResources 1#define INCLUDE_vTaskSuspend 1#define INCLUDE_vTaskDelayUntil 1#define INCLUDE_vTaskDelay 1#define INCLUDE_eTaskGetState 1#define INCLUDE_xTimerPendFunctionCall 0#define INCLUDE_xTaskAbortDelay 1#define INCLUDE_xTaskGetHandle 1#define INCLUDE_xSemaphoreGetMutexHolder 1/* Normal assert() semantics without relying on the provision of an assert.h * header file. */#define configASSERT( x ) if( ( x ) == 0 ) { taskDISABLE_INTERRUPTS(); __asm volatile( &quot;ebreak&quot; ); for( ;; ); }/* Map to the platform write function. */extern void vSendString( const char * const pcString );#define configPRINT_STRING( pcString ) vSendString( pcString )#endif /* FREERTOS_CONFIG_H */ 2.2.3 修改freertos_risc_v_chip_specific_extensions.h 文件 由于我的mcu 是利用mtime 来做 sistick 的，所以我需要修改freertos_risc_v_chip_specific_extensions.h中的宏定义，建议使用这种情况不然会需要修改Freertos 的中断处理汇编源码。 #define portasmHAS_MTIME 1 2.2.4 修改中断向量表入口地址 由于riscv 的中断向量表的地址存放在mtevc寄存器中，所以我们需要把中断向量表的入口地址赋值给mtevc。在你的startup.s中加入下面代码即可。其中freertos_risc_v_trap_handler定义在Freertos\\portable\\GCC\\RISC-V\\portASM.S文件下。 ;#************* prepare the entry of interrupt ***** la t0, freertos_risc_v_trap_handler csrw mtvec, t0 2.2.5 重新定义你自己的外部中断处理函数 由于mtime 中断是Core 内部的中断，所以使用起来不会经过不同的中断处理器，例如clint/MPIC 等，但是不同的MCU可能用的外部中断控制器不同，这里Freertos留了一个接口给我们，让我们能够根据需要重新定义自己的外部中断处理函数，同样是在portASM.S文件中，如下，如果进入中断的话，不是mtime 中断就会调用freertos_risc_v_application_interrupt_handler，然后再产生一次调度。 handle_interrupt:#if( portasmHAS_MTIME != 0 ) test_if_mtimer: /* If there is a CLINT then the mtimer is used to generate the tick interrupt. */ addi t0, x0, 1 slli t0, t0, __riscv_xlen - 1 /* LSB is already set, shift into MSB. Shift 31 on 32-bit or 63 on 64-bit cores. */ addi t1, t0, 7 /* 0x8000[]0007 == machine timer interrupt. */ bne a0, t1, application_interrupt_handler portUPDATE_MTIMER_COMPARE_REGISTER call xTaskIncrementTick beqz a0, processed_source /* Don't switch context if incrementing tick didn't unblock a task. */ call vTaskSwitchContext j processed_source#endif /* portasmHAS_MTIME */application_interrupt_handler: call freertos_risc_v_application_interrupt_handler j processed_source 我们可以根据自己的中断控制器，实现freertos_risc_v_application_interrupt_handler如下： void __attribute__((aligned(4))) freertos_risc_v_application_interrupt_handler(void) {/* 读取外部中断号 *//* 进入外部handler 函数*//* 清除标志位 退出中断 */} 3. 完成移植，来个测试demo 还记得main 中赋值的创建的两个task任务的测试case 吗，我们可以利用其进行测试。 #include &quot;FreeRTOS.h&quot;#include &quot;task.h&quot;static void AppTaskCreate (void);int main(void) { int mstatus_val = 0,mie_val = 0x888; uart_init(); printf(&quot;for Freertos ! \\r\\n&quot;); portDISABLE_INTERRUPTS(); AppTaskCreate(); vTaskStartScheduler(); while(1){ __asm(&quot;nop&quot;); }; return 0;} 预期结果log如下： for Freertos ! Task B : 1 Task C : 1 Task B : 2 Task C : 2 Task B : 3 Task C : 3 ......","link":"/2024/06/06/%E7%A7%AF%E7%B4%AF/Freertos/"},{"title":"","text":"配置vscode+clangd 的开发环境： 总体可以参考这个文章： https://blog.csdn.net/ludaoyi88/article/details/135051470 改进点： 安装的时候：不需要去下载，一般只需要执行下面两个命令 sudo apt-get updatesudo apt-get install clangd 设置命令的时候：注意 这里一定是&quot;–&quot;。是对应clangd 命令的。 --compile-commands-dir=${workspaceFolder}--background-index--completion-style=detailed--header-insertion=never-log=info 总结 有下面的步骤： ubuntu 中安装bear: sudo apt install bear vscode 中安装clanged插件 WSL 中安装 clanged sudo apt-get updatesudo apt-get install clangd/* sudo apt-get install clangd */","link":"/2024/06/06/%E7%A7%AF%E7%B4%AF/vscode+clangd/"},{"title":"","text":"移植coremark &amp; dhrystone要点 1. coremark 1.1 coremark 计算方法 1.2 coremark 移植方法 2. dhrystone 2.1 dhrystone 计算方式 2.2 dhrystone 移植要点 [toc] 1. coremark 1.1 coremark 计算方法 ​ 计算的核心为下方的代码 start_time();#if (MULTITHREAD &gt; 1)/* 多线程的情况 */#else/*单线程情况*/ iterate(&amp;results[0]);#endif stop_time(); ​ 对于 iterate(&amp;results[0]); 再追进去可以发现 void * iterate(voisd *pres){ ee_u32 i; ee_u16 crc; core_results *res = (core_results *)pres; ee_u32 iterations = res-&gt;iterations; res-&gt;crc = 0; res-&gt;crclist = 0; res-&gt;crcmatrix = 0; res-&gt;crcstate = 0; for (i = 0; i &lt; iterations; i++) { crc = core_bench_list(res, 1); res-&gt;crc = crcu16(crc, res-&gt;crc); crc = core_bench_list(res, -1); res-&gt;crc = crcu16(crc, res-&gt;crc); if (i == 0) res-&gt;crclist = res-&gt;crc; } return NULL;} ​ 而这里的iterations 会在results[0].iterations = get_seed_32(4);函数中被赋值为ITERATIONS,所以我们可以知道，其实coremark 就是获取了下面这些参数 start_time(); stop_time(); iterations ​ 然后通过下面的代码算出 循环次数÷时间 的结果，可以看下面的代码，用default_num_contexts * results[0].iterations / time_in_secs(total_time)计算出了目标值。 ​ 但是实际我们看的分数是Iterations/Sec /MHZ，即最后需要的结果是跑分/(你的时钟/1MHZ),例如我最后跑分是14，频率是5MHZ，那么我的实际结果是：14/(5/1) = 2.8 coremark/Mhz /* and report results */ ee_printf(&quot;CoreMark Size : %lu\\n&quot;, (long unsigned)results[0].size); ee_printf(&quot;Total ticks : %lu\\n&quot;, (long unsigned)total_time);#if HAS_FLOAT /* 有浮点的情况 */#else ee_printf(&quot;Total time (secs): %d\\n&quot;, time_in_secs(total_time)); if (time_in_secs(total_time) &gt; 0) ee_printf(&quot;Iterations/Sec : %d\\n&quot;, default_num_contexts * results[0].iterations / time_in_secs(total_time));#endif if (time_in_secs(total_time) &lt; 10) { ee_printf( &quot;ERROR! Must execute for at least 10 secs for a valid result!\\n&quot;); total_errors++; } ee_printf(&quot;Iterations : %lu\\n&quot;, (long unsigned)default_num_contexts * results[0].iterations); ee_printf(&quot;Compiler version : %s\\n&quot;, COMPILER_VERSION); ee_printf(&quot;Compiler flags : %s\\n&quot;, COMPILER_FLAGS); 1.2 coremark 移植方法 由1.1 我们就可以知道，其实coremark 就是跑个程序n 循环，然后计算一个 指令/时间/频率 这样的结果，所以我们移植只需要给出以下几个参数 时间获取方式，start_time() 和 stop_time()向里追，最后会有时间函数的实现，这里一般获取的都是cnt 数，需要结合时钟的频率才能具体计算出了时间，即这里忽略了周期。 CLOCKS_PER_SEC 这个宏定义改为你的时钟频率，第一点的获取了这段时间内增加的cnt值，这里有了时间周期，那么time_in_secs(total_time)这个函数就能够计算出执行当前的时间了。其实最后也是cnt 值/频率=时间 iterations ，结合时钟频率不同，需要保证coremark 跑10s 以上，即time_in_secs(total_time)计算出来的结果是10s 以上，按照实际的结果给一个值就可以了。 printf 的实现，需要根据实际情况注意是不是要加printf这个宏 //如果编译的时候加上了 -DHAS_PRINTF,那么这里就不会生效，但是还是代表了HAS_PRINTF#ifndef HAS_PRINTF#define HAS_PRINTF 1#endif//由于coremark 都是使用的ee_printf，所以需要把ee_printf符号替换为printf#if HAS_PRINTF#define ee_printf printf#endif 以上就是移植的要点，需要哪些文件内容官网readme 有说，就不赘述了。 2. dhrystone 2.1 dhrystone 计算方式 ​ 和coremark 类似，dhrystone的主函数也是进行算 跑dhrystone 程序的时间，以推出来单位时间下跑dhrystone 的个数，再除以MHZ的话就可以推出来 再1MHZ的情况下，1秒能跑多少dhrystone 程序。 ​ 主题程序如下： /***************/ /* Start timer */ /***************/#ifdef TIMES times (&amp;time_info); Begin_Time = (long) time_info.tms_utime;#endif#ifdef TIME Begin_Time = time ( (long *) 0);#endif#ifdef MSC_CLOCK Begin_Time = clock();#endif for (Run_Index = 1; Run_Index &lt;= Number_Of_Runs; ++Run_Index) { Proc_5(); Proc_4(); /* Ch_1_Glob == 'A', Ch_2_Glob == 'B', Bool_Glob == true */ Int_1_Loc = 2; Int_2_Loc = 3; strcpy (Str_2_Loc, &quot;DHRYSTONE PROGRAM, 2'ND STRING&quot;); Enum_Loc = Ident_2; Bool_Glob = ! Func_2 (Str_1_Loc, Str_2_Loc); /* Bool_Glob == 1 */ while (Int_1_Loc &lt; Int_2_Loc) /* loop body executed once */ { Int_3_Loc = 5 * Int_1_Loc - Int_2_Loc; /* Int_3_Loc == 7 */ Proc_7 (Int_1_Loc, Int_2_Loc, &amp;Int_3_Loc); /* Int_3_Loc == 7 */ Int_1_Loc += 1; } /* while */ /* Int_1_Loc == 3, Int_2_Loc == 3, Int_3_Loc == 7 */ Proc_8 (Arr_1_Glob, Arr_2_Glob, Int_1_Loc, Int_3_Loc); /* Int_Glob == 5 */ Proc_1 (Ptr_Glob); for (Ch_Index = 'A'; Ch_Index &lt;= Ch_2_Glob; ++Ch_Index) /* loop body executed twice */ { if (Enum_Loc == Func_1 (Ch_Index, 'C')) /* then, not executed */ { Proc_6 (Ident_1, &amp;Enum_Loc); strcpy (Str_2_Loc, &quot;DHRYSTONE PROGRAM, 3'RD STRING&quot;); Int_2_Loc = Run_Index; Int_Glob = Run_Index; } } /* Int_1_Loc == 3, Int_2_Loc == 3, Int_3_Loc == 7 */ Int_2_Loc = Int_2_Loc * Int_1_Loc; Int_1_Loc = Int_2_Loc / Int_3_Loc; Int_2_Loc = 7 * (Int_2_Loc - Int_3_Loc) - Int_1_Loc; /* Int_1_Loc == 1, Int_2_Loc == 13, Int_3_Loc == 7 */ Proc_2 (&amp;Int_1_Loc); /* Int_1_Loc == 5 */ } /* loop &quot;for Run_Index&quot; */ /**************/ /* Stop timer */ /**************/#ifdef TIMES times (&amp;time_info); End_Time = (long) time_info.tms_utime;#endif#ifdef TIME End_Time = time ( (long *) 0);#endif#ifdef MSC_CLOCK End_Time = clock();#endif ​ 以上就可以通过Begin_Time和End_Time获取运行程序的时间，在有以下的计算程序： User_Time = End_Time - Begin_Time;#ifdef TIME /*User_Time 已经是具体时间计数了*/ Microseconds = (float) User_Time * Mic_secs_Per_Second / (float) Number_Of_Runs; Dhrystones_Per_Second = (float) Number_Of_Runs / (float) User_Time;#else /*User_Time 是counter值*/ Microseconds = (float) User_Time * Mic_secs_Per_Second / ((float) HZ * ((float) Number_Of_Runs)); Dhrystones_Per_Second = ((float) HZ * (float) Number_Of_Runs) / (float) User_Time;#endif ​ 以user_time 是counter值为例：Dhrystones_Per_Second =Number_Of_Runs ÷ 时间 = Number_Of_Runs÷ (counter/频率) ，于是就有了上面的公式。 ​ 对于一般的DMIP_MHZ，上面的结果还需要再除以一个频率，因为是xMhz 跑的，不是1Mhz 跑的。即 ​ DMIP_MHZ = Dhrystones_Per_Second ÷（频率/1Mhz）例如 Dhrystones_Per_Second 为12，主频为5Mhz,那么结果就为12/5 = 2.4. 100000/(119900320/5000000)/5 = 2.2 dhrystone 移植要点 ​ 理解了第一点，这里就比较简单，其实和coremark 一样。只需要做好以下两点就可以了： 提供时间基准，用于获取start time 和 end time ，一般为timer 的计数器。 提供pintf 函数的重定义，用于打印。 注意不要让计数器超过计数范围了。","link":"/2024/06/06/%E7%A7%AF%E7%B4%AF/coremark&dhrystone/"},{"title":"","text":"一些月报内容 哈哈 12月 1月 2月 3月 构建ccm1002bc 项目 fpag阶段keil5 base工程 通过fpga版本协助定位了两个问题： 最终定位至fpga rom区域未加密的问题。 最终定位至sram ecc错误问题 通过软件rom程序处理，解决了两个问题 rom启动软件写ram区域的方式解决ram ecc错误问题 在rom中构建软件中断向量表，实现软件的二级跳转解决comtex m0 没有vocter中断向量表重定位寄存器的问题 根据ccm1002bc的中断向量表和M0核的nvic硬件特性，重写了软件中断向量表和NVIC 处理函数。 完成ccm1002bc LinFlexD 和 CanFD 模块的FPGA case 验证 阅读ccm1002bc 手册，完成LinflexD 和CanFD的传输、发送、接收、中断的fpga case 覆盖。 定位到两个软件使用注意事项： LinFlexD 使用rxdma 必须使能txdma 且用txdma 发送header，否则无法使用dma。 canfd tx buff的写入必须要32位四字节对齐写入，否则会hard fault。 完成ccm1002bc bootloader的设计及开发 任务进行中：完成lin、can 底层接口。完成Lin 接收上位机数据跳转至 RAM 执行流程。 任务1： 通过 FPGA case 协助定位到 FPGA ROM 区域未加密 和 SRAM ECC 错误问题。 采用 ROM 启动软件写 RAM 区域的方式解决了 RAM ECC 错误问题。 在 ROM 中构建软件中断向量表，实现了软件的二级跳转，解决了 Comtex M0 缺少 Vocter 中断向量表重定位寄存器的问题。 根据 ccm1002bc 的中断向量表和 M0 核的 NVIC 硬件特性，重写了软件中断向量表和 NVIC 处理函数。 任务2 阅读 ccm1002bc 手册，成功完成 LinFlexD 和 CanFD 的传输、发送、接收、中断的 FPGA Case 覆盖。 定位到软件注意事项：LinFlexD 使用 RXDMA 必须使能 TXDMA 且用 TXDMA 发送 header，否则无法使用 RXDMA 。 定位到软件注意事项：CanFD TX Buff 的写入必须要 32 位四字节对齐写入，否则可能导致 hard fault。 任务3 ​ 任务进行中：已完成 Lin 和 Can 底层接口，成功实现 Lin 接收上位机数据跳转至 RAM 执行的流程。 12月 任务1： 根据bootrom需求，完成 bootrom 的设计。在项目主管的帮助下确认bootrom方案。落实设计资料文档。 根据bootrom的设计方案，完成bootrom 代码开发。 结合bootrom功能，设计bootrom验证方案。结合验证出现的问题，完成bootrom代码迭代，实现bootrom的定版。 完成CCM1002bc Coremark 和 Dhrystone 测试。 协助同事定位FPGA版本问题和CP test 问题。 任务2 进行JNS3204 擦除编程Flashmain block对 info区域的实验，协助同事定位到info 区域的问题依旧是擦除编程Flash中por 造成的影响。 任务3 ​ 由于新的工作安排，任务3未开展，转而协助定位CCM3310S-lE的MRAM读写问题。 协助定位CCM3310S-LE mram 写入问题： 工时：2.0天 完成情况：搭建CCM3310S-LE trim环境，增加trim 信号中 wait等待时间，进行mram 读写实验，发现无法写入。 ​ 1月 CCL1100B： 在dz100和dz300完成 lin 和can transceiver的功能测试包括通讯、错误处理、唤醒、rxonly&amp;loop 等功能。 验证CCL100B lin 和can transceiver的数字逻辑功能，构建软件case，定位到多个数字逻辑bug，协助DE问题复现和分析。 根据DE的问题表格，设计软件case，在dz100和dz300上测试，回复DE实际验证结果。 2月 CCL1100B： 验证CCL100B lin 和can transceiver的数字逻辑功能，构建软件case，验证通讯、错误处理、唤醒、rxonly&amp;loop 等功能。 针对can唤醒最低有效时间问题，结合应用场景，给出判断依据，完成FPGA版本的补充验证。 CCR4001： 1. 阅读CRV4H和riscv手册，设计CRV4H验证计划，完成coremark和dhrytone的跑分测试。 2. 对riscv 软件IDE，发现了使用bug并已同步给相关同事。 计划： CCR4001： 1. 完成CCR4001 base 工程的搭建。3/5 2. 完成can、otp、ahbram ip的验证。3/13 3. 学习NPU相关知识，设计NPU软件验证计划，进行NPU的功能和数据通路的验证。3/31 CCM1002BC ​ 1. 完成芯片EVB阶段的boot、can、lin的验证。3/10 3月 CCM1002BC: 完成芯片EVB阶段的bootrom、can、lin的验证。 协助同事定位bootrom 中断问题。 CCR4001S: 在核心版CRV4H上搭建base工程和中断处理框架，交付给同事进行后续CCR4001S上base 工程搭建。 完成CCR4001S 的dhrystone 和coremark 性能测试。 学习CCR4001S NPU 知识，完成letnet IDE 软仿验证，整理网络部署和NPU验证思路。 在CCR4001S 上成功移植FreeRtos,同时适配中断、串口、浮点处理等功能。完成芯原VIPLite 需要的系统平台的搭建。积极协助应用部门的环境平台搭建，协助推进应用层的网络部署工作。 FPGA环境下跑通 NPU conv1*1 算子。 计划 CCM1002BC： 完成bootrom 的修改和验证工作。 CCR4001S： 在FPGA平台上验证已有的NPU DV case验证。 在FPGA平台上，完成NPU寄存器遍历、支持算子遍历、数据通路、中断的验证。 在FPGA平台上，完成常见小网络的部署和性能测试。 完成CCR4001S can ip的验证。 加班申请： 在FPGA平台上验证NPU 5个卷积功能算子、2个图像滤波算子case。 验证NPU 在FreeRtos 的中断通路。 阅读芯愿新realse 的NPU driver源码和相关使用手册，排查现在Freertos 适配时的mutex 申请错误和signal 循环等待的问题。 1002BC：完成FPGA阶段和EVB阶段 lin can 控制器的验证、bootrom的开发及验证。基于1100B 数模混合芯片，完成lin/can 收发器ip 数字部分的验证。 CCR4001S：完成CRV4H (riscv core)的coremark 和dhrystone性能测试、中断验证、浮点数和dsp 指令验证、完成NPU Case的验证。在CCR4001S 上成功移植Freertos，同时适配中断、串口、浮点等功能。成功适配芯愿提供的NPU Freertos 接口，且利用芯原提供的工具链，完成resnet 的部署和验证，完成pytorch 算子的导出和验证。 初次在SPI FLASH 上调试，发现没有运行成功。在DDR 能够运行的文件，将代码段编译到Flash 上运行。首先确认了是否是XIP的问题，其次修改link文件，做data 数据段的重定位还是不行。追查发现，是在FPGA环境下，CPU 运行频率和 Flsah 的 CLK 频率都比较低，而Freertos的 mtime 中断频率较高，由此导致了频繁进入mtime 中断但是不能执行用户代码。修改mtime 中断时间后问题得到解决。此外，还进行风险性评估，提供elf 给DV 验证仿真，由此判断真实场景下，芯片的处理能力。此外，NPU直接搬运的过程中 NBG 文件和权重文件都有4KB 对齐的要求，通过修改link 脚本和定义section 解决此问题。也可以用__attribute__ ((aligned (0x1000))) 解决此问题。 还有一个问题是m0 核没有中断向量表，构建了一个不定位的向量表来实现的内容。 真正想做的，还是能够从系统级层面上holdon 一个产品（软件系统）能够根据具体的问题给出软件的解法。明确数字信息和指标。","link":"/2024/06/06/%E7%A7%AF%E7%B4%AF/%E6%9C%88%E6%8A%A5%E7%BC%96%E5%86%99/"},{"title":"","text":"如何理解和配置mcu 的时钟？ 1. 观察系统的时钟结构图 2. 观察目标模块在体系中的位置 ​ 目前有项工作为芯片的bootrom工作，在bootrom中如何使能时钟是一个需要小心谨慎的问题（FPGA上不能仿真出clock）,由此梳理了一下如何配置mcu 的时钟。【ps：这确实是初学stm32的时候就接触过的问题，不过当时没有好好分析。】 1. 观察系统的时钟结构图 观察系统的时钟树结构，重点要看几个点： 系统的时钟输入是什么？有哪些时钟源可供选择和配置？ 是否有介绍目标模块的时钟通路？时钟通路上会经历哪些时钟源的选择和分频？ 2. 观察目标模块在体系中的位置 有很多外设时钟在时钟体系中没有明确的表示，打过挂载在apb总线上，由此需要确认目标模块在挂载在哪个总线上，需要打开哪些外设时钟。 3. 查看寄存器 经过上述两步，应该知道要使能目标模块时钟的话，需要选择什么时钟源，配置哪些分频。因此需要查看mcu的寄存器的说明，来按顺序配置时钟即可。 引用文章【https://blog.csdn.net/qq_29344757/article/details/73479924】","link":"/2024/06/06/%E7%A7%AF%E7%B4%AF/%E6%97%B6%E9%92%9F%E9%85%8D%E7%BD%AE/"},{"title":"","text":"一些随笔记录的问题 问题 ：makefile 中.bulid makefile .mk 这三种文件有什么区别吗？ makefile $(if ) 函数 [toc] 问题 ：makefile 中.bulid makefile .mk 这三种文件有什么区别吗？ 在使用 make 工具时，makefile.build、makefile 和 .mk 这三种文件名有一些区别，但主要在于命名惯例和使用习惯方面，而不在于 make 工具本身的功能上。 makefile: 这是默认的 make 文件名。如果你在命令行中仅输入 make 而不指定任何文件，make 会自动查找名为 makefile 或 Makefile 的文件并执行其中的规则。 由于这是默认文件名，所以这是最常见的命名方式。 makefile.build: 这不是 make 的默认文件名，需要通过指定 -f 选项来使用。例如，make -f makefile.build。 这种命名通常用于区分不同的构建文件，比如在同一个项目中有多个构建文件时，可以通过不同的后缀来区分其用途（例如，特定的构建配置或步骤）。 .mk: 这是另一种常见的命名方式，特别是在更复杂的项目或构建系统中。这种文件通常被包含在主 makefile 中，而不是直接由 make 命令执行。 例如，一个项目可能有一个主 makefile 文件，其中包含了多个 .mk 文件，这些文件可能包含特定的规则或变量定义：include config.mkinclude rules.mk 总结： makefile 是 make 的默认文件名，最常见。 makefile.build 等带有后缀的文件需要通过 make -f 来指定，通常用于区分不同的构建配置或步骤。 .mk 文件常用于被主 makefile 包含，帮助组织和管理复杂的构建系统。 这些命名差异主要是基于项目的组织结构和开发者的习惯，而不是 make 工具本身的功能差异。 .build 文件需要用 make -f 来指定的原因是 make 工具默认只识别特定名称的文件作为其构建脚本，即 makefile 或 Makefile。如果构建脚本的名称不同于这两个默认名称，make 工具就需要明确地告知使用哪个文件。这是通过 -f 选项来实现的。 具体来说，make 在执行时会自动查找当前目录下是否存在名为 makefile 或 Makefile 的文件。如果找不到这两个文件名之一，make 会报错说找不到构建文件。在这种情况下，或者如果你有多个构建文件且希望使用一个非默认名称的构建文件，你需要使用 -f 选项来指定文件名。例如： make -f makefile.build 这是为了提供灵活性，让开发者能够根据项目需求创建多个不同的构建文件，并通过显式指定来选择要使用的构建脚本。 以下是一些使用场景和原因： 多配置构建： 一个项目可能有多个配置，比如调试和发布配置，每个配置可以有独立的构建文件。 make -f makefile.debug 和 make -f makefile.release 可以分别执行不同的构建配置。 模块化构建： 大型项目可能会将构建规则分割到多个文件中，每个文件专注于项目的某个部分或模块。 例如，可以有 makefile.core、makefile.gui 等，然后通过 make -f 来选择构建哪个部分。 特殊构建任务： 某些构建任务可能需要特定的构建脚本，例如用于生成文档或运行测试。 make -f makefile.docs 可以专门用于生成项目文档，而 make -f makefile.tests 用于运行测试。 通过使用 -f 选项指定非默认的构建文件名称，make 工具可以更灵活地处理各种构建场景，满足不同项目和开发流程的需求。 makefile $(if ) 函数 $(if) 函数是 GNU make 提供的一个条件函数，用于在 makefile 中执行简单的条件判断。它的基本语法如下： $(if condition,then-part[,else-part]) condition: 这是一个条件表达式。如果这个表达式的值不为空字符串，则被认为是真。 then-part: 当 condition 为真时，返回 then-part 的值。 else-part（可选）：当 condition 为假时，返回 else-part 的值。如果省略 else-part，则在条件为假时返回空字符串。 示例 假设你有一个变量 DEBUG，用于控制是否进行调试构建。可以使用 $(if) 来决定编译选项： DEBUG := 1CFLAGS := $(if $(DEBUG),-g,-O2) 在这个例子中，如果 DEBUG 不为空（即，条件为真），CFLAGS 将被设置为 -g（启用调试信息）。否则，CFLAGS 将被设置为 -O2（优化等级 2）。 更复杂的例子 你可以嵌套使用 $(if) 函数，创建更复杂的条件逻辑： VAR1 := fooVAR2 := barRESULT := $(if $(VAR1),$(if $(VAR2),both non-empty,$(VAR1) non-empty),VAR1 empty)# 如果 VAR1 和 VAR2 都不为空，则 RESULT 为 &quot;both non-empty&quot;# 如果 VAR1 不为空但 VAR2 为空，则 RESULT 为 &quot;foo non-empty&quot;# 如果 VAR1 为空，则 RESULT 为 &quot;VAR1 empty&quot; 示例：目标文件的选择 假设你有两个不同版本的目标文件，你可以使用 $(if) 根据一个变量来选择其中一个： VERSION := 1OBJ_FILES := $(if $(VERSION),version1.o,version2.o)all: $(OBJ_FILES) $(CC) -o my_program $(OBJ_FILES) 在这个例子中，如果 VERSION 不为空，则 OBJ_FILES 将被设置为 version1.o；否则，设置为 version2.o。 使用环境变量 你也可以结合环境变量来使用 $(if) 函数。例如： INSTALL_DIR := $(if $(PREFIX),$(PREFIX)/usr/local,/usr/local)install: cp my_program $(INSTALL_DIR)/bin 在这个例子中，如果环境变量 PREFIX 被设置了，INSTALL_DIR 将使用 PREFIX 指定的目录；否则，将使用默认目录 /usr/local。 $(wildcard) 函数 在 GNU make 中，$(wildcard) 函数用于扩展模式匹配符并返回与模式匹配的文件列表。它在自动化文件查找和管理中非常有用，特别是在处理源文件或其他需要动态查找的文件时。 其基本语法是： $(wildcard pattern) 其中，pattern 是包含通配符（如 *、?）的模式字符串。 假设你在当前目录下有以下文件： main.cutils.cmain.hutils.hreadme.txt 你可以使用 $(wildcard) 来找到所有 .c 文件： SRC_FILES := $(wildcard *.c) 此时，SRC_FILES 将包含 main.c 和 utils.c。 你还可以将目录名和文件模式结合在变量中使用，例如： SRC_DIR := srcSRC_FILES := $(wildcard $(SRC_DIR)/*.c) 假设 src 目录下有 file1.c 和 file2.c 文件，则 SRC_FILES 将包含 src/file1.c 和 src/file2.c。 以下是一些具体的使用示例： 自动生成对象文件列表： SRC_FILES := $(wildcard *.c)OBJ_FILES := $(patsubst %.c,%.o,$(SRC_FILES))all: my_programmy_program: $(OBJ_FILES) $(CC) -o $@ $^%.o: %.c $(CC) -c $&lt; -o $@ 在这个例子中，SRC_FILES 自动包含当前目录下所有的 .c 文件，并生成对应的 .o 文件列表存储在 OBJ_FILES 变量中。 查找特定类型的文件： HEADER_FILES := $(wildcard *.h) HEADER_FILES 将包含所有 .h 文件。 如果你的项目结构包含子目录，可以使用递归通配符来查找子目录中的文件（GNU make 4.0 及以上版本支持）： SRC_FILES := $(wildcard src/**/*.c) 这个命令将查找 src 目录及其所有子目录中的 .c 文件。 你可以结合 $(wildcard) 和 $(foreach) 实现更复杂的文件查找逻辑。例如，查找多个目录中的文件： DIRS := src lib testsSRC_FILES := $(foreach dir,$(DIRS),$(wildcard $(dir)/*.c)) 这个例子会在 src、lib 和 tests 目录中查找所有的 .c 文件，并将它们存储在 SRC_FILES 中。 $(wildcard) 函数在 makefile 中是一个非常强大的工具，能够自动查找匹配特定模式的文件，使得构建过程更加灵活和自动化。通过结合使用变量、模式匹配和其他 make 函数，可以实现复杂的文件管理和构建规则。 $(patsubst) 函数 $(patsubst) 是一个 GNU Make 函数，用于模式替换。它在一组单词中，将符合指定模式的部分替换为另一个字符串。 基本语法： # 匹配规则 替换结果 替换源$(patsubst pattern,replacement,text) pattern：模式，使用 % 表示通配符。 replacement：替换的字符串，同样可以包含 % 以表示与模式中通配符对应的部分。 text：要进行模式替换的文本。 示例： 假设有如下 Makefile 代码： sources = foo.c bar.c baz.cobjects = $(patsubst %.c,%.o,$(sources)) 在这个例子中： sources 定义了一组源文件列表。 $(patsubst %.c,%.o,$(sources)) 将 sources 列表中每个以 .c 结尾的文件替换成以 .o 结尾的文件。 结果： objects 将包含 foo.o bar.o baz.o。 $&lt; 的用法举例 在 Makefile 中，$&lt; 是一个自动变量，用于表示第一个依赖文件。它通常用于规则的配方（recipe）中，以便引用目标文件的第一个依赖文件。 下面是一个简单的例子，展示了如何使用 $&lt;： # 定义编译器和编译选项CC = gccCFLAGS = -Wall -g# 定义目标文件TARGET = myprogram# 定义源文件和对象文件SRCS = main.c utils.cOBJS = $(SRCS:.c=.o)# 默认目标all: $(TARGET)# 链接目标文件$(TARGET): $(OBJS) $(CC) $(CFLAGS) -o $@ $^# 编译源文件到对象文件%.o: %.c $(CC) $(CFLAGS) -c $&lt; -o $@# 清理生成的文件clean: rm -f $(OBJS) $(TARGET) 在这个示例中，%.o: %.c 是一个模式规则，表示所有的 .c 文件都会被编译成对应的 .o 文件。在该规则的配方中，$&lt; 用于表示模式匹配的第一个依赖文件，即当前正在被编译的 .c 文件。 例如，当 main.c 需要被编译时，$&lt; 的值就是 main.c，对应的命令行就是： gcc -Wall -g -c main.c -o main.o 同样地，当 utils.c 需要被编译时，$&lt; 的值就是 utils.c，对应的命令行就是： gcc -Wall -g -c utils.c -o utils.o 通过使用 $&lt;，可以使 Makefile 更加简洁和灵活，因为它自动引用了当前的源文件，而无需手动指定。 Makefile 什么时候会执行结束 在Makefile中，行的结束由换行符（\\n）或分号（;）来表示。Make会按行读取Makefile，并执行每一行中的命令，直到遇到一个新的规则或者文件结束。 如果一行太长而无法在一行中显示，可以使用反斜杠（\\）将其分隔成多行。Make会将多行拼接在一起视为单独的一行。例如： target: dependency1 dependency2 \\ dependency3 command1 command2 这个规则定义了一个名为target的目标，它依赖于dependency1、dependency2和dependency3。当这个目标被执行时，会依次执行command1和command2。Make会将命令1和命令2视为同一行的一部分，直到遇到一个新的规则或文件结束。 因此，Make会根据换行符、分号以及反斜杠来确定命令的结束，而不是根据特定的行结束符。","link":"/2024/06/06/%E7%A7%AF%E7%B4%AF/%E9%9A%8F%E7%AC%94%E9%97%AE%E9%A2%98/"},{"title":"","text":"关于链接脚本和汇编导致的数据段初始化错误的问题 问题 第一个链接脚本存在data 段初始化失败的问题，第二个link 脚本增加了At&gt;flash就可以正常的运行了，是为什么？如果只是链接错误的话，那么汇编从ram 向同地址的ram 中搬运为什么就会运行出错？ 链接脚本分别如下： 有错误的类型 MEMORY{ flash (rxai!w) : ORIGIN = 0x20000000, LENGTH = 256k ram (wxa!ri) : ORIGIN = 0x20040000, LENGTH = 384k } .lalign : { . = ALIGN(4); PROVIDE( _data_lma = . ); } &gt; flash .dalign : { . = ALIGN(4); PROVIDE( _data = . ); } &gt; ram .data : { *(.data .data.*) *(.gnu.linkonce.d.*) . = ALIGN(8); PROVIDE( __global_pointer$ = . + 0x800 ); *(.sdata .sdata.*) *(.gnu.linkonce.s.*) . = ALIGN(8); *(.srodata.cst16) *(.srodata.cst8) *(.srodata.cst4) *(.srodata.cst2) *(.srodata .srodata.*) } &gt; ram 没有错误的类型 .lalign :{ . = ALIGN(4); PROVIDE( _data_lma = . );} &gt;rom AT&gt;flash :flash.dalign :{ . = ALIGN(4); PROVIDE( _data = . );} &gt;ram AT&gt;flash :ram_init.data :{ *(.data .data.*) *(.gnu.linkonce.d.*) . = ALIGN(8); PROVIDE( __global_pointer$ = . + 0x800 ); *(.sdata .sdata.*) *(.gnu.linkonce.s.*) . = ALIGN(8); *(.srodata.cst16) *(.srodata.cst8) *(.srodata.cst4) *(.srodata.cst2) *(.srodata .srodata.*)} &gt;ram AT&gt;flash :ram_init 汇编语言搬运data段的操作 la a0, _data_lma la a1, _data la a2, _edata bgeu a1, a2, 2f1: lw t0, (a0) sw t0, (a1) addi a0, a0, 4 addi a1, a1, 4 bltu a1, a2, 1b2: 分析如下： 原来存在的问题和分析思路 问题：上诉所说第一个链接脚本存在data 段初始化失败的问题，第二个link 脚本增加了At&gt;flash就可以正常的运行了，是为什么？如果只是链接错误的话，那么汇编从ram 向同地址的ram 中搬运为什么就会运行出错？ 解决思路： 确认链接器会把data 段的数据放在哪里？ 真正代码跑起来的时候，mcu 会去哪里取代码？这个是由谁决定的？连接器还是编译器？ 目前问题的逻辑解释 对于问题1：一般情况下不加AT 属性就会编译在哪个内存空间，就存放在哪个内存空间。 对于问题2：真正代码跑起来的时候，mcu 会去ram 中取data段，这个是由连接器决定的（连接器会 为每个符号分配地址？），因为两个lds 文件都是把data 段放在了ram 的区域。 原因解释，对应这个问题，有以下几点 符号的定义，结合上面的lds 源码，_data_lma 永远在 flash地址，_data永远在ram地址 汇编代码：结合汇编，永远是从_data_lma 搬运 到data 地址处 链接脚本：第一种错误的链接脚本，没有加At&gt;flash,data 段存放和使用地址都在 ram区域（data 地址开始），这个时候汇编代码还将_data_lma_ 的数据搬运到 data 处就会导致将错误的数据覆盖了正确的数据。 第二种正确的链接脚本，加个At&gt;flash，data 段存放地址在_data_lma_ 开始的地址和使用地址在_data_开始的地址，这个时候利用汇编代码将_data_lma_ 的数据搬运到 data 处，就是将数据搬运到了改在的位置，程序能正常运行。 对于符号的数值定义很重要 MEMORY{ flash (rxai!w) : ORIGIN = 0x20000000, LENGTH = 256k ram (wxa!ri) : ORIGIN = 0x20040000, LENGTH = 384k } .lalign : { . = ALIGN(4); PROVIDE( _data_lma = . ); /* 这里的_data_lma 可以看到就是flash 中的地址 */ } &gt; flash .dalign : { . = ALIGN(4); PROVIDE( _data = . ); /* 这里的 _data 地址是ram中的地址*/ } &gt; ram 由于链接的时候选择了将.data 段编译到了ram 中，所以实际的时候取数会去ram的地址取值。 .data : {、、、、、、 } &gt;ram 待后续补充 用readelf 查看两种编译方式编译出来的section的区别","link":"/2024/06/04/%E7%A7%AF%E7%B4%AF/lds%E9%97%AE%E9%A2%98/"}],"tags":[],"categories":[{"name":"uboot_linux","slug":"uboot-linux","link":"/categories/uboot-linux/"},{"name":"积累","slug":"积累","link":"/categories/%E7%A7%AF%E7%B4%AF/"}],"pages":[{"title":"categories","text":"","link":"/categories/index.html"}]}