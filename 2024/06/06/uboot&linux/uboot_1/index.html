<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>Hexo</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="Hexo"><meta name="msapplication-TileImage" content="/img/favicon.svg"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="Hexo"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="从头理清uboot（2）-启动流程分析[toc] 1.总体流程图123graph TB上电--&amp;gt;a[entry: start] --&amp;gt;设置中断向量表,跳转到reset--&amp;gt;设置处理器工作模式--&amp;gt;设置CP的值&amp;#x2F;初始化中断向量表--&amp;gt;关闭mmu,初始化堆栈值--&amp;gt;初始化gd结构体:完成内存布局初步分配--&amp;gt;c[利用函数指针初始化函数]c--&amp;gt;代码重定位"><meta property="og:type" content="blog"><meta property="og:title" content="Hexo"><meta property="og:url" content="https://satelite98.github.io/2024/06/06/uboot&amp;linux/uboot_1/"><meta property="og:site_name" content="Hexo"><meta property="og:description" content="从头理清uboot（2）-启动流程分析[toc] 1.总体流程图123graph TB上电--&amp;gt;a[entry: start] --&amp;gt;设置中断向量表,跳转到reset--&amp;gt;设置处理器工作模式--&amp;gt;设置CP的值&amp;#x2F;初始化中断向量表--&amp;gt;关闭mmu,初始化堆栈值--&amp;gt;初始化gd结构体:完成内存布局初步分配--&amp;gt;c[利用函数指针初始化函数]c--&amp;gt;代码重定位"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://satelite98.github.io/img/og_image.png"><meta property="article:published_time" content="2024-06-06T15:00:09.070Z"><meta property="article:modified_time" content="2024-06-06T15:02:39.857Z"><meta property="article:author" content="John Doe"><meta property="twitter:card" content="summary"><meta property="twitter:image:src" content="https://satelite98.github.io/img/og_image.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://satelite98.github.io/2024/06/06/uboot&linux/uboot_1/"},"headline":"Hexo","image":["https://satelite98.github.io/img/og_image.png"],"datePublished":"2024-06-06T15:00:09.070Z","dateModified":"2024-06-06T15:02:39.857Z","author":{"@type":"Person","name":"John Doe"},"publisher":{"@type":"Organization","name":"Hexo","logo":{"@type":"ImageObject","url":"https://satelite98.github.io/img/logo.svg"}},"description":"从头理清uboot（2）-启动流程分析[toc] 1.总体流程图123graph TB上电--&gt;a[entry: start] --&gt;设置中断向量表,跳转到reset--&gt;设置处理器工作模式--&gt;设置CP的值&#x2F;初始化中断向量表--&gt;关闭mmu,初始化堆栈值--&gt;初始化gd结构体:完成内存布局初步分配--&gt;c[利用函数指针初始化函数]c--&gt;代码重定位"}</script><link rel="canonical" href="https://satelite98.github.io/2024/06/06/uboot&amp;linux/uboot_1/"><link rel="icon" href="/img/favicon.svg"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v6.0.0/css/all.css"><link data-pjax rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@11.7.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link data-pjax rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/css/justifiedGallery.min.css"><!--!--><!--!--><!--!--><style>.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pace-inactive{display:none}.pace .pace-progress{background:#3273dc;position:fixed;z-index:2000;top:0;right:100%;width:100%;height:2px}</style><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js"></script><!--!--><!--!--><!-- hexo injector head_end start --><script>
  (function () {
      function switchTab() {
          if (!location.hash) {
            return;
          }

          const id = '#' + CSS.escape(location.hash.substring(1));
          const $tabMenu = document.querySelector(`.tabs a[href="${id}"]`);
          if (!$tabMenu) {
            return;
          }

          const $tabMenuContainer = $tabMenu.parentElement.parentElement;
          Array.from($tabMenuContainer.children).forEach($menu => $menu.classList.remove('is-active'));
          Array.from($tabMenuContainer.querySelectorAll('a'))
              .map($menu => document.getElementById($menu.getAttribute("href").substring(1)))
              .forEach($content => $content.classList.add('is-hidden'));

          if ($tabMenu) {
              $tabMenu.parentElement.classList.add('is-active');
          }
          const $activeTab = document.querySelector(id);
          if ($activeTab) {
              $activeTab.classList.remove('is-hidden');
          }
      }
      switchTab();
      window.addEventListener('hashchange', switchTab, false);
  })();
  </script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.2.0"></head><body class="is-2-column"><nav class="navbar navbar-main"><div class="container navbar-container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/logo.svg" alt="Hexo" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/about">About</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-8-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2024-06-06T15:00:09.070Z" title="2024/6/6 23:00:09">2024-06-06</time>发表</span><span class="level-item"><time dateTime="2024-06-06T15:02:39.857Z" title="2024/6/6 23:02:39">2024-06-06</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/uboot-linux/">uboot_linux</a></span><span class="level-item">41 分钟读完 (大约6175个字)</span></div></div><div class="content"><h1 id="从头理清uboot（2）-启动流程分析"><a href="#从头理清uboot（2）-启动流程分析" class="headerlink" title="从头理清uboot（2）-启动流程分析"></a>从头理清uboot（2）-启动流程分析</h1><p>[toc]</p>
<h2 id="1-总体流程图"><a href="#1-总体流程图" class="headerlink" title="1.总体流程图"></a>1.总体流程图</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">graph TB</span><br><span class="line">上电--&gt;a[entry: start] --&gt;设置中断向量表,跳转到reset--&gt;设置处理器工作模式--&gt;设置CP的值/初始化中断向量表--&gt;关闭mmu,初始化堆栈值--&gt;初始化gd结构体:完成内存布局初步分配--&gt;c[利用函数指针初始化函数]</span><br><span class="line">c--&gt;代码重定位--&gt;dyn段的table值重定位+向量表重定位--&gt;再次执行函数指针数组--&gt;进入main_loop函数</span><br></pre></td></tr></table></figure>

<h2 id="2-逐步分析"><a href="#2-逐步分析" class="headerlink" title="2. 逐步分析"></a>2. 逐步分析</h2><h3 id="2-1-上电后执行的第一条指令"><a href="#2-1-上电后执行的第一条指令" class="headerlink" title="2.1 上电后执行的第一条指令"></a>2.1 上电后执行的第一条指令</h3><p>由于在编译的时候有下面的链接命令：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arm-linux-gnueabihf-ld.bfd   -pie  --gc-sections -Bstatic -Ttext 0x87800000 -o u-boot -T u-boot.lds arch/arm/cpu/armv7/start.o --start-group  arch/arm/cpu/built-in.o ...... test/dm/built-in.o --end-group arch/arm/lib/eabi_compat.o  -L /usr/lib/gcc-cross/arm-linux-gnueabihf/9 -lgcc -Map u-boot.map</span><br></pre></td></tr></table></figure>

<p>所以其实是利用<code>u-boot.lds</code>来链接整个bin 文件的。那么就可以在lds 中看到uboot 的程序入口：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">ENTRY(_start)</span><br><span class="line">SECTIONS</span><br><span class="line">&#123;</span><br><span class="line"> . = 0x00000000;</span><br><span class="line"> . = ALIGN(4);</span><br><span class="line"> .text :</span><br><span class="line"> &#123;</span><br><span class="line">  *(.__image_copy_start)</span><br><span class="line">  *(.vectors)</span><br><span class="line">  arch/arm/cpu/armv7/start.o (.text*)</span><br><span class="line">  *(.text*)</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>在<code>arch/arm/lib/vector.s</code>中能够找到<code>_start</code>的具体实现：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">_start:</span><br><span class="line">#ifdef CONFIG_SYS_DV_NOR_BOOT_CFG</span><br><span class="line">	.word	CONFIG_SYS_DV_NOR_BOOT_CFG</span><br><span class="line">#endif</span><br><span class="line">	b	reset</span><br><span class="line">	ldr	pc, _undefined_instruction</span><br><span class="line">	ldr	pc, _software_interrupt</span><br><span class="line">	ldr	pc, _prefetch_abort</span><br><span class="line">	ldr	pc, _data_abort</span><br><span class="line">	ldr	pc, _not_used</span><br><span class="line">	ldr	pc, _irq</span><br><span class="line">	ldr	pc, _fiq</span><br></pre></td></tr></table></figure>

<p>​		由此我们找到了程序上电执行的第一条指令。</p>
<h3 id="2-2-初始化中断向量表"><a href="#2-2-初始化中断向量表" class="headerlink" title="2.2 初始化中断向量表"></a>2.2 初始化中断向量表</h3><p>​		由上可知，_start的汇编代码的作用便是初始化了中断向量表，并且跳转像了<code>reset</code>函数。至于为什么这里实现了跳转了中断向量表，可先参考这个blog 学习：</p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/liangliangge/p/12549087.html">https://www.cnblogs.com/liangliangge/p/12549087.html</a>  </p>
<p>&#x3D;&#x3D;TODO：补充armv7 中断处理功能&#x3D;&#x3D;</p>
<h3 id="2-3-初始化工作模式-初始化中断向量表。"><a href="#2-3-初始化工作模式-初始化中断向量表。" class="headerlink" title="2.3 初始化工作模式 &amp; 初始化中断向量表。"></a>2.3 初始化工作模式 &amp; 初始化中断向量表。</h3><p>​		在<code>_start</code>函数中，会跳到<code>reset</code>函数（在<code>arch/arm/cpu/armv7/start.s</code>）中，其函数如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">	.globl	reset</span><br><span class="line">	.globl	save_boot_params_ret</span><br><span class="line"></span><br><span class="line">reset:</span><br><span class="line">	......<span class="comment">//中间代码边分析边给出</span></span><br><span class="line">	bl	_main</span><br></pre></td></tr></table></figure>

<p>​		进入reset 之后，首先执行的就是<code>b  save_boot_params</code>但是又会跳回<code>save_boot_params_ret:</code>，在reset 中再次执行，由于定义是week 的，最后实际实现还可以再覆盖。见下方代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ENTRY(save_boot_params)</span><br><span class="line">	b	save_boot_params_ret</span><br><span class="line"><span class="title function_">ENDPROC</span><span class="params">(save_boot_params)</span></span><br><span class="line">	.weak	save_boot_params</span><br></pre></td></tr></table></figure>

<p>​		之后便会初始化处理器的工作模式及关闭中断，见下方代码，注释已经写入其中。</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/zhoutaopower/article/details/113746587">https://blog.csdn.net/zhoutaopower/article/details/113746587</a></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mrs	r0, cpsr			<span class="comment">//读cpsr 的值到r0</span></span><br><span class="line">and	r1, r0, #<span class="number">0x1f</span>		<span class="comment">//取 低五位到r1</span></span><br><span class="line">teq	r1, #<span class="number">0x1a</span>			<span class="comment">//判断是，即判断是不是HYP模式</span></span><br><span class="line">bicne	r0, r0, #<span class="number">0x1f</span>	<span class="comment">//不是，就清除低五位</span></span><br><span class="line">orrne	r0, r0, #<span class="number">0x13</span>	<span class="comment">//不是，设置为SVC 模式</span></span><br><span class="line">orr	r0, r0, #<span class="number">0xc0</span>		<span class="comment">//关闭FIQ 和IRQ</span></span><br><span class="line">msr	cpsr,r0				<span class="comment">//把新的r0 值写入CPSR</span></span><br></pre></td></tr></table></figure>

<p>​		其次就会设置SCTLR 的值，这里会涉及到armv7 的CP 寄存器，可以见这篇文章：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/lifexy/p/7203786.html">协处理器CP15介绍—MCR&#x2F;MRC指令(6) - 诺谦 - 博客园 (cnblogs.com)</a>，uboot 汇编相关见下方注释：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> !(defined(CONFIG_OMAP44XX) &amp;&amp; defined(CONFIG_SPL_BUILD))</span></span><br><span class="line">	<span class="comment">/* Set V=0 in CP15 SCTLR register - for VBAR to point to vector */</span></span><br><span class="line">	mrc	p15, <span class="number">0</span>, r0, c1, c0, <span class="number">0</span>	<span class="comment">//把cp15寄存器中c1控制位 读到r0中</span></span><br><span class="line">	bic	r0, #CR_V				<span class="comment">//清除r0 中的 CR_V 控制位，表示向量表地址为0x00000000,且可以重定位向量表。</span></span><br><span class="line">	mcr	p15, <span class="number">0</span>, r0, c1, c0, <span class="number">0</span>	<span class="comment">//把r0写回 cp15-c1</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Set vector address in CP15 VBAR register */</span></span><br><span class="line">	ldr	r0, =_start</span><br><span class="line">	mcr	p15, <span class="number">0</span>, r0, c12, c0, <span class="number">0</span>	 <span class="comment">//把_start设置为向量表地址，写入 cp15-c12</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<h3 id="2-4-cpu-init-cp15-cpu-init-crit"><a href="#2-4-cpu-init-cp15-cpu-init-crit" class="headerlink" title="2.4 cpu_init_cp15 &amp; cpu_init_crit"></a>2.4 cpu_init_cp15 &amp; cpu_init_crit</h3><p>​		在设置好中断向量表之后，在<code>reset </code>中会做两个<strong>CPU 核</strong>相关的init动作，之后便会跳转到<code>_main</code>执行，见下方代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> CONFIG_SKIP_LOWLEVEL_INIT</span></span><br><span class="line">	bl	cpu_init_cp15</span><br><span class="line">	bl	cpu_init_crit</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	bl	_main</span><br></pre></td></tr></table></figure>

<p>我们依次分析这两个函数都做了什么事情：</p>
<h4 id="2-4-1-cpu-init-cp15"><a href="#2-4-1-cpu-init-cp15" class="headerlink" title="2.4.1 cpu_init_cp15"></a>2.4.1 cpu_init_cp15</h4><p>​		通过下方代码，可以看出，功能为：关闭指令cache、清空写和预取缓存区，关闭mmu、使能地址跳转预测、获取CPU信息并且根据CPU info  信息的不同来做处理。下方直接将注释写入下方代码段中：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line">/*************************************************************************</span><br><span class="line"> *</span><br><span class="line"> * cpu_init_cp15</span><br><span class="line"> *</span><br><span class="line"> * Setup CP15 registers (cache, MMU, TLBs). The I-cache is turned on unless</span><br><span class="line"> * CONFIG_SYS_ICACHE_OFF is defined.</span><br><span class="line"> *</span><br><span class="line"> *************************************************************************/</span><br><span class="line">ENTRY(cpu_init_cp15)</span><br><span class="line">	/*</span><br><span class="line">	 * Invalidate L1 I/D</span><br><span class="line">	 */</span><br><span class="line">	mov	r0, #0			@ set up for MCR</span><br><span class="line">	mcr	p15, 0, r0, c8, c7, 0	@ 无效整个数据和指令TLB</span><br><span class="line">	mcr	p15, 0, r0, c7, c5, 0	@无效整个指令cache</span><br><span class="line">	mcr	p15, 0, r0, c7, c5, 6	@ 无效整个跳转目标cache</span><br><span class="line">	mcr p15, 0, r0, c7, c10, 4	@ 清空写缓存区</span><br><span class="line">	mcr p15, 0, r0, c7, c5, 4	@ 清空预取缓存区</span><br><span class="line"></span><br><span class="line">	/*</span><br><span class="line">	 * disable MMU stuff and caches</span><br><span class="line">	 */</span><br><span class="line">	mrc	p15, 0, r0, c1, c0, 0	@把cp15-c1 的值读到r0中</span><br><span class="line">	bic	r0, r0, #0x00002000	@ 设置低端一场中断向量表，且在可重定位状态</span><br><span class="line">	bic	r0, r0, #0x00000007	@ 关闭mmu、地址对齐、禁止cache</span><br><span class="line">	orr	r0, r0, #0x00000002	@ 使能地址对齐检查</span><br><span class="line">	orr	r0, r0, #0x00000800	@ 使能跳转预测</span><br><span class="line">#ifdef CONFIG_SYS_ICACHE_OFF</span><br><span class="line">	bic	r0, r0, #0x00001000	@ 关闭 I-cahe</span><br><span class="line">#else</span><br><span class="line">	orr	r0, r0, #0x00001000	@ 使能 I-cahe</span><br><span class="line">#endif</span><br><span class="line">	mcr	p15, 0, r0, c1, c0, 0</span><br><span class="line"></span><br><span class="line">#ifdef CONFIG_ARM_ERRATA_716044  --使能跳转预测</span><br><span class="line">	mrc	p15, 0, r0, c1, c0, 0	@ read system control register</span><br><span class="line">	orr	r0, r0, #1 &lt;&lt; 11	@ set bit #11</span><br><span class="line">	mcr	p15, 0, r0, c1, c0, 0	@ write system control register</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">  --C15 寄存器会随着设计的不同而不同。</span><br><span class="line">#if (defined(CONFIG_ARM_ERRATA_742230) || defined(CONFIG_ARM_ERRATA_794072))</span><br><span class="line">	mrc	p15, 0, r0, c15, c0, 1	@ read diagnostic register</span><br><span class="line">	orr	r0, r0, #1 &lt;&lt; 4		@ set bit #4</span><br><span class="line">	mcr	p15, 0, r0, c15, c0, 1	@ write diagnostic register</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line"> 		.</span><br><span class="line"> 		. @中间为相似判断，省略</span><br><span class="line"> 		.</span><br><span class="line"> 		.</span><br><span class="line"> 		.</span><br><span class="line"> 		.</span><br><span class="line"></span><br><span class="line">	mov	r5, lr			@ Store my Caller 保存下lr指针，保存函数返回地址</span><br><span class="line">	mrc	p15, 0, r1, c0, c0, 0	@ 把cp15-c0-主标识符 读到r1</span><br><span class="line">	mov	r3, r1, lsr #20		@ 将r1 右移20bit ,存储到r3</span><br><span class="line">	and	r3, r3, #0xf		@获取r1[23:20]</span><br><span class="line">	and	r4, r1, #0xf		@ 获取r1[4:0]</span><br><span class="line">	mov	r2, r3, lsl #4		@ shift variant field for combined value</span><br><span class="line">	orr	r2, r4, r2		@ r2= r1[23:20] + r1[4:0] = c0[23:20] + c0[4:0] CPU variant + revision</span><br><span class="line"></span><br><span class="line"> 		.</span><br><span class="line"> 		. @中间为相似判断，省略</span><br><span class="line"> 		.</span><br><span class="line"> 		.</span><br><span class="line"> 		.</span><br><span class="line"> 		.</span><br><span class="line"></span><br><span class="line">#ifdef CONFIG_ARM_ERRATA_621766</span><br><span class="line">	cmp	r2, #0x21		@ Only on &lt; r2p1</span><br><span class="line">	bge	skip_errata_621766</span><br><span class="line"></span><br><span class="line">	mrc	p15, 0, r0, c1, c0, 1	@ Read ACR</span><br><span class="line">	orr	r0, r0, #(0x1 &lt;&lt; 5)	@ Set L1NEON bit</span><br><span class="line">	push	&#123;r1-r5&#125;			@ Save the cpu info registers</span><br><span class="line">	bl	v7_arch_cp15_set_acr</span><br><span class="line">	pop	&#123;r1-r5&#125;			@ Restore the cpu info - fall through</span><br><span class="line"></span><br><span class="line">skip_errata_621766:</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">	mov	pc, r5			@ 退出函数执行，跳回。</span><br><span class="line">ENDPROC(cpu_init_cp15)</span><br></pre></td></tr></table></figure>



<h4 id="2-4-1-cpu-init-crit"><a href="#2-4-1-cpu-init-crit" class="headerlink" title="2.4.1 cpu_init_crit"></a>2.4.1 cpu_init_crit</h4><p>​		跳入 <code>lowlevel_init</code>函数，在<code>arch/arm/cpu/armv7/lowlevel_init.s</code>中有定义，可见初步作用是初始化栈，调用<code>s_init</code>函数，定义在<code>arch/arm/cpu/armv7/mx6/soc.c</code>，但是对于<code>imax6ull</code>而言就是个空函数，故整体而言，这里只是做了一个获取<code>CONFIG_SYS_INIT_SP_ADDR</code>的值，做了下sp 的初始化，给<code>GD_SIZE</code>留出空间。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">ENTRY(lowlevel_init)</span><br><span class="line"></span><br><span class="line">	ldr	sp, =CONFIG_SYS_INIT_SP_ADDR</span><br><span class="line">	bic	sp, sp, #7 /*8byte对齐*/</span><br><span class="line">#ifdef CONFIG_SPL_DM</span><br><span class="line">	mov	r9, #0</span><br><span class="line">#else</span><br><span class="line">#ifdef CONFIG_SPL_BUILD  </span><br><span class="line">	ldr	r9, =gdata</span><br><span class="line">#else</span><br><span class="line">	sub	sp, sp, #GD_SIZE  @减去 GD_SIZE 的值。</span><br><span class="line">	bic	sp, sp, #7 /*8byte对齐*/</span><br><span class="line">	mov	r9, sp</span><br><span class="line">#endif</span><br><span class="line">#endif</span><br><span class="line">	push	&#123;ip, lr&#125; @将IP  和 lr  都压入栈中</span><br><span class="line">	bl	s_init</span><br><span class="line">	pop	&#123;ip, pc&#125; @将IP  和 lr  都出栈</span><br><span class="line">ENDPROC(lowlevel_init)</span><br></pre></td></tr></table></figure>

<p>​		对于<code>CONFIG_SYS_INIT_SP_ADDR</code>和&#96;&#96;在<code>include/configs/mx6sllevk.h</code>中有定义：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> CONFIG_SYS_INIT_RAM_ADDR	IRAM_BASE_ADDR</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CONFIG_SYS_INIT_RAM_SIZE	IRAM_SIZE</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CONFIG_SYS_INIT_SP_OFFSET \</span></span><br><span class="line"><span class="meta">	(CONFIG_SYS_INIT_RAM_SIZE - GENERATED_GBL_DATA_SIZE)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CONFIG_SYS_INIT_SP_ADDR \</span></span><br><span class="line"><span class="meta">	(CONFIG_SYS_INIT_RAM_ADDR + CONFIG_SYS_INIT_SP_OFFSET)</span></span><br></pre></td></tr></table></figure>

<p>​		其中<code>IRAM_BASE_ADDR</code>和 <code>IRAM_SIZE</code>在&#96;&#96;arch&#x2F;arm&#x2F;include&#x2F;asm&#x2F;arch-mx6&#x2F;imx-regs.h&#96;中有定义,可以看出，这应该是CPU内部的<strong>ram</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> IRAM_BASE_ADDR			0x00900000</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> !(defined(CONFIG_MX6SX) || defined(CONFIG_MX6UL) || \</span></span><br><span class="line"><span class="meta">	defined(CONFIG_MX6SLL) || defined(CONFIG_MX6SL))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IRAM_SIZE                    0x00040000</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IRAM_SIZE                    0x00020000</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>​		我们还需要知道<code>GENERATED_GBL_DATA_SIZE</code>和<code>GD_SIZE</code>的值，都定义在<code>include/generated/generic-asm-offsets.h</code>中，有以下定义：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> GENERATED_GBL_DATA_SIZE 256 <span class="comment">/* (sizeof(struct global_data) + 15) &amp; ~15	@ */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GENERATED_BD_INFO_SIZE 80 <span class="comment">/* (sizeof(struct bd_info) + 15) &amp; ~15	@ */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GD_SIZE 248 <span class="comment">/* sizeof(struct global_data)	@ */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GD_BD 0 <span class="comment">/* offsetof(struct global_data, bd)	@ */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GD_MALLOC_BASE 188 <span class="comment">/* offsetof(struct global_data, malloc_base)	@ */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GD_RELOCADDR 44 <span class="comment">/* offsetof(struct global_data, relocaddr)	@ */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GD_RELOC_OFF 64 <span class="comment">/* offsetof(struct global_data, reloc_off)	@ */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GD_START_ADDR_SP 60 <span class="comment">/* offsetof(struct global_data, start_addr_sp)	@ */</span></span></span><br></pre></td></tr></table></figure>

<p>​		由此我们可以得到当前的栈指针的值：</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">*</span> sp = CONFIG<span class="emphasis">_SYS_</span>INIT<span class="emphasis">_SP_</span>ADDR =  (CONFIG<span class="emphasis">_SYS_</span>INIT<span class="emphasis">_RAM_</span>ADDR + CONFIG<span class="emphasis">_SYS_</span>INIT<span class="emphasis">_RAM_</span>SIZE - GENERATED<span class="emphasis">_GBL_</span>DATA<span class="emphasis">_SIZE) = 0x00900000 + 0x00020000 -256 = 0x0091FF00</span></span><br><span class="line"><span class="emphasis">* sp = sp - GD_</span>SIZE = 0x0091FF00 - 248 = 0x0091FE08 </span><br><span class="line"><span class="bullet">*</span> bic	sp, sp, #7 --&gt; sp = 0x0091FE00</span><br></pre></td></tr></table></figure>

<h3 id="2-5-进入-main-函数"><a href="#2-5-进入-main-函数" class="headerlink" title="2.5 进入_main 函数"></a>2.5 进入_main 函数</h3><p>​		&#x3D;&#x3D;补充重点：&#x3D;&#x3D;<strong>建议看crt0.S 中关于_main 函数的作用，里面解释了为什么会有这些流程</strong></p>
<p>​		在上面步骤，应该是初步完成了CPU的一些配置，解下来会进入_main函数，进一步完成系统级的初始化工作。   <code>__main</code>函数定义在<code> arch/arm/lib/crt0.S</code>中。【crt0.S 作用是 准备计入C语言需要的环境。】</p>
<p>​	首先判断是否定义了SPL build 相关，初始化栈sp 指针。然后会分别调用<code>board_init_f_alloc_reserve</code>、<code>board_init_f_init_reserve</code>、<code>board_init_f</code>(r0 &#x3D;&#x3D;0),可见下方代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">ENTRY(_main)</span><br><span class="line">/*</span><br><span class="line"> * Set up initial C runtime environment and call board_init_f(0).</span><br><span class="line"> */</span><br><span class="line">#if defined(CONFIG_SPL_BUILD) &amp;&amp; defined(CONFIG_SPL_STACK)</span><br><span class="line">	ldr	sp, =(CONFIG_SPL_STACK)</span><br><span class="line">#else</span><br><span class="line">	ldr	sp, =(CONFIG_SYS_INIT_SP_ADDR)</span><br><span class="line">#endif</span><br><span class="line">#if defined(CONFIG_CPU_V7M)	/* v7M forbids using SP as BIC destination */</span><br><span class="line">	mov	r3, sp</span><br><span class="line">	bic	r3, r3, #7</span><br><span class="line">	mov	sp, r3</span><br><span class="line">#else</span><br><span class="line">	bic	sp, sp, #7	/* 8-byte alignment for ABI compliance */</span><br><span class="line">#endif</span><br><span class="line">	mov	r0, sp</span><br><span class="line">	bl	board_init_f_alloc_reserve</span><br><span class="line">	mov	sp, r0  </span><br><span class="line">	/* set up gd here, outside any C code */</span><br><span class="line">	mov	r9, r0</span><br><span class="line">	bl	board_init_f_init_reserve</span><br><span class="line"></span><br><span class="line">	mov	r0, #0</span><br><span class="line">	bl	board_init_f</span><br><span class="line"></span><br><span class="line">#if ! defined(CONFIG_SPL_BUILD)</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> * Set up intermediate environment (new sp and gd) and call</span><br><span class="line"> * relocate_code(addr_moni). Trick here is that we&#x27;ll return</span><br><span class="line"> * &#x27;here&#x27; but relocated.</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">	ldr	sp, [r9, #GD_START_ADDR_SP]	/* sp = gd-&gt;start_addr_sp */</span><br><span class="line">	.......</span><br></pre></td></tr></table></figure>

<h4 id="2-5-1-board-init-f-alloc-reserve（sp）"><a href="#2-5-1-board-init-f-alloc-reserve（sp）" class="headerlink" title="2.5.1 board_init_f_alloc_reserve（sp）"></a>2.5.1 board_init_f_alloc_reserve（sp）</h4><p>​	其中调用的<code>board_init_f_alloc_reserve（sp）</code>在<code>common/init/board_init.c</code>中，这个函数有一个传参，实际为sp 的值，可见这个函数的作用为在栈中留出<code>CONFIG_SYS_MALLOC_F_LEN = 0x400</code>大小和<code>global_data</code>结构体的大小(GD_SIZE)空间区域后，进行一个16byte 的对齐操作。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ulong <span class="title function_">board_init_f_alloc_reserve</span><span class="params">(ulong top)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/* Reserve early malloc arena */</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(CONFIG_SYS_MALLOC_F)</span></span><br><span class="line">	top -= CONFIG_SYS_MALLOC_F_LEN;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="comment">/* LAST : reserve GD (rounded up to a multiple of 16 bytes) */</span></span><br><span class="line">	top = rounddown(top-<span class="keyword">sizeof</span>(<span class="keyword">struct</span> global_data), <span class="number">16</span>);</span><br><span class="line">	<span class="keyword">return</span> top;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​		所以当前的sp 为：<code>0x0091FF00 - 0x400 - 248 = 0x0091Fa00 </code>。出栈后会把<strong>算好的r0 在赋值给sp</strong>，同时赋值g给r9。</p>
<h4 id="2-5-2-board-init-f-init-reserve（sp）"><a href="#2-5-2-board-init-f-init-reserve（sp）" class="headerlink" title="2.5.2 board_init_f_init_reserve（sp）"></a>2.5.2 board_init_f_init_reserve（sp）</h4><p>​	之后会调用<code>board_init_f_init_reserve</code>，对于imax6ull 条件编译之后见下方，可见主要作用为：</p>
<p>​		将当前sp 设置为<code>global_data</code>的基地址、<code>global_data</code>区域清0、然后把<code>gd-&gt;malloc_base</code>设置为base 加上<code>struct global_data</code>并且16字节取整，之后base 加上<code>CONFIG_SYS_MALLOC_F_LEN</code>长度。那么这个函数就是把<code>global_data</code>初始化了，把malloc地址指向了<code> 0x0091FF00 - 0x400</code>，然后把base设置为了<code>0x0091FF00 </code>再赋值给r0了。</p>
<p>​		作用：这里留出一块内存用于保存global_data和 执行后面的函数的内存空间</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">board_init_f_init_reserve</span><span class="params">(ulong base)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">global_data</span> *<span class="title">gd_ptr</span>;</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * clear GD entirely and set it up.</span></span><br><span class="line"><span class="comment">	 * Use gd_ptr, as gd may not be properly set yet.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	gd_ptr = (<span class="keyword">struct</span> global_data *)base;</span><br><span class="line">	<span class="comment">/* zero the area */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _USE_MEMCPY</span></span><br><span class="line">	<span class="built_in">memset</span>(gd_ptr, <span class="string">&#x27;\0&#x27;</span>, <span class="keyword">sizeof</span>(*gd));</span><br><span class="line">	<span class="comment">/* next alloc will be higher by one GD plus 16-byte alignment */</span></span><br><span class="line">	base += roundup(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> global_data), <span class="number">16</span>);</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * record early malloc arena start.</span></span><br><span class="line"><span class="comment">	 * Use gd as it is now properly set for all architectures.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(CONFIG_SYS_MALLOC_F)</span></span><br><span class="line">	<span class="comment">/* go down one &#x27;early malloc arena&#x27; */</span></span><br><span class="line">	gd-&gt;malloc_base = base;</span><br><span class="line">	<span class="comment">/* next alloc will be higher by one &#x27;early malloc arena&#x27; size */</span></span><br><span class="line">	base += CONFIG_SYS_MALLOC_F_LEN;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-5-3-board-init-f-0"><a href="#2-5-3-board-init-f-0" class="headerlink" title="2.5.3 board_init_f(0)"></a>2.5.3 board_init_f(0)</h4><p>​	<code>board_init_f</code>函数定义在<code> common/board_f.c</code>中，经过条件编译之后的结果为下图所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">board_init_f</span><span class="params">(ulong boot_flags)</span></span><br><span class="line">&#123;</span><br><span class="line">	gd-&gt;flags = boot_flags;</span><br><span class="line">	gd-&gt;have_console = <span class="number">0</span>;  </span><br><span class="line">	<span class="keyword">if</span> (initcall_run_list(init_sequence_f))</span><br><span class="line">		hang();</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> !defined(CONFIG_ARM) &amp;&amp; !defined(CONFIG_SANDBOX) &amp;&amp; \</span></span><br><span class="line"><span class="meta">		!defined(CONFIG_EFI_APP)</span></span><br><span class="line">	<span class="comment">/* NOTREACHED - jump_to_copy() does not return */</span></span><br><span class="line">	hang();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="comment">/* Light up LED1 */</span></span><br><span class="line">	imx6_light_up_led1();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​		<code>gd-&gt;have_console = 0;</code>表明现在还没有窗口。</p>
<p>​		其中<code>boot_flags == 0</code>作为输入传入，后续主要是执行<code>initcall_run_list(init_sequence_f)</code>这个函数，我们需要先看函数输入<code>init_sequence_f</code>的定义(已经经过条件编译，见下方)。</p>
<p>​		其中<code>init_fnc_t</code>的定义为<code>typedef int (*init_fnc_t)(void);</code>，由此这是一个函数指针结构体，而在<code>board_init_f</code>中调用的<code>initcall_run_list</code>函数就是会遍历执行下方的<code>init_sequence_f</code>函数结构体，来执行板级的初始化。对于被遍历的函数，大致功能见注释。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">init_fnc_t</span> init_sequence_f[] = &#123;</span><br><span class="line">    setup_mon_len, <span class="comment">//gd-&gt;mon_len = (ulong)&amp;__bss_end - (ulong)_start; 设置mon_len 为代码长度</span></span><br><span class="line">    initf_malloc,	<span class="comment">//gd-&gt;malloc_limit = 0x40; 当前内存池大小。</span></span><br><span class="line">	initf_console_record,	<span class="comment">//return 0;</span></span><br><span class="line">    arch_cpu_init,		<span class="comment">/* basic arch cpu dependent setup */</span></span><br><span class="line">	initf_dm,			<span class="comment">//初始化驱动模型相关</span></span><br><span class="line">	arch_cpu_init_dm,</span><br><span class="line">	mark_bootstage,		<span class="comment">/* need timer, go after init dm */</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(CONFIG_BOARD_EARLY_INIT_F)</span></span><br><span class="line">	board_early_init_f,		<span class="comment">//，I.MX6ULL 用来初始化串口的 IO 配置</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(CONFIG_ARM) || defined(CONFIG_MIPS) || \</span></span><br><span class="line"><span class="meta">		defined(CONFIG_BLACKFIN) || defined(CONFIG_NDS32) || \</span></span><br><span class="line"><span class="meta">		defined(CONFIG_SPARC)</span></span><br><span class="line">	timer_init,		<span class="comment">//初始化内部定时器</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span>    </span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(CONFIG_BOARD_POSTCLK_INIT)</span></span><br><span class="line">	board_postclk_init,		<span class="comment">//设置 VDDSOC 电压</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(CONFIG_SYS_FSL_CLK) || defined(CONFIG_M68K)</span></span><br><span class="line">	get_clocks,			<span class="comment">//可以配置获取多种时钟值，I.MX6ULL 获取的是 sdhc_clk 时钟</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	env_init,		<span class="comment">//gd-&gt;env_addr	= (ulong)&amp;default_environment[0]; 设置gd ENV 地址</span></span><br><span class="line">    init_baud_rate,		<span class="comment">/* 根据 “baudrate” 环境变量配置波特率 */</span></span><br><span class="line">	serial_init,		<span class="comment">/* 串口初始化 会调用函数指针 */</span></span><br><span class="line">	console_init_f,		<span class="comment">/* gd-&gt;have_console = 1; 配置输出窗口*/</span></span><br><span class="line">    display_options,	<span class="comment">/* 在窗口上显示输出 */</span></span><br><span class="line">	display_text_info,	<span class="comment">/* 在窗口上打印文本输出*/</span></span><br><span class="line">	print_cpuinfo,		<span class="comment">/* 打印CPU 信息 */</span>      </span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(CONFIG_DISPLAY_BOARDINFO)</span></span><br><span class="line">	show_board_info,	<span class="comment">/* 打印板子 信息 */</span>    </span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	INIT_FUNC_WATCHDOG_INIT     <span class="comment">/*初始化看门狗， I.MX6ULL 来说是空函数  */</span></span><br><span class="line">	INIT_FUNC_WATCHDOG_RESET 	<span class="comment">/*喂狗， I.MX6ULL 来说是空函数  */</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(CONFIG_HARD_I2C) || defined(CONFIG_SYS_I2C)</span></span><br><span class="line">	init_func_i2c,				<span class="comment">/* 初始化IIC */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span>        </span></span><br><span class="line">	announce_dram_init,</span><br><span class="line">	<span class="comment">/* <span class="doctag">TODO:</span> unify all these dram functions? */</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(CONFIG_ARM) || defined(CONFIG_X86) || defined(CONFIG_NDS32) || \</span></span><br><span class="line"><span class="meta">		defined(CONFIG_MICROBLAZE) || defined(CONFIG_AVR32)</span></span><br><span class="line">	dram_init,		<span class="comment">/*gd-&gt;ram_size = imx_ddr_size();把 外部能用的DDR大小付给gd-&gt;ram_size */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span>    </span></span><br><span class="line">    INIT_FUNC_WATCHDOG_RESET</span><br><span class="line">    INIT_FUNC_WATCHDOG_RESET</span><br><span class="line">    INIT_FUNC_WATCHDOG_RESET</span><br><span class="line"> 	setup_dest_addr,	<span class="comment">/* 这个函数下方详细介绍 */</span></span><br><span class="line">   	reserve_round_4k,	<span class="comment">/* gd-&gt;relocaddr &amp;= ~(4096 - 1);重定位地址4k 对齐 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> !(defined(CONFIG_SYS_ICACHE_OFF) &amp;&amp; defined(CONFIG_SYS_DCACHE_OFF)) &amp;&amp; \</span></span><br><span class="line"><span class="meta">		defined(CONFIG_ARM)</span></span><br><span class="line">	reserve_mmu,		<span class="comment">/* 这个函数下方详细介绍 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">   	reserve_trace,		<span class="comment">/*留出debug 空间，I.MX6ULL 来说是空函数*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> !defined(CONFIG_BLACKFIN)</span></span><br><span class="line">	reserve_uboot,		<span class="comment">/*留出 uboot code空间 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> CONFIG_SPL_BUILD</span></span><br><span class="line">	reserve_malloc,		<span class="comment">/*留出malloc 空间 TOTAL_MALLOC_LEN*/</span></span><br><span class="line">	reserve_board,		<span class="comment">/* 留出 sizeof(bd_t) 的空间*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	setup_machine,		<span class="comment">/* 设置机器id 等设置，I.MX6ULL 来说是空函数 */</span></span><br><span class="line">	reserve_global_data,	<span class="comment">/*留出sizeof(gd_t)的空间 */</span></span><br><span class="line">	reserve_fdt,		<span class="comment">/* 留出 fdt_size 的空间,I.MX6ULL 无效 */</span></span><br><span class="line">	reserve_arch,		<span class="comment">/* I.MX6ULL 来说是空函数 */</span></span><br><span class="line">	reserve_stacks,		<span class="comment">/*gd-&gt;start_addr_sp 栈顶做16字节对齐  */</span></span><br><span class="line">	setup_dram_config,	<span class="comment">/* 设置Dram的地址和大小，后续告诉linux 内核 */</span></span><br><span class="line">	show_dram_config,	<span class="comment">/* 打印上述信息  */</span></span><br><span class="line">	display_new_sp,    	<span class="comment">/* 打印sp-栈顶 */</span></span><br><span class="line">   	INIT_FUNC_WATCHDOG_RESET	</span><br><span class="line">	reloc_fdt,			<span class="comment">/* I.MX6ULL 没有用到 */</span></span><br><span class="line">重要：setup_reloc,		<span class="comment">/*设置一些重定位要用的参数，并且将gd 从ram中拷贝到DDR中* / </span></span><br><span class="line"><span class="comment">    	NULL,</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br></pre></td></tr></table></figure>

<p>可以看出，<code>board_init_f(0)</code>总体上是围绕<code>global_data</code>展开的，关于<code>global_data</code>可以参考这篇文档：<a target="_blank" rel="noopener" href="https://blog.csdn.net/wenjin359/article/details/82849492%EF%BC%8C">https://blog.csdn.net/wenjin359/article/details/82849492，</a></p>
<ul>
<li><p>setup_dest_addr 函数</p>
<ul>
<li><p>作用：初始化<code>gd-&gt;ram_siz</code>、<code>gd-&gt;ram_top</code>、<code>gd-&gt;relocaddr </code>。</p>
 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">setup_dest_addr</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	gd-&gt;ram_size = board_reserve_ram_top(gd-&gt;ram_size);<span class="comment">// ram_szie 前面已经init过了，是imx_ddr_size()</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SYS_SDRAM_BASE</span></span><br><span class="line">	gd-&gt;ram_top = CONFIG_SYS_SDRAM_BASE;	<span class="comment">//设置为DDR base 地址CONFIG_SYS_SDRAM_BASE</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	gd-&gt;ram_top += get_effective_memsize();<span class="comment">// base + gd-&gt;ram_size </span></span><br><span class="line">	gd-&gt;ram_top = board_get_usable_ram_top(gd-&gt;mon_len);</span><br><span class="line">	gd-&gt;relocaddr = gd-&gt;ram_top;			<span class="comment">//重定位地址 = gd-&gt;ram_top</span></span><br><span class="line">	debug(<span class="string">&quot;Ram top: %08lX\n&quot;</span>, (ulong)gd-&gt;ram_top);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>reserve_round_4k 函数，把刚刚初始化的<code>gd-&gt;relocaddr</code>地址4K对齐。<code>gd-&gt;relocaddr &amp;= ~(4096 - 1);</code></p>
</li>
<li><p>reserve_mmu:</p>
<ul>
<li>作用：在DDR中留出<code>PGTABLE_SIZE</code>大小的空间用于做tlb。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">reserve_mmu</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/* reserve TLB table */</span></span><br><span class="line">	gd-&gt;arch.tlb_size = PGTABLE_SIZE;</span><br><span class="line">	gd-&gt;relocaddr -= gd-&gt;arch.tlb_size;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* round down to next 64 kB limit */</span></span><br><span class="line">	gd-&gt;relocaddr &amp;= ~(<span class="number">0x10000</span> - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">	gd-&gt;arch.tlb_addr = gd-&gt;relocaddr;</span><br><span class="line">	debug(<span class="string">&quot;TLB table from %08lx to %08lx\n&quot;</span>, gd-&gt;arch.tlb_addr,</span><br><span class="line">	      gd-&gt;arch.tlb_addr + gd-&gt;arch.tlb_size);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>&#x3D;&#x3D;reserve_uboot：&#x3D;&#x3D;</p>
<ul>
<li><p>作用：留出code_len 的空间，并且把此时<code>relocaddr</code>地址付给<code>start_addr_sp</code>。<strong>注意，这里开始gd-&gt;relocaddr</strong>不再继续减小了，因为已经到了代码段都拷完的地方了，重定位的地址已经确定好了！！！</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">reserve_uboot</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	gd-&gt;relocaddr -= gd-&gt;mon_len;</span><br><span class="line">	gd-&gt;relocaddr &amp;= ~(<span class="number">4096</span> - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">	debug(<span class="string">&quot;Reserving %ldk for U-Boot at: %08lx\n&quot;</span>, gd-&gt;mon_len &gt;&gt; <span class="number">10</span>,</span><br><span class="line">	      gd-&gt;relocaddr);</span><br><span class="line"></span><br><span class="line">	gd-&gt;start_addr_sp = gd-&gt;relocaddr;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>其余剩余的reserve_xxx 函数都是在DDR 内存中，划分出对应区域给对应功能实用。有以下几个参数需要注意一下</p>
<ul>
<li><p>重定位offset 偏移：<code>gd-&gt;reloc_off = gd-&gt;relocaddr - CONFIG_SYS_TEXT_BASE;</code></p>
</li>
<li><p>会有一次gd 的搬运：，其中gd 的宏定义展开见下方，由于之前将<strong>将cpu ram 的gd 指针存储在R9</strong>中，所以芯片内部的ram 中有一份global_data结构体。新的gd 会放在全局变量后面：参考<code>reserve_global_data</code>函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//搬运：</span></span><br><span class="line">`<span class="built_in">memcpy</span>(gd-&gt;new_gd, (<span class="type">char</span> *)gd, <span class="keyword">sizeof</span>(<span class="type">gd_t</span>));`</span><br><span class="line"><span class="comment">//获取老gd 地址：</span></span><br><span class="line">__asm__ <span class="title function_">volatile</span><span class="params">(<span class="string">&quot;mov %0, r9\n&quot;</span> : <span class="string">&quot;=r&quot;</span> (gd_ptr))</span>;</span><br><span class="line"><span class="comment">//新GD 地址</span></span><br><span class="line"> gd-&gt;new_gd = (<span class="type">gd_t</span> *)map_sysmem(gd-&gt;start_addr_sp, <span class="keyword">sizeof</span>(<span class="type">gd_t</span>));</span><br><span class="line">   </span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>总结：由此 board_info 就执行完了，主要是初始化了DDR的内存布局，并且对golobal data 进行初始化，同时拷贝进了DDR中。</p>
</li>
</ul>
<h4 id="2-5-4-再次回到-main-函数"><a href="#2-5-4-再次回到-main-函数" class="headerlink" title="2.5.4 再次回到 _main 函数"></a>2.5.4 再次回到 _main 函数</h4><p>执行完DDR区域分配及配置好gd 之后，会执行下面的操作：</p>
<ul>
<li><p>把 sp设置到DDR上：<code>ldr   sp, [r9, #GD_START_ADDR_SP] /* sp = gd-&gt;start_addr_sp */</code></p>
</li>
<li><p>初始化栈，之后会执行代码段的重定位，需要注意<code>lr</code>的值，再次返回时就已经到DDR中的重定位地址了。</p>
</li>
<li><p>问题：当前代码在什么地址？**R:**根据obj dump 来看，在<code>87802800 &lt;_main&gt;:</code>DDR 中。</p>
</li>
<li><p>&#x3D;&#x3D;追问：&#x3D;&#x3D;那为什么需要再搬运一次地址？新搬运的地址在哪里？**R:**搬运的地址是<code>board_init_f()</code>中设置的地址，提高了灵活性？</p>
</li>
</ul>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"> <span class="meta">#<span class="keyword">if</span> defined(CONFIG_CPU_V7M)	<span class="comment">/* v7M forbids using SP as BIC destination */</span></span></span><br><span class="line"> 	mov	r3, sp</span><br><span class="line"> 	bic	r3, r3, #<span class="number">7</span></span><br><span class="line"> 	mov	sp, r3</span><br><span class="line"> <span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"> 	bic	sp, sp, #<span class="number">7</span>	<span class="comment">/* 8-byte alignment for ABI compliance */</span></span><br><span class="line"> <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"> 	ldr	r9, [r9, #GD_BD]		<span class="comment">/* r9 = gd-&gt;bd */</span></span><br><span class="line"> 	sub	r9, r9, #GD_SIZE		<span class="comment">/* new GD is below bd */</span> 获取新gd的位置？</span><br><span class="line"> </span><br><span class="line"> 	adr	lr, here</span><br><span class="line"> 	ldr	r0, [r9, #GD_RELOC_OFF]		<span class="comment">/* r0 = gd-&gt;reloc_off */</span></span><br><span class="line"> 	add	lr, lr, r0				  lr  = here 地址 + gd-&gt;reloc_off </span><br><span class="line"> <span class="meta">#<span class="keyword">if</span> defined(CONFIG_CPU_V7M)</span></span><br><span class="line"> 	orr	lr, #<span class="number">1</span>				<span class="comment">/* As required by Thumb-only */</span></span><br><span class="line"> <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"> 	ldr	r0, [r9, #GD_RELOCADDR]		<span class="comment">/* r0 = gd-&gt;relocaddr */</span></span><br><span class="line"> 	b	relocate_code			<span class="comment">/*代码从定位*/</span> 所以执行完这个，跳回的时候就已经在DDR中了？</span><br><span class="line"> here:</span><br><span class="line"> <span class="comment">/*</span></span><br><span class="line"><span class="comment">  * now relocate vectors</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> 	bl	relocate_vectors 	 </span><br><span class="line"> <span class="comment">/* Set up final (full) environment */</span></span><br><span class="line">bl	c_runtime_cpu_setup	<span class="comment">/* we still call old routine here */</span></span><br><span class="line"> <span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>执行<code>relocate_code</code>函数</p>
<p>​		见下方代码，r1是代码段起始地址，r0是传入的<code>gd-&gt;relocaddr</code>重定位地址，整体作用是判断起始地址和<code>relocaddr</code>是否相等，不相等的话就会进行代码段的搬运（__image_copy_start ~ image_copy_end）。然后进行<code>dyn</code>段，即动态代码段的符号表地址的更改。【此处涉及到elf文件的表示，有兴趣的可以查阅elf 文件格式，了解动态代码是如何执行的。】</p>
<p><strong>注意：</strong>这里跳转使用的是<code>b</code>而不是<strong>bl</strong>就是不需要更改<strong>LR</strong>的值，因为LR 已经被重定位了。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">ENTRY(relocate_code)</span><br><span class="line">	ldr	r1, =__image_copy_start	/* r1 &lt;- SRC &amp;__image_copy_start */</span><br><span class="line">	subs	r4, r0, r1		/* r4 &lt;- relocation offset */</span><br><span class="line">	beq	relocate_done		/* skip relocation */</span><br><span class="line">	ldr	r2, =__image_copy_end	/* r2 &lt;- SRC &amp;__image_copy_end */</span><br><span class="line"></span><br><span class="line">copy_loop:</span><br><span class="line">	ldmia	r1!, &#123;r10-r11&#125;		/* copy from source address [r1]    */</span><br><span class="line">	stmia	r0!, &#123;r10-r11&#125;		/* copy to   target address [r0]    */</span><br><span class="line">	cmp	r1, r2			/* until source end address [r2]    */</span><br><span class="line">	blo	copy_loop</span><br><span class="line"></span><br><span class="line">	/*</span><br><span class="line">	 * fix .rel.dyn relocations</span><br><span class="line">	 */</span><br><span class="line">	ldr	r2, =__rel_dyn_start	/* r2 &lt;- SRC &amp;__rel_dyn_start */</span><br><span class="line">	ldr	r3, =__rel_dyn_end	/* r3 &lt;- SRC &amp;__rel_dyn_end */</span><br><span class="line">fixloop:</span><br><span class="line">	ldmia	r2!, &#123;r0-r1&#125;		/* (r0,r1) &lt;- (SRC location,fixup) */</span><br><span class="line">	and	r1, r1, #0xff</span><br><span class="line">	cmp	r1, #23			/* relative fixup? */</span><br><span class="line">	bne	fixnext</span><br><span class="line"></span><br><span class="line">	/* relative fix: increase location by offset */</span><br><span class="line">	add	r0, r0, r4</span><br><span class="line">	ldr	r1, [r0]</span><br><span class="line">	add	r1, r1, r4</span><br><span class="line">	str	r1, [r0]</span><br><span class="line">fixnext:</span><br><span class="line">	cmp	r2, r3</span><br><span class="line">	blo	fixloop</span><br><span class="line"></span><br><span class="line">relocate_done:</span><br><span class="line">	bx	lr</span><br><span class="line">ENDPROC(relocate_code)</span><br></pre></td></tr></table></figure>
</li>
<li><p>向量表的重定位：</p>
<p>由于<code>arm</code>处理器将向量表放在代码头部，所以这里中断向量表的重定位也是设置 cp15-c12 的值，将其设置为<code>gd-&gt;relocaddr</code>，即重定位代码段的首地址。编译后的程序如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ENTRY(relocate_vectors)	</span><br><span class="line">	ldr	r0, [r9, #GD_RELOCADDR]	/* r0 = gd-&gt;relocaddr */</span><br><span class="line">	mcr     p15, 0, r0, c12, c0, 0  /* Set VBAR */</span><br><span class="line">	bx	lr</span><br><span class="line">ENDPROC(relocate_vectors)	</span><br></pre></td></tr></table></figure>
</li>
<li><p>执行<code>c_runtime_cpu_setup 函数</code>，此代码在<code>arch/arm/cpu/armv7/start.S </code>中，作用是关闭指令cache</p>
</li>
<li><p>执行清除BSS段的汇编代码</p>
</li>
<li><p>跳转执行到<code>board_init_r()</code>，至此<strong>—main</strong>函数运行结束。</p>
</li>
</ul>
<h3 id="2-6-执行board-init-r函数，开始最后的初始化"><a href="#2-6-执行board-init-r函数，开始最后的初始化" class="headerlink" title="2.6 执行board_init_r函数，开始最后的初始化"></a>2.6 执行board_init_r函数，开始最后的初始化</h3><p>board_init_r函数如下，如同board_init_f 函数，主要是遍历了<code>init_sequence_r</code>这样一个函数指针结构提。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">void board_init_r(gd_t *new_gd, ulong dest_addr)</span><br><span class="line">&#123;</span><br><span class="line">	if (initcall_run_list(init_sequence_r))</span><br><span class="line">		hang();</span><br><span class="line">	/* NOTREACHED - run_main_loop() does not return */</span><br><span class="line">	hang();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同样，对于<code>init_sequence_r</code>这样一个函数指针数据，我们分析其条件条件编译之后的参数项</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">init_fnc_t</span> init_sequence_r[] = &#123;</span><br><span class="line">	initr_trace, <span class="comment">/* 初始化追踪调试内容 */</span></span><br><span class="line">	initr_reloc,	<span class="comment">/* gd-&gt;flags |= GD_FLG_RELOC | GD_FLG_FULL_MALLOC_INIT; 表示重定位完成 */</span></span><br><span class="line">	<span class="comment">/* <span class="doctag">TODO:</span> could x86/PPC have this also perhaps? */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_ARM</span></span><br><span class="line">	initr_caches,<span class="comment">/* 使能cache  */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	initr_reloc_global_data, <span class="comment">/* 修改重定位之后的 gd 参数 */</span></span><br><span class="line">	initr_barrier,			<span class="comment">/*  I.MX6ULL 来说是空函数   */</span></span><br><span class="line">	initr_malloc,			<span class="comment">/* 初始化 malloc 的内存空间，一些全局变量参数  */</span></span><br><span class="line">	initr_console_record,	<span class="comment">/* I.MX6ULL 来说是空函数  */</span></span><br><span class="line">	bootstage_relocate,		<span class="comment">/* bootstage重定位-但实际未看到*/</span></span><br><span class="line">	initr_bootstage,		<span class="comment">/* 初始化 bootstage*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(CONFIG_ARM) || defined(CONFIG_NDS32)</span></span><br><span class="line">	board_init,	<span class="comment">/* Setup chipselects 	- 片上外设初始化在这里 USB IIC FEC QSPI 等等*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	stdio_init_tables,		<span class="comment">/* 初始化 STDIO */</span></span><br><span class="line">	initr_serial,			<span class="comment">/* 串行设备初始化 */</span></span><br><span class="line">	initr_announce,</span><br><span class="line">	INIT_FUNC_WATCHDOG_RESET    </span><br><span class="line">	power_init_board,       <span class="comment">/* 电源初始化- imx6ull 来说是空函数*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_GENERIC_MMC</span></span><br><span class="line">	initr_mmc,				<span class="comment">/* 初始化mmc */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    initr_env,				<span class="comment">/* 环境变量初始化 */</span></span><br><span class="line">   	INIT_FUNC_WATCHDOG_RESET</span><br><span class="line">	initr_secondary_cpu,	<span class="comment">/* 多核初始化,I.MX6ULL 来说是空函数 */</span></span><br><span class="line">   	stdio_add_devices,		<span class="comment">/* 各种输入输出外设初始化 */</span></span><br><span class="line">	initr_jumptable,		<span class="comment">/* 初始化跳转表 */</span></span><br><span class="line">    console_init_r,			<span class="comment">/* 人机交互控制台初始化 */</span></span><br><span class="line">    interrupt_init,			<span class="comment">/* 中断堆栈初始化 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(CONFIG_ARM) || defined(CONFIG_AVR32)</span></span><br><span class="line">	initr_enable_interrupts,	<span class="comment">/* 中断使能 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="meta">#<span class="keyword">ifdef</span> CONFIG_CMD_NET</span></span><br><span class="line">	initr_ethaddr,			<span class="comment">/* 获取环境变量“ethaddr” 来初始化MAC的值 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_BOARD_LATE_INIT</span></span><br><span class="line">	board_late_init,		<span class="comment">/* 后续初始化，如果环境变量需要存储在EMMC/SD 中的话， 会初始化EMMC,并且调用了 cmd 接口*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_CMD_NET</span></span><br><span class="line">	INIT_FUNC_WATCHDOG_RESET</span><br><span class="line">	initr_net,				<span class="comment">/* 网口初始化 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">        imx6_light_up_led2,</span><br><span class="line"></span><br><span class="line">	run_main_loop,			<span class="comment">/* uboot 的主命令循环 */</span></span><br><span class="line">&#125;;       </span><br></pre></td></tr></table></figure>

<p>由上注释可见，调用<code>board_init_r</code>函数更多的是板级初始化的设置，让整个SOC板子和外设能够正常的运行起来，进入到main_loop 的函数。</p>
<h2 id="3-整体函数调用框架"><a href="#3-整体函数调用框架" class="headerlink" title="3. 整体函数调用框架"></a>3. 整体函数调用框架</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">a[reset]--&gt;|set scv mode|cpu_init_cp15</span><br><span class="line">a--&gt;cpu_init_crit--&gt;lowlevel_init--&gt;s_init</span><br><span class="line">a--&gt;b[_main]</span><br><span class="line">b--&gt;board_init_f_alloc_reserve</span><br><span class="line">b--&gt;board_init_f_init_reserve</span><br><span class="line">b--&gt;board_init_f--&gt;initcall_run_list-init_sequence_f</span><br><span class="line">b--&gt;relocate_code</span><br><span class="line">b--&gt;relocate_vectors</span><br><span class="line">b--&gt;|bss-init|c_runtime_cpu_setup</span><br><span class="line">b--&gt;board_init_r</span><br></pre></td></tr></table></figure>



<p>有了整体框架之后我们依次简短的介绍下各个函数的作用</p>
<ul>
<li>cpu_init_cp15：在进入SVC 模式之后，关闭各种Cache、MMU，读取<code>CPU variant + revision</code>CPU 信息。</li>
<li>cpu_init_crit：第一次初始化 SP 在CPU内部的SRAM中。并且给结构体数组<code>gd_date</code>留出空间，把<code>gd_data</code>的指针赋值给r9，后面可以直接通过r9寄存器调用gd。（sram内部）然后调用s_init了。</li>
<li>board_init_f_alloc_reserve：在_main 函数中会重新设定<code>sp</code>的值为<code>CONFIG_SYS_INIT_SP_ADDR</code>，在此函数中会在sram中留出<strong>malloc 和 global_data</strong>的空间</li>
<li>board_init_f_init_reserve：把global_data 的空间清0，并且设定malloc 的空间起始地址。为执行C语言的环境做准备。</li>
<li>board_init_f：调用<code>initcall_run_list(init_sequence_f)</code>函数来初步板级初始化（CPU特性、时钟、环境变量、串行显示等）和对内存的划分（boot 使用的内存空间、global_date、relocate、mmu_TLB、ENV）信息的存储。</li>
<li>relocate_code &amp; relocate_vectors：代码和中断向量的重定位</li>
<li>board_init_r：调用<code>initcall_run_list(init_sequence_r)</code>函数来进一步初始化板级外设、设置和开启中断，最后进入<strong>run_main_loop</strong>函数等待执行命令。</li>
</ul>
</div><div class="article-licensing box"><div class="licensing-title"><p><a href="https://satelite98.github.io/2024/06/06/uboot&amp;linux/uboot_1/">https://satelite98.github.io/2024/06/06/uboot&amp;linux/uboot_1/</a></p></div><div class="licensing-meta level is-mobile"><div class="level-left"><div class="level-item is-narrow"><div><h6>作者</h6><p>John Doe</p></div></div><div class="level-item is-narrow"><div><h6>发布于</h6><p>2024-06-06</p></div></div><div class="level-item is-narrow"><div><h6>更新于</h6><p>2024-06-06</p></div></div><div class="level-item is-narrow"><div><h6>许可协议</h6><p><a class="icons" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="icon fab fa-creative-commons"></i></a><a class="icons" rel="noopener" target="_blank" title="Attribution" href="https://creativecommons.org/licenses/by/4.0/"><i class="icon fab fa-creative-commons-by"></i></a><a class="icons" rel="noopener" target="_blank" title="Noncommercial" href="https://creativecommons.org/licenses/by-nc/4.0/"><i class="icon fab fa-creative-commons-nc"></i></a></p></div></div></div></div></div><div class="notification is-danger">You need to set <code>install_url</code> to use ShareThis. Please set it in <code>_config.yml</code>.</div></article></div><div class="card"><div class="card-content"><h3 class="menu-label has-text-centered">喜欢这篇文章？打赏一下作者吧</h3><div class="buttons is-centered"><a class="button donate" href="/" target="_blank" rel="noopener" data-type="afdian"><span class="icon is-small"><i class="fas fa-charging-station"></i></span><span>爱发电</span></a><a class="button donate" data-type="alipay"><span class="icon is-small"><i class="fab fa-alipay"></i></span><span>支付宝</span><span class="qrcode"><img src="/" alt="支付宝"></span></a><a class="button donate" href="/" target="_blank" rel="noopener" data-type="buymeacoffee"><span class="icon is-small"><i class="fas fa-coffee"></i></span><span>送我杯咖啡</span></a><a class="button donate" href="/" target="_blank" rel="noopener" data-type="patreon"><span class="icon is-small"><i class="fab fa-patreon"></i></span><span>Patreon</span></a><div class="notification is-danger">You forgot to set the <code>business</code> or <code>currency_code</code> for Paypal. Please set it in <code>_config.yml</code>.</div><a class="button donate" data-type="wechat"><span class="icon is-small"><i class="fab fa-weixin"></i></span><span>微信</span><span class="qrcode"><img src="/" alt="微信"></span></a></div></div></div><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/2024/06/06/uboot&amp;linux/uboot_2/"><i class="level-item fas fa-chevron-left"></i><span class="level-item"> </span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/2024/06/06/uboot&amp;linux/makefile_analyse/"><span class="level-item"> </span><i class="level-item fas fa-chevron-right"></i></a></div></nav><div class="card"><div class="card-content"><h3 class="title is-5">评论</h3><div class="notification is-danger">You forgot to set the <code>shortname</code> for Disqus. Please set it in <code>_config.yml</code>.</div></div></div></div><div class="column column-left is-4-tablet is-4-desktop is-4-widescreen  order-1"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar" src="/img/my.png" alt="Satellite"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">Satellite</p><p class="is-size-6 is-block">none</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>SZHOU,CHINA</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/archives"><p class="title">13</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/categories"><p class="title">2</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/tags"><p class="title">0</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/ppoffice" target="_blank" rel="me noopener">关注我</a></div></div></div><!--!--><div class="card widget" data-type="links"><div class="card-content"><div class="menu"><h3 class="menu-label">链接</h3><ul class="menu-list"><li><a class="level is-mobile" href="https://hexo.io" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Hexo</span></span><span class="level-right"><span class="level-item tag">hexo.io</span></span></a></li><li><a class="level is-mobile" href="https://bulma.io" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Bulma</span></span><span class="level-right"><span class="level-item tag">bulma.io</span></span></a></li></ul></div></div></div><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">分类</h3><ul class="menu-list"><li><a class="level is-mobile" href="/categories/uboot-linux/"><span class="level-start"><span class="level-item">uboot_linux</span></span><span class="level-end"><span class="level-item tag">6</span></span></a></li><li><a class="level is-mobile" href="/categories/%E7%A7%AF%E7%B4%AF/"><span class="level-start"><span class="level-item">积累</span></span><span class="level-end"><span class="level-item tag">7</span></span></a></li></ul></div></div></div><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">最新文章</h3><article class="media"><div class="media-content"><p class="date"><time dateTime="2024-06-06T15:00:09.076Z">2024-06-06</time></p><p class="title"><a href="/2024/06/06/%E7%A7%AF%E7%B4%AF/%E9%9A%8F%E7%AC%94%E9%97%AE%E9%A2%98/"> </a></p><p class="categories"><a href="/categories/%E7%A7%AF%E7%B4%AF/">积累</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2024-06-06T15:00:09.075Z">2024-06-06</time></p><p class="title"><a href="/2024/06/06/%E7%A7%AF%E7%B4%AF/vscode+clangd/"> </a></p><p class="categories"><a href="/categories/%E7%A7%AF%E7%B4%AF/">积累</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2024-06-06T15:00:09.074Z">2024-06-06</time></p><p class="title"><a href="/2024/06/06/uboot&amp;linux/uboot_analyse/"> </a></p><p class="categories"><a href="/categories/uboot-linux/">uboot_linux</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2024-06-06T15:00:09.072Z">2024-06-06</time></p><p class="title"><a href="/2024/06/06/uboot&amp;linux/uboot_3/"> </a></p><p class="categories"><a href="/categories/uboot-linux/">uboot_linux</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2024-06-06T15:00:09.071Z">2024-06-06</time></p><p class="title"><a href="/2024/06/06/uboot&amp;linux/uboot_2/"> </a></p><p class="categories"><a href="/categories/uboot-linux/">uboot_linux</a></p></div></article></div></div><div class="card widget" data-type="archives"><div class="card-content"><div class="menu"><h3 class="menu-label">归档</h3><ul class="menu-list"><li><a class="level is-mobile" href="/archives/2024/06/"><span class="level-start"><span class="level-item">六月 2024</span></span><span class="level-end"><span class="level-item tag">13</span></span></a></li></ul></div></div></div><!--!--><div class="card widget" data-type="subscribe-email"><div class="card-content"><div class="menu"><h3 class="menu-label">订阅更新</h3><form action="https://feedburner.google.com/fb/a/mailverify" method="post" target="popupwindow" onsubmit="window.open(&#039;https://feedburner.google.com/fb/a/mailverify?uri=&#039;,&#039;popupwindow&#039;,&#039;scrollbars=yes,width=550,height=520&#039;);return true"><input type="hidden" value="" name="uri"><input type="hidden" name="loc" value="en_US"><div class="field has-addons"><div class="control has-icons-left is-expanded"><input class="input" name="email" type="email" placeholder="Email"><span class="icon is-small is-left"><i class="fas fa-envelope"></i></span></div><div class="control"><input class="button" type="submit" value="订阅"></div></div></form></div></div></div><div class="card widget"><div class="card-content"><div class="notification is-danger">You need to set <code>client_id</code> and <code>slot_id</code> to show this AD unit. Please set it in <code>_config.yml</code>.</div></div></div><div class="card widget" data-type="subscribe-email"><div class="card-content"><div class="menu"><h3 class="menu-label">follow.it</h3><form action="" method="post" target="_blank"><div class="field has-addons"><div class="control has-icons-left is-expanded"><input class="input" name="email" type="email" placeholder="Email"><span class="icon is-small is-left"><i class="fas fa-envelope"></i></span></div><div class="control"><input class="button" type="submit" value="订阅"></div></div></form></div></div></div></div><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/logo.svg" alt="Hexo" height="28"></a><p class="is-size-7"><span>&copy; 2024 John Doe</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p><p class="is-size-7">© 2019</p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("zh-cn");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script data-pjax src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script data-pjax src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "此网站使用Cookie来改善您的体验。",
          dismiss: "知道了！",
          allow: "允许使用Cookie",
          deny: "拒绝",
          link: "了解更多",
          policy: "Cookie政策",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/pjax@0.2.8/pjax.min.js"></script><script src="/js/pjax.js"></script><!--!--><!--!--><!--!--><script data-pjax src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>